<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>slack_sdk.audit_logs.v1.async_client API documentation</title>
<meta name="description" content="Audit Logs API is a set of APIs for monitoring what’s happening in your Enterprise Grid organization …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>slack_sdk.audit_logs.v1.async_client</code></h1>
</header>
<section id="section-intro">
<p>Audit Logs API is a set of APIs for monitoring what’s happening in your Enterprise Grid organization.</p>
<p>Refer to <a href="https://slack.dev/python-slack-sdk/audit-logs/">https://slack.dev/python-slack-sdk/audit-logs/</a> for details.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Audit Logs API is a set of APIs for monitoring what’s happening in your Enterprise Grid organization.

Refer to https://slack.dev/python-slack-sdk/audit-logs/ for details.
&#34;&#34;&#34;
import json
import logging
from ssl import SSLContext
from typing import Any, List
from typing import Dict, Optional

import aiohttp
from aiohttp import BasicAuth, ClientSession

from slack_sdk.errors import SlackApiError
from .internal_utils import (
    _build_request_headers,
    _debug_log_response,
    get_user_agent,
)
from .response import AuditLogsResponse
from slack_sdk.http_retry.async_handler import AsyncRetryHandler
from slack_sdk.http_retry.builtin_async_handlers import async_default_handlers
from slack_sdk.http_retry.request import HttpRequest as RetryHttpRequest
from slack_sdk.http_retry.response import HttpResponse as RetryHttpResponse
from slack_sdk.http_retry.state import RetryState
from ...proxy_env_variable_loader import load_http_proxy_from_env


class AsyncAuditLogsClient:
    BASE_URL = &#34;https://api.slack.com/audit/v1/&#34;

    token: str
    timeout: int
    ssl: Optional[SSLContext]
    proxy: Optional[str]
    base_url: str
    session: Optional[ClientSession]
    trust_env_in_session: bool
    auth: Optional[BasicAuth]
    default_headers: Dict[str, str]
    logger: logging.Logger
    retry_handlers: List[AsyncRetryHandler]

    def __init__(
        self,
        token: str,
        timeout: int = 30,
        ssl: Optional[SSLContext] = None,
        proxy: Optional[str] = None,
        base_url: str = BASE_URL,
        session: Optional[ClientSession] = None,
        trust_env_in_session: bool = False,
        auth: Optional[BasicAuth] = None,
        default_headers: Optional[Dict[str, str]] = None,
        user_agent_prefix: Optional[str] = None,
        user_agent_suffix: Optional[str] = None,
        logger: Optional[logging.Logger] = None,
        retry_handlers: Optional[List[AsyncRetryHandler]] = None,
    ):
        &#34;&#34;&#34;API client for Audit Logs API
        See https://api.slack.com/admins/audit-logs for more details

        Args:
            token: An admin user&#39;s token, which starts with `xoxp-`
            timeout: Request timeout (in seconds)
            ssl: `ssl.SSLContext` to use for requests
            proxy: Proxy URL (e.g., `localhost:9000`, `http://localhost:9000`)
            base_url: The base URL for API calls
            session: `aiohttp.ClientSession` instance
            trust_env_in_session: True/False for `aiohttp.ClientSession`
            auth: Basic auth info for `aiohttp.ClientSession`
            default_headers: Request headers to add to all requests
            user_agent_prefix: Prefix for User-Agent header value
            user_agent_suffix: Suffix for User-Agent header value
            logger: Custom logger
            retry_handlers: Retry handlers
        &#34;&#34;&#34;
        self.token = token
        self.timeout = timeout
        self.ssl = ssl
        self.proxy = proxy
        self.base_url = base_url
        self.session = session
        self.trust_env_in_session = trust_env_in_session
        self.auth = auth
        self.default_headers = default_headers if default_headers else {}
        self.default_headers[&#34;User-Agent&#34;] = get_user_agent(user_agent_prefix, user_agent_suffix)
        self.logger = logger if logger is not None else logging.getLogger(__name__)
        self.retry_handlers = retry_handlers if retry_handlers is not None else async_default_handlers()

        if self.proxy is None or len(self.proxy.strip()) == 0:
            env_variable = load_http_proxy_from_env(self.logger)
            if env_variable is not None:
                self.proxy = env_variable

    async def schemas(
        self,
        *,
        query_params: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
    ) -&gt; AuditLogsResponse:
        &#34;&#34;&#34;Returns information about the kind of objects which the Audit Logs API
        returns as a list of all objects and a short description.
        Authentication not required.

        Args:
            query_params: Set any values if you want to add query params
            headers: Additional request headers
        Returns:
            API response
        &#34;&#34;&#34;
        return await self.api_call(
            path=&#34;schemas&#34;,
            query_params=query_params,
            headers=headers,
        )

    async def actions(
        self,
        *,
        query_params: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
    ) -&gt; AuditLogsResponse:
        &#34;&#34;&#34;Returns information about the kind of actions that the Audit Logs API
        returns as a list of all actions and a short description of each.
        Authentication not required.

        Args:
            query_params: Set any values if you want to add query params
            headers: Additional request headers

        Returns:
            API response
        &#34;&#34;&#34;
        return await self.api_call(
            path=&#34;actions&#34;,
            query_params=query_params,
            headers=headers,
        )

    async def logs(
        self,
        *,
        latest: Optional[int] = None,
        oldest: Optional[int] = None,
        limit: Optional[int] = None,
        action: Optional[str] = None,
        actor: Optional[str] = None,
        entity: Optional[str] = None,
        cursor: Optional[str] = None,
        additional_query_params: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
    ) -&gt; AuditLogsResponse:
        &#34;&#34;&#34;This is the primary endpoint for retrieving actual audit events from your organization.
        It will return a list of actions that have occurred on the installed workspace or grid organization.
        Authentication required.

        The following filters can be applied in order to narrow the range of actions returned.
        Filters are added as query string parameters and can be combined together.
        Multiple filter parameters are additive (a boolean AND) and are separated
        with an ampersand (&amp;) in the query string. Filtering is entirely optional.

        Args:
            latest: Unix timestamp of the most recent audit event to include (inclusive).
            oldest: Unix timestamp of the least recent audit event to include (inclusive).
                Data is not available prior to March 2018.
            limit: Number of results to optimistically return, maximum 9999.
            action: Name of the action.
            actor: User ID who initiated the action.
            entity: ID of the target entity of the action (such as a channel, workspace, organization, file).
            cursor: The next page cursor of pagination
            additional_query_params: Add anything else if you need to use the ones this library does not support
            headers: Additional request headers

        Returns:
            API response
        &#34;&#34;&#34;
        query_params = {
            &#34;latest&#34;: latest,
            &#34;oldest&#34;: oldest,
            &#34;limit&#34;: limit,
            &#34;action&#34;: action,
            &#34;actor&#34;: actor,
            &#34;entity&#34;: entity,
            &#34;cursor&#34;: cursor,
        }
        if additional_query_params is not None:
            query_params.update(additional_query_params)
        query_params = {k: v for k, v in query_params.items() if v is not None}
        return await self.api_call(
            path=&#34;logs&#34;,
            query_params=query_params,
            headers=headers,
        )

    async def api_call(
        self,
        *,
        http_verb: str = &#34;GET&#34;,
        path: str,
        query_params: Optional[Dict[str, Any]] = None,
        body_params: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
    ) -&gt; AuditLogsResponse:
        url = f&#34;{self.base_url}{path}&#34;
        return await self._perform_http_request(
            http_verb=http_verb,
            url=url,
            query_params=query_params,
            body_params=body_params,
            headers=_build_request_headers(
                token=self.token,
                default_headers=self.default_headers,
                additional_headers=headers,
            ),
        )

    async def _perform_http_request(
        self,
        *,
        http_verb: str,
        url: str,
        query_params: Optional[Dict[str, Any]],
        body_params: Optional[Dict[str, Any]],
        headers: Dict[str, str],
    ) -&gt; AuditLogsResponse:
        if body_params is not None:
            body_params = json.dumps(body_params)
        headers[&#34;Content-Type&#34;] = &#34;application/json;charset=utf-8&#34;

        session: Optional[ClientSession] = None
        use_running_session = self.session and not self.session.closed
        if use_running_session:
            session = self.session
        else:
            session = aiohttp.ClientSession(
                timeout=aiohttp.ClientTimeout(total=self.timeout),
                auth=self.auth,
                trust_env=self.trust_env_in_session,
            )

        last_error = None
        resp: Optional[AuditLogsResponse] = None
        try:
            request_kwargs = {
                &#34;headers&#34;: headers,
                &#34;params&#34;: query_params,
                &#34;data&#34;: body_params,
                &#34;ssl&#34;: self.ssl,
                &#34;proxy&#34;: self.proxy,
            }
            retry_request = RetryHttpRequest(
                method=http_verb,
                url=url,
                headers=headers,
                body_params=body_params,
            )

            retry_state = RetryState()
            counter_for_safety = 0
            while counter_for_safety &lt; 100:
                counter_for_safety += 1
                # If this is a retry, the next try started here. We can reset the flag.
                retry_state.next_attempt_requested = False
                retry_response: Optional[RetryHttpResponse] = None
                response_body = &#34;&#34;

                if self.logger.level &lt;= logging.DEBUG:
                    headers_for_logging = {
                        k: &#34;(redacted)&#34; if k.lower() == &#34;authorization&#34; else v for k, v in headers.items()
                    }
                    self.logger.debug(
                        f&#34;Sending a request - &#34;
                        f&#34;url: {url}, &#34;
                        f&#34;params: {query_params}, &#34;
                        f&#34;body: {body_params}, &#34;
                        f&#34;headers: {headers_for_logging}&#34;
                    )

                try:
                    async with session.request(http_verb, url, **request_kwargs) as res:
                        try:
                            response_body = await res.text()
                            retry_response = RetryHttpResponse(
                                status_code=res.status,
                                headers=res.headers,
                                data=response_body.encode(&#34;utf-8&#34;) if response_body is not None else None,
                            )
                        except aiohttp.ContentTypeError:
                            self.logger.debug(f&#34;No response data returned from the following API call: {url}.&#34;)
                            retry_response = RetryHttpResponse(
                                status_code=res.status,
                                headers=res.headers,
                            )
                        except json.decoder.JSONDecodeError as e:
                            message = f&#34;Failed to parse the response body: {str(e)}&#34;
                            raise SlackApiError(message, res)

                        if res.status == 429:
                            for handler in self.retry_handlers:
                                if await handler.can_retry_async(
                                    state=retry_state,
                                    request=retry_request,
                                    response=retry_response,
                                ):
                                    if self.logger.level &lt;= logging.DEBUG:
                                        self.logger.info(
                                            f&#34;A retry handler found: {type(handler).__name__} &#34;
                                            f&#34;for {http_verb} {url} - rate_limited&#34;
                                        )
                                    await handler.prepare_for_next_attempt_async(
                                        state=retry_state,
                                        request=retry_request,
                                        response=retry_response,
                                    )
                                    break

                        if retry_state.next_attempt_requested is False:
                            resp = AuditLogsResponse(
                                url=url,
                                status_code=res.status,
                                raw_body=response_body,
                                headers=res.headers,
                            )
                            _debug_log_response(self.logger, resp)
                            return resp

                except Exception as e:
                    last_error = e
                    for handler in self.retry_handlers:
                        if await handler.can_retry_async(
                            state=retry_state,
                            request=retry_request,
                            response=retry_response,
                            error=e,
                        ):
                            if self.logger.level &lt;= logging.DEBUG:
                                self.logger.info(
                                    f&#34;A retry handler found: {type(handler).__name__} &#34; f&#34;for {http_verb} {url} - {e}&#34;
                                )
                            await handler.prepare_for_next_attempt_async(
                                state=retry_state,
                                request=retry_request,
                                response=retry_response,
                                error=e,
                            )
                            break

                    if retry_state.next_attempt_requested is False:
                        raise last_error

            if resp is not None:
                return resp
            raise last_error

        finally:
            if not use_running_session:
                await session.close()

        return resp</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient"><code class="flex name class">
<span>class <span class="ident">AsyncAuditLogsClient</span></span>
<span>(</span><span>token: str, timeout: int = 30, ssl: Optional[ssl.SSLContext] = None, proxy: Optional[str] = None, base_url: str = 'https://api.slack.com/audit/v1/', session: Optional[aiohttp.client.ClientSession] = None, trust_env_in_session: bool = False, auth: Optional[aiohttp.helpers.BasicAuth] = None, default_headers: Optional[Dict[str, str]] = None, user_agent_prefix: Optional[str] = None, user_agent_suffix: Optional[str] = None, logger: Optional[logging.Logger] = None, retry_handlers: Optional[List[slack_sdk.http_retry.async_handler.AsyncRetryHandler]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>API client for Audit Logs API
See <a href="https://api.slack.com/admins/audit-logs">https://api.slack.com/admins/audit-logs</a> for more details</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>token</code></strong></dt>
<dd>An admin user's token, which starts with <code>xoxp-</code></dd>
<dt><strong><code>timeout</code></strong></dt>
<dd>Request timeout (in seconds)</dd>
<dt><strong><code>ssl</code></strong></dt>
<dd><code>ssl.SSLContext</code> to use for requests</dd>
<dt><strong><code>proxy</code></strong></dt>
<dd>Proxy URL (e.g., <code>localhost:9000</code>, <code>http://localhost:9000</code>)</dd>
<dt><strong><code>base_url</code></strong></dt>
<dd>The base URL for API calls</dd>
<dt><strong><code>session</code></strong></dt>
<dd><code>aiohttp.ClientSession</code> instance</dd>
<dt><strong><code>trust_env_in_session</code></strong></dt>
<dd>True/False for <code>aiohttp.ClientSession</code></dd>
<dt><strong><code>auth</code></strong></dt>
<dd>Basic auth info for <code>aiohttp.ClientSession</code></dd>
<dt><strong><code>default_headers</code></strong></dt>
<dd>Request headers to add to all requests</dd>
<dt><strong><code>user_agent_prefix</code></strong></dt>
<dd>Prefix for User-Agent header value</dd>
<dt><strong><code>user_agent_suffix</code></strong></dt>
<dd>Suffix for User-Agent header value</dd>
<dt><strong><code>logger</code></strong></dt>
<dd>Custom logger</dd>
<dt><strong><code>retry_handlers</code></strong></dt>
<dd>Retry handlers</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AsyncAuditLogsClient:
    BASE_URL = &#34;https://api.slack.com/audit/v1/&#34;

    token: str
    timeout: int
    ssl: Optional[SSLContext]
    proxy: Optional[str]
    base_url: str
    session: Optional[ClientSession]
    trust_env_in_session: bool
    auth: Optional[BasicAuth]
    default_headers: Dict[str, str]
    logger: logging.Logger
    retry_handlers: List[AsyncRetryHandler]

    def __init__(
        self,
        token: str,
        timeout: int = 30,
        ssl: Optional[SSLContext] = None,
        proxy: Optional[str] = None,
        base_url: str = BASE_URL,
        session: Optional[ClientSession] = None,
        trust_env_in_session: bool = False,
        auth: Optional[BasicAuth] = None,
        default_headers: Optional[Dict[str, str]] = None,
        user_agent_prefix: Optional[str] = None,
        user_agent_suffix: Optional[str] = None,
        logger: Optional[logging.Logger] = None,
        retry_handlers: Optional[List[AsyncRetryHandler]] = None,
    ):
        &#34;&#34;&#34;API client for Audit Logs API
        See https://api.slack.com/admins/audit-logs for more details

        Args:
            token: An admin user&#39;s token, which starts with `xoxp-`
            timeout: Request timeout (in seconds)
            ssl: `ssl.SSLContext` to use for requests
            proxy: Proxy URL (e.g., `localhost:9000`, `http://localhost:9000`)
            base_url: The base URL for API calls
            session: `aiohttp.ClientSession` instance
            trust_env_in_session: True/False for `aiohttp.ClientSession`
            auth: Basic auth info for `aiohttp.ClientSession`
            default_headers: Request headers to add to all requests
            user_agent_prefix: Prefix for User-Agent header value
            user_agent_suffix: Suffix for User-Agent header value
            logger: Custom logger
            retry_handlers: Retry handlers
        &#34;&#34;&#34;
        self.token = token
        self.timeout = timeout
        self.ssl = ssl
        self.proxy = proxy
        self.base_url = base_url
        self.session = session
        self.trust_env_in_session = trust_env_in_session
        self.auth = auth
        self.default_headers = default_headers if default_headers else {}
        self.default_headers[&#34;User-Agent&#34;] = get_user_agent(user_agent_prefix, user_agent_suffix)
        self.logger = logger if logger is not None else logging.getLogger(__name__)
        self.retry_handlers = retry_handlers if retry_handlers is not None else async_default_handlers()

        if self.proxy is None or len(self.proxy.strip()) == 0:
            env_variable = load_http_proxy_from_env(self.logger)
            if env_variable is not None:
                self.proxy = env_variable

    async def schemas(
        self,
        *,
        query_params: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
    ) -&gt; AuditLogsResponse:
        &#34;&#34;&#34;Returns information about the kind of objects which the Audit Logs API
        returns as a list of all objects and a short description.
        Authentication not required.

        Args:
            query_params: Set any values if you want to add query params
            headers: Additional request headers
        Returns:
            API response
        &#34;&#34;&#34;
        return await self.api_call(
            path=&#34;schemas&#34;,
            query_params=query_params,
            headers=headers,
        )

    async def actions(
        self,
        *,
        query_params: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
    ) -&gt; AuditLogsResponse:
        &#34;&#34;&#34;Returns information about the kind of actions that the Audit Logs API
        returns as a list of all actions and a short description of each.
        Authentication not required.

        Args:
            query_params: Set any values if you want to add query params
            headers: Additional request headers

        Returns:
            API response
        &#34;&#34;&#34;
        return await self.api_call(
            path=&#34;actions&#34;,
            query_params=query_params,
            headers=headers,
        )

    async def logs(
        self,
        *,
        latest: Optional[int] = None,
        oldest: Optional[int] = None,
        limit: Optional[int] = None,
        action: Optional[str] = None,
        actor: Optional[str] = None,
        entity: Optional[str] = None,
        cursor: Optional[str] = None,
        additional_query_params: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
    ) -&gt; AuditLogsResponse:
        &#34;&#34;&#34;This is the primary endpoint for retrieving actual audit events from your organization.
        It will return a list of actions that have occurred on the installed workspace or grid organization.
        Authentication required.

        The following filters can be applied in order to narrow the range of actions returned.
        Filters are added as query string parameters and can be combined together.
        Multiple filter parameters are additive (a boolean AND) and are separated
        with an ampersand (&amp;) in the query string. Filtering is entirely optional.

        Args:
            latest: Unix timestamp of the most recent audit event to include (inclusive).
            oldest: Unix timestamp of the least recent audit event to include (inclusive).
                Data is not available prior to March 2018.
            limit: Number of results to optimistically return, maximum 9999.
            action: Name of the action.
            actor: User ID who initiated the action.
            entity: ID of the target entity of the action (such as a channel, workspace, organization, file).
            cursor: The next page cursor of pagination
            additional_query_params: Add anything else if you need to use the ones this library does not support
            headers: Additional request headers

        Returns:
            API response
        &#34;&#34;&#34;
        query_params = {
            &#34;latest&#34;: latest,
            &#34;oldest&#34;: oldest,
            &#34;limit&#34;: limit,
            &#34;action&#34;: action,
            &#34;actor&#34;: actor,
            &#34;entity&#34;: entity,
            &#34;cursor&#34;: cursor,
        }
        if additional_query_params is not None:
            query_params.update(additional_query_params)
        query_params = {k: v for k, v in query_params.items() if v is not None}
        return await self.api_call(
            path=&#34;logs&#34;,
            query_params=query_params,
            headers=headers,
        )

    async def api_call(
        self,
        *,
        http_verb: str = &#34;GET&#34;,
        path: str,
        query_params: Optional[Dict[str, Any]] = None,
        body_params: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
    ) -&gt; AuditLogsResponse:
        url = f&#34;{self.base_url}{path}&#34;
        return await self._perform_http_request(
            http_verb=http_verb,
            url=url,
            query_params=query_params,
            body_params=body_params,
            headers=_build_request_headers(
                token=self.token,
                default_headers=self.default_headers,
                additional_headers=headers,
            ),
        )

    async def _perform_http_request(
        self,
        *,
        http_verb: str,
        url: str,
        query_params: Optional[Dict[str, Any]],
        body_params: Optional[Dict[str, Any]],
        headers: Dict[str, str],
    ) -&gt; AuditLogsResponse:
        if body_params is not None:
            body_params = json.dumps(body_params)
        headers[&#34;Content-Type&#34;] = &#34;application/json;charset=utf-8&#34;

        session: Optional[ClientSession] = None
        use_running_session = self.session and not self.session.closed
        if use_running_session:
            session = self.session
        else:
            session = aiohttp.ClientSession(
                timeout=aiohttp.ClientTimeout(total=self.timeout),
                auth=self.auth,
                trust_env=self.trust_env_in_session,
            )

        last_error = None
        resp: Optional[AuditLogsResponse] = None
        try:
            request_kwargs = {
                &#34;headers&#34;: headers,
                &#34;params&#34;: query_params,
                &#34;data&#34;: body_params,
                &#34;ssl&#34;: self.ssl,
                &#34;proxy&#34;: self.proxy,
            }
            retry_request = RetryHttpRequest(
                method=http_verb,
                url=url,
                headers=headers,
                body_params=body_params,
            )

            retry_state = RetryState()
            counter_for_safety = 0
            while counter_for_safety &lt; 100:
                counter_for_safety += 1
                # If this is a retry, the next try started here. We can reset the flag.
                retry_state.next_attempt_requested = False
                retry_response: Optional[RetryHttpResponse] = None
                response_body = &#34;&#34;

                if self.logger.level &lt;= logging.DEBUG:
                    headers_for_logging = {
                        k: &#34;(redacted)&#34; if k.lower() == &#34;authorization&#34; else v for k, v in headers.items()
                    }
                    self.logger.debug(
                        f&#34;Sending a request - &#34;
                        f&#34;url: {url}, &#34;
                        f&#34;params: {query_params}, &#34;
                        f&#34;body: {body_params}, &#34;
                        f&#34;headers: {headers_for_logging}&#34;
                    )

                try:
                    async with session.request(http_verb, url, **request_kwargs) as res:
                        try:
                            response_body = await res.text()
                            retry_response = RetryHttpResponse(
                                status_code=res.status,
                                headers=res.headers,
                                data=response_body.encode(&#34;utf-8&#34;) if response_body is not None else None,
                            )
                        except aiohttp.ContentTypeError:
                            self.logger.debug(f&#34;No response data returned from the following API call: {url}.&#34;)
                            retry_response = RetryHttpResponse(
                                status_code=res.status,
                                headers=res.headers,
                            )
                        except json.decoder.JSONDecodeError as e:
                            message = f&#34;Failed to parse the response body: {str(e)}&#34;
                            raise SlackApiError(message, res)

                        if res.status == 429:
                            for handler in self.retry_handlers:
                                if await handler.can_retry_async(
                                    state=retry_state,
                                    request=retry_request,
                                    response=retry_response,
                                ):
                                    if self.logger.level &lt;= logging.DEBUG:
                                        self.logger.info(
                                            f&#34;A retry handler found: {type(handler).__name__} &#34;
                                            f&#34;for {http_verb} {url} - rate_limited&#34;
                                        )
                                    await handler.prepare_for_next_attempt_async(
                                        state=retry_state,
                                        request=retry_request,
                                        response=retry_response,
                                    )
                                    break

                        if retry_state.next_attempt_requested is False:
                            resp = AuditLogsResponse(
                                url=url,
                                status_code=res.status,
                                raw_body=response_body,
                                headers=res.headers,
                            )
                            _debug_log_response(self.logger, resp)
                            return resp

                except Exception as e:
                    last_error = e
                    for handler in self.retry_handlers:
                        if await handler.can_retry_async(
                            state=retry_state,
                            request=retry_request,
                            response=retry_response,
                            error=e,
                        ):
                            if self.logger.level &lt;= logging.DEBUG:
                                self.logger.info(
                                    f&#34;A retry handler found: {type(handler).__name__} &#34; f&#34;for {http_verb} {url} - {e}&#34;
                                )
                            await handler.prepare_for_next_attempt_async(
                                state=retry_state,
                                request=retry_request,
                                response=retry_response,
                                error=e,
                            )
                            break

                    if retry_state.next_attempt_requested is False:
                        raise last_error

            if resp is not None:
                return resp
            raise last_error

        finally:
            if not use_running_session:
                await session.close()

        return resp</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.BASE_URL"><code class="name">var <span class="ident">BASE_URL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.auth"><code class="name">var <span class="ident">auth</span> : Optional[aiohttp.helpers.BasicAuth]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.base_url"><code class="name">var <span class="ident">base_url</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.default_headers"><code class="name">var <span class="ident">default_headers</span> : Dict[str, str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.logger"><code class="name">var <span class="ident">logger</span> : logging.Logger</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.proxy"><code class="name">var <span class="ident">proxy</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.retry_handlers"><code class="name">var <span class="ident">retry_handlers</span> : List[slack_sdk.http_retry.async_handler.AsyncRetryHandler]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.session"><code class="name">var <span class="ident">session</span> : Optional[aiohttp.client.ClientSession]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.ssl"><code class="name">var <span class="ident">ssl</span> : Optional[ssl.SSLContext]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.timeout"><code class="name">var <span class="ident">timeout</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.token"><code class="name">var <span class="ident">token</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.trust_env_in_session"><code class="name">var <span class="ident">trust_env_in_session</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.actions"><code class="name flex">
<span>async def <span class="ident">actions</span></span>(<span>self, *, query_params: Optional[Dict[str, Any]] = None, headers: Optional[Dict[str, str]] = None) ‑> <a title="slack_sdk.audit_logs.v1.response.AuditLogsResponse" href="response.html#slack_sdk.audit_logs.v1.response.AuditLogsResponse">AuditLogsResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns information about the kind of actions that the Audit Logs API
returns as a list of all actions and a short description of each.
Authentication not required.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>query_params</code></strong></dt>
<dd>Set any values if you want to add query params</dd>
<dt><strong><code>headers</code></strong></dt>
<dd>Additional request headers</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>API response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def actions(
    self,
    *,
    query_params: Optional[Dict[str, Any]] = None,
    headers: Optional[Dict[str, str]] = None,
) -&gt; AuditLogsResponse:
    &#34;&#34;&#34;Returns information about the kind of actions that the Audit Logs API
    returns as a list of all actions and a short description of each.
    Authentication not required.

    Args:
        query_params: Set any values if you want to add query params
        headers: Additional request headers

    Returns:
        API response
    &#34;&#34;&#34;
    return await self.api_call(
        path=&#34;actions&#34;,
        query_params=query_params,
        headers=headers,
    )</code></pre>
</details>
</dd>
<dt id="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.api_call"><code class="name flex">
<span>async def <span class="ident">api_call</span></span>(<span>self, *, http_verb: str = 'GET', path: str, query_params: Optional[Dict[str, Any]] = None, body_params: Optional[Dict[str, Any]] = None, headers: Optional[Dict[str, str]] = None) ‑> <a title="slack_sdk.audit_logs.v1.response.AuditLogsResponse" href="response.html#slack_sdk.audit_logs.v1.response.AuditLogsResponse">AuditLogsResponse</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def api_call(
    self,
    *,
    http_verb: str = &#34;GET&#34;,
    path: str,
    query_params: Optional[Dict[str, Any]] = None,
    body_params: Optional[Dict[str, Any]] = None,
    headers: Optional[Dict[str, str]] = None,
) -&gt; AuditLogsResponse:
    url = f&#34;{self.base_url}{path}&#34;
    return await self._perform_http_request(
        http_verb=http_verb,
        url=url,
        query_params=query_params,
        body_params=body_params,
        headers=_build_request_headers(
            token=self.token,
            default_headers=self.default_headers,
            additional_headers=headers,
        ),
    )</code></pre>
</details>
</dd>
<dt id="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.logs"><code class="name flex">
<span>async def <span class="ident">logs</span></span>(<span>self, *, latest: Optional[int] = None, oldest: Optional[int] = None, limit: Optional[int] = None, action: Optional[str] = None, actor: Optional[str] = None, entity: Optional[str] = None, cursor: Optional[str] = None, additional_query_params: Optional[Dict[str, Any]] = None, headers: Optional[Dict[str, str]] = None) ‑> <a title="slack_sdk.audit_logs.v1.response.AuditLogsResponse" href="response.html#slack_sdk.audit_logs.v1.response.AuditLogsResponse">AuditLogsResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>This is the primary endpoint for retrieving actual audit events from your organization.
It will return a list of actions that have occurred on the installed workspace or grid organization.
Authentication required.</p>
<p>The following filters can be applied in order to narrow the range of actions returned.
Filters are added as query string parameters and can be combined together.
Multiple filter parameters are additive (a boolean AND) and are separated
with an ampersand (&amp;) in the query string. Filtering is entirely optional.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>latest</code></strong></dt>
<dd>Unix timestamp of the most recent audit event to include (inclusive).</dd>
<dt><strong><code>oldest</code></strong></dt>
<dd>Unix timestamp of the least recent audit event to include (inclusive).
Data is not available prior to March 2018.</dd>
<dt><strong><code>limit</code></strong></dt>
<dd>Number of results to optimistically return, maximum 9999.</dd>
<dt><strong><code>action</code></strong></dt>
<dd>Name of the action.</dd>
<dt><strong><code>actor</code></strong></dt>
<dd>User ID who initiated the action.</dd>
<dt><strong><code>entity</code></strong></dt>
<dd>ID of the target entity of the action (such as a channel, workspace, organization, file).</dd>
<dt><strong><code>cursor</code></strong></dt>
<dd>The next page cursor of pagination</dd>
<dt><strong><code>additional_query_params</code></strong></dt>
<dd>Add anything else if you need to use the ones this library does not support</dd>
<dt><strong><code>headers</code></strong></dt>
<dd>Additional request headers</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>API response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def logs(
    self,
    *,
    latest: Optional[int] = None,
    oldest: Optional[int] = None,
    limit: Optional[int] = None,
    action: Optional[str] = None,
    actor: Optional[str] = None,
    entity: Optional[str] = None,
    cursor: Optional[str] = None,
    additional_query_params: Optional[Dict[str, Any]] = None,
    headers: Optional[Dict[str, str]] = None,
) -&gt; AuditLogsResponse:
    &#34;&#34;&#34;This is the primary endpoint for retrieving actual audit events from your organization.
    It will return a list of actions that have occurred on the installed workspace or grid organization.
    Authentication required.

    The following filters can be applied in order to narrow the range of actions returned.
    Filters are added as query string parameters and can be combined together.
    Multiple filter parameters are additive (a boolean AND) and are separated
    with an ampersand (&amp;) in the query string. Filtering is entirely optional.

    Args:
        latest: Unix timestamp of the most recent audit event to include (inclusive).
        oldest: Unix timestamp of the least recent audit event to include (inclusive).
            Data is not available prior to March 2018.
        limit: Number of results to optimistically return, maximum 9999.
        action: Name of the action.
        actor: User ID who initiated the action.
        entity: ID of the target entity of the action (such as a channel, workspace, organization, file).
        cursor: The next page cursor of pagination
        additional_query_params: Add anything else if you need to use the ones this library does not support
        headers: Additional request headers

    Returns:
        API response
    &#34;&#34;&#34;
    query_params = {
        &#34;latest&#34;: latest,
        &#34;oldest&#34;: oldest,
        &#34;limit&#34;: limit,
        &#34;action&#34;: action,
        &#34;actor&#34;: actor,
        &#34;entity&#34;: entity,
        &#34;cursor&#34;: cursor,
    }
    if additional_query_params is not None:
        query_params.update(additional_query_params)
    query_params = {k: v for k, v in query_params.items() if v is not None}
    return await self.api_call(
        path=&#34;logs&#34;,
        query_params=query_params,
        headers=headers,
    )</code></pre>
</details>
</dd>
<dt id="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.schemas"><code class="name flex">
<span>async def <span class="ident">schemas</span></span>(<span>self, *, query_params: Optional[Dict[str, Any]] = None, headers: Optional[Dict[str, str]] = None) ‑> <a title="slack_sdk.audit_logs.v1.response.AuditLogsResponse" href="response.html#slack_sdk.audit_logs.v1.response.AuditLogsResponse">AuditLogsResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns information about the kind of objects which the Audit Logs API
returns as a list of all objects and a short description.
Authentication not required.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>query_params</code></strong></dt>
<dd>Set any values if you want to add query params</dd>
<dt><strong><code>headers</code></strong></dt>
<dd>Additional request headers</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>API response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def schemas(
    self,
    *,
    query_params: Optional[Dict[str, Any]] = None,
    headers: Optional[Dict[str, str]] = None,
) -&gt; AuditLogsResponse:
    &#34;&#34;&#34;Returns information about the kind of objects which the Audit Logs API
    returns as a list of all objects and a short description.
    Authentication not required.

    Args:
        query_params: Set any values if you want to add query params
        headers: Additional request headers
    Returns:
        API response
    &#34;&#34;&#34;
    return await self.api_call(
        path=&#34;schemas&#34;,
        query_params=query_params,
        headers=headers,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="slack_sdk.audit_logs.v1" href="index.html">slack_sdk.audit_logs.v1</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient" href="#slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient">AsyncAuditLogsClient</a></code></h4>
<ul class="">
<li><code><a title="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.BASE_URL" href="#slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.BASE_URL">BASE_URL</a></code></li>
<li><code><a title="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.actions" href="#slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.actions">actions</a></code></li>
<li><code><a title="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.api_call" href="#slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.api_call">api_call</a></code></li>
<li><code><a title="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.auth" href="#slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.auth">auth</a></code></li>
<li><code><a title="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.base_url" href="#slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.base_url">base_url</a></code></li>
<li><code><a title="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.default_headers" href="#slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.default_headers">default_headers</a></code></li>
<li><code><a title="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.logger" href="#slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.logger">logger</a></code></li>
<li><code><a title="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.logs" href="#slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.logs">logs</a></code></li>
<li><code><a title="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.proxy" href="#slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.proxy">proxy</a></code></li>
<li><code><a title="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.retry_handlers" href="#slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.retry_handlers">retry_handlers</a></code></li>
<li><code><a title="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.schemas" href="#slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.schemas">schemas</a></code></li>
<li><code><a title="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.session" href="#slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.session">session</a></code></li>
<li><code><a title="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.ssl" href="#slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.ssl">ssl</a></code></li>
<li><code><a title="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.timeout" href="#slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.timeout">timeout</a></code></li>
<li><code><a title="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.token" href="#slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.token">token</a></code></li>
<li><code><a title="slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.trust_env_in_session" href="#slack_sdk.audit_logs.v1.async_client.AsyncAuditLogsClient.trust_env_in_session">trust_env_in_session</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>