<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>slack_sdk.web.legacy_client API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>slack_sdk.web.legacy_client</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#
#  *** DO NOT EDIT THIS FILE ***
#
#  1) Modify slack_sdk/web/client.py
#  2) Run `python setup.py codegen`
#
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

from asyncio import Future

&#34;&#34;&#34;A Python module for interacting with Slack&#39;s Web API.&#34;&#34;&#34;
import json
import os
import warnings
from io import IOBase
from typing import Union, Sequence, Optional, Dict, Tuple, Any, List

import slack_sdk.errors as e
from slack_sdk.models.views import View
from .legacy_base_client import LegacyBaseClient, SlackResponse
from .internal_utils import (
    _parse_web_class_objects,
    _update_call_participants,
    _warn_if_text_or_attachment_fallback_is_missing,
    _remove_none_values,
    _to_v2_file_upload_item,
    _upload_file_via_v2_url,
    _validate_for_legacy_client,
    _print_files_upload_v2_suggestion,
)
from ..models.attachments import Attachment
from ..models.blocks import Block
from ..models.metadata import Metadata


class LegacyWebClient(LegacyBaseClient):
    &#34;&#34;&#34;A WebClient allows apps to communicate with the Slack Platform&#39;s Web API.

    https://api.slack.com/methods

    The Slack Web API is an interface for querying information from
    and enacting change in a Slack workspace.

    This client handles constructing and sending HTTP requests to Slack
    as well as parsing any responses received into a `SlackResponse`.

    Attributes:
        token (str): A string specifying an `xoxp-*` or `xoxb-*` token.
        base_url (str): A string representing the Slack API base URL.
            Default is `&#39;https://www.slack.com/api/&#39;`
        timeout (int): The maximum number of seconds the client will wait
            to connect and receive a response from Slack.
            Default is 30 seconds.
        ssl (SSLContext): An [`ssl.SSLContext`][1] instance, helpful for specifying
            your own custom certificate chain.
        proxy (str): String representing a fully-qualified URL to a proxy through
            which to route all requests to the Slack API. Even if this parameter
            is not specified, if any of the following environment variables are
            present, they will be loaded into this parameter: `HTTPS_PROXY`,
            `https_proxy`, `HTTP_PROXY` or `http_proxy`.
        headers (dict): Additional request headers to attach to all requests.

    Methods:
        `api_call`: Constructs a request and executes the API call to Slack.

    Example of recommended usage:
    ```python
        import os
        from slack_sdk.web.legacy_client import LegacyWebClient

        client = LegacyWebClient(token=os.environ[&#39;SLACK_API_TOKEN&#39;])
        response = client.chat_postMessage(
            channel=&#39;#random&#39;,
            text=&#34;Hello world!&#34;)
        assert response[&#34;ok&#34;]
        assert response[&#34;message&#34;][&#34;text&#34;] == &#34;Hello world!&#34;
    ```

    Example manually creating an API request:
    ```python
        import os
        from slack_sdk.web.legacy_client import LegacyWebClient

        client = LegacyWebClient(token=os.environ[&#39;SLACK_API_TOKEN&#39;])
        response = client.api_call(
            api_method=&#39;chat.postMessage&#39;,
            json={&#39;channel&#39;: &#39;#random&#39;,&#39;text&#39;: &#34;Hello world!&#34;}
        )
        assert response[&#34;ok&#34;]
        assert response[&#34;message&#34;][&#34;text&#34;] == &#34;Hello world!&#34;
    ```

    Note:
        Any attributes or methods prefixed with _underscores are
        intended to be &#34;private&#34; internal use only. They may be changed or
        removed at anytime.

    [1]: https://docs.python.org/3/library/ssl.html#ssl.SSLContext
    &#34;&#34;&#34;

    def admin_analytics_getFile(
        self,
        *,
        type: str,
        date: Optional[str] = None,
        metadata_only: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieve analytics data for a given date, presented as a compressed JSON file
        https://api.slack.com/methods/admin.analytics.getFile
        &#34;&#34;&#34;
        kwargs.update({&#34;type&#34;: type})
        if date is not None:
            kwargs.update({&#34;date&#34;: date})
        if metadata_only is not None:
            kwargs.update({&#34;metadata_only&#34;: metadata_only})
        return self.api_call(&#34;admin.analytics.getFile&#34;, params=kwargs)

    def admin_apps_approve(
        self,
        *,
        app_id: Optional[str] = None,
        request_id: Optional[str] = None,
        enterprise_id: Optional[str] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Approve an app for installation on a workspace.
        Either app_id or request_id is required.
        These IDs can be obtained either directly via the app_requested event,
        or by the admin.apps.requests.list method.
        https://api.slack.com/methods/admin.apps.approve
        &#34;&#34;&#34;
        if app_id:
            kwargs.update({&#34;app_id&#34;: app_id})
        elif request_id:
            kwargs.update({&#34;request_id&#34;: request_id})
        else:
            raise e.SlackRequestError(&#34;The app_id or request_id argument must be specified.&#34;)

        kwargs.update(
            {
                &#34;enterprise_id&#34;: enterprise_id,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;admin.apps.approve&#34;, params=kwargs)

    def admin_apps_approved_list(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        enterprise_id: Optional[str] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List approved apps for an org or workspace.
        https://api.slack.com/methods/admin.apps.approved.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
                &#34;enterprise_id&#34;: enterprise_id,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;admin.apps.approved.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def admin_apps_clearResolution(
        self,
        *,
        app_id: str,
        enterprise_id: Optional[str] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Clear an app resolution
        https://api.slack.com/methods/admin.apps.clearResolution
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;app_id&#34;: app_id,
                &#34;enterprise_id&#34;: enterprise_id,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;admin.apps.clearResolution&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def admin_apps_requests_cancel(
        self,
        *,
        request_id: str,
        enterprise_id: Optional[str] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List app requests for a team/workspace.
        https://api.slack.com/methods/admin.apps.requests.cancel
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;request_id&#34;: request_id,
                &#34;enterprise_id&#34;: enterprise_id,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;admin.apps.requests.cancel&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def admin_apps_requests_list(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List app requests for a team/workspace.
        https://api.slack.com/methods/admin.apps.requests.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;admin.apps.requests.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def admin_apps_restrict(
        self,
        *,
        app_id: Optional[str] = None,
        request_id: Optional[str] = None,
        enterprise_id: Optional[str] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Restrict an app for installation on a workspace.
        Exactly one of the team_id or enterprise_id arguments is required, not both.
        Either app_id or request_id is required. These IDs can be obtained either directly
        via the app_requested event, or by the admin.apps.requests.list method.
        https://api.slack.com/methods/admin.apps.restrict
        &#34;&#34;&#34;
        if app_id:
            kwargs.update({&#34;app_id&#34;: app_id})
        elif request_id:
            kwargs.update({&#34;request_id&#34;: request_id})
        else:
            raise e.SlackRequestError(&#34;The app_id or request_id argument must be specified.&#34;)

        kwargs.update(
            {
                &#34;enterprise_id&#34;: enterprise_id,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;admin.apps.restrict&#34;, params=kwargs)

    def admin_apps_restricted_list(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        enterprise_id: Optional[str] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List restricted apps for an org or workspace.
        https://api.slack.com/methods/admin.apps.restricted.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
                &#34;enterprise_id&#34;: enterprise_id,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;admin.apps.restricted.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def admin_apps_uninstall(
        self,
        *,
        app_id: str,
        enterprise_id: Optional[str] = None,
        team_ids: Optional[Union[str, Sequence[str]]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Uninstall an app from one or many workspaces, or an entire enterprise organization.
        With an org-level token, enterprise_id or team_ids is required.
        https://api.slack.com/methods/admin.apps.uninstall
        &#34;&#34;&#34;
        kwargs.update({&#34;app_id&#34;: app_id})
        if enterprise_id is not None:
            kwargs.update({&#34;enterprise_id&#34;: enterprise_id})
        if team_ids is not None:
            if isinstance(team_ids, (list, Tuple)):
                kwargs.update({&#34;team_ids&#34;: &#34;,&#34;.join(team_ids)})
            else:
                kwargs.update({&#34;team_ids&#34;: team_ids})
        return self.api_call(&#34;admin.apps.uninstall&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def admin_apps_activities_list(
        self,
        *,
        app_id: Optional[str] = None,
        component_id: Optional[str] = None,
        component_type: Optional[str] = None,
        log_event_type: Optional[str] = None,
        max_date_created: Optional[int] = None,
        min_date_created: Optional[int] = None,
        min_log_level: Optional[str] = None,
        sort_direction: Optional[str] = None,
        source: Optional[str] = None,
        team_id: Optional[str] = None,
        trace_id: Optional[str] = None,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Get logs for a specified team/org
        https://api.slack.com/methods/admin.apps.activities.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;app_id&#34;: app_id,
                &#34;component_id&#34;: component_id,
                &#34;component_type&#34;: component_type,
                &#34;log_event_type&#34;: log_event_type,
                &#34;max_date_created&#34;: max_date_created,
                &#34;min_date_created&#34;: min_date_created,
                &#34;min_log_level&#34;: min_log_level,
                &#34;sort_direction&#34;: sort_direction,
                &#34;source&#34;: source,
                &#34;team_id&#34;: team_id,
                &#34;trace_id&#34;: trace_id,
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
            }
        )
        return self.api_call(&#34;admin.apps.activities.list&#34;, params=kwargs)

    def admin_apps_config_lookup(
        self,
        *,
        app_ids: Union[str, Sequence[str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Look up the app config for connectors by their IDs
        https://api.slack.com/methods/admin.apps.config.lookup
        &#34;&#34;&#34;
        if isinstance(app_ids, (list, Tuple)):
            kwargs.update({&#34;app_ids&#34;: &#34;,&#34;.join(app_ids)})
        else:
            kwargs.update({&#34;app_ids&#34;: app_ids})
        return self.api_call(&#34;admin.apps.config.lookup&#34;, params=kwargs)

    def admin_apps_config_set(
        self,
        *,
        app_id: str,
        domain_restrictions: Optional[Dict[str, Any]] = None,
        workflow_auth_strategy: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Set the app config for a connector
        https://api.slack.com/methods/admin.apps.config.set
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;app_id&#34;: app_id,
                &#34;workflow_auth_strategy&#34;: workflow_auth_strategy,
            }
        )
        if domain_restrictions is not None:
            kwargs.update({&#34;domain_restrictions&#34;: json.dumps(domain_restrictions)})
        return self.api_call(&#34;admin.apps.config.set&#34;, params=kwargs)

    def admin_auth_policy_getEntities(
        self,
        *,
        policy_name: str,
        cursor: Optional[str] = None,
        entity_type: Optional[str] = None,
        limit: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Fetch all the entities assigned to a particular authentication policy by name.
        https://api.slack.com/methods/admin.auth.policy.getEntities
        &#34;&#34;&#34;
        kwargs.update({&#34;policy_name&#34;: policy_name})
        if cursor is not None:
            kwargs.update({&#34;cursor&#34;: cursor})
        if entity_type is not None:
            kwargs.update({&#34;entity_type&#34;: entity_type})
        if limit is not None:
            kwargs.update({&#34;limit&#34;: limit})
        return self.api_call(&#34;admin.auth.policy.getEntities&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def admin_auth_policy_assignEntities(
        self,
        *,
        entity_ids: Union[str, Sequence[str]],
        policy_name: str,
        entity_type: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Assign entities to a particular authentication policy.
        https://api.slack.com/methods/admin.auth.policy.assignEntities
        &#34;&#34;&#34;
        if isinstance(entity_ids, (list, Tuple)):
            kwargs.update({&#34;entity_ids&#34;: &#34;,&#34;.join(entity_ids)})
        else:
            kwargs.update({&#34;entity_ids&#34;: entity_ids})
        kwargs.update({&#34;policy_name&#34;: policy_name})
        kwargs.update({&#34;entity_type&#34;: entity_type})
        return self.api_call(&#34;admin.auth.policy.assignEntities&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def admin_auth_policy_removeEntities(
        self,
        *,
        entity_ids: Union[str, Sequence[str]],
        policy_name: str,
        entity_type: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Remove specified entities from a specified authentication policy.
        https://api.slack.com/methods/admin.auth.policy.removeEntities
        &#34;&#34;&#34;
        if isinstance(entity_ids, (list, Tuple)):
            kwargs.update({&#34;entity_ids&#34;: &#34;,&#34;.join(entity_ids)})
        else:
            kwargs.update({&#34;entity_ids&#34;: entity_ids})
        kwargs.update({&#34;policy_name&#34;: policy_name})
        kwargs.update({&#34;entity_type&#34;: entity_type})
        return self.api_call(&#34;admin.auth.policy.removeEntities&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def admin_barriers_create(
        self,
        *,
        barriered_from_usergroup_ids: Union[str, Sequence[str]],
        primary_usergroup_id: str,
        restricted_subjects: Union[str, Sequence[str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Create an Information Barrier
        https://api.slack.com/methods/admin.barriers.create
        &#34;&#34;&#34;
        kwargs.update({&#34;primary_usergroup_id&#34;: primary_usergroup_id})
        if isinstance(barriered_from_usergroup_ids, (list, Tuple)):
            kwargs.update({&#34;barriered_from_usergroup_ids&#34;: &#34;,&#34;.join(barriered_from_usergroup_ids)})
        else:
            kwargs.update({&#34;barriered_from_usergroup_ids&#34;: barriered_from_usergroup_ids})
        if isinstance(restricted_subjects, (list, Tuple)):
            kwargs.update({&#34;restricted_subjects&#34;: &#34;,&#34;.join(restricted_subjects)})
        else:
            kwargs.update({&#34;restricted_subjects&#34;: restricted_subjects})
        return self.api_call(&#34;admin.barriers.create&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def admin_barriers_delete(
        self,
        *,
        barrier_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Delete an existing Information Barrier
        https://api.slack.com/methods/admin.barriers.delete
        &#34;&#34;&#34;
        kwargs.update({&#34;barrier_id&#34;: barrier_id})
        return self.api_call(&#34;admin.barriers.delete&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def admin_barriers_update(
        self,
        *,
        barrier_id: str,
        barriered_from_usergroup_ids: Union[str, Sequence[str]],
        primary_usergroup_id: str,
        restricted_subjects: Union[str, Sequence[str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Update an existing Information Barrier
        https://api.slack.com/methods/admin.barriers.update
        &#34;&#34;&#34;
        kwargs.update({&#34;barrier_id&#34;: barrier_id, &#34;primary_usergroup_id&#34;: primary_usergroup_id})
        if isinstance(barriered_from_usergroup_ids, (list, Tuple)):
            kwargs.update({&#34;barriered_from_usergroup_ids&#34;: &#34;,&#34;.join(barriered_from_usergroup_ids)})
        else:
            kwargs.update({&#34;barriered_from_usergroup_ids&#34;: barriered_from_usergroup_ids})
        if isinstance(restricted_subjects, (list, Tuple)):
            kwargs.update({&#34;restricted_subjects&#34;: &#34;,&#34;.join(restricted_subjects)})
        else:
            kwargs.update({&#34;restricted_subjects&#34;: restricted_subjects})
        return self.api_call(&#34;admin.barriers.update&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def admin_barriers_list(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Get all Information Barriers for your organization
        https://api.slack.com/methods/admin.barriers.list&#34;&#34;&#34;
        kwargs.update(
            {
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
            }
        )
        return self.api_call(&#34;admin.barriers.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def admin_conversations_create(
        self,
        *,
        is_private: bool,
        name: str,
        description: Optional[str] = None,
        org_wide: Optional[bool] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Create a public or private channel-based conversation.
        https://api.slack.com/methods/admin.conversations.create
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;is_private&#34;: is_private,
                &#34;name&#34;: name,
                &#34;description&#34;: description,
                &#34;org_wide&#34;: org_wide,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;admin.conversations.create&#34;, params=kwargs)

    def admin_conversations_delete(
        self,
        *,
        channel_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Delete a public or private channel.
        https://api.slack.com/methods/admin.conversations.delete
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_id&#34;: channel_id})
        return self.api_call(&#34;admin.conversations.delete&#34;, params=kwargs)

    def admin_conversations_invite(
        self,
        *,
        channel_id: str,
        user_ids: Union[str, Sequence[str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Invite a user to a public or private channel.
        https://api.slack.com/methods/admin.conversations.invite
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_id&#34;: channel_id})
        if isinstance(user_ids, (list, Tuple)):
            kwargs.update({&#34;user_ids&#34;: &#34;,&#34;.join(user_ids)})
        else:
            kwargs.update({&#34;user_ids&#34;: user_ids})
        # NOTE: the endpoint is unable to handle Content-Type: application/json as of Sep 3, 2020.
        return self.api_call(&#34;admin.conversations.invite&#34;, params=kwargs)

    def admin_conversations_archive(
        self,
        *,
        channel_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Archive a public or private channel.
        https://api.slack.com/methods/admin.conversations.archive
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_id&#34;: channel_id})
        return self.api_call(&#34;admin.conversations.archive&#34;, params=kwargs)

    def admin_conversations_unarchive(
        self,
        *,
        channel_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Unarchive a public or private channel.
        https://api.slack.com/methods/admin.conversations.archive
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_id&#34;: channel_id})
        return self.api_call(&#34;admin.conversations.unarchive&#34;, params=kwargs)

    def admin_conversations_rename(
        self,
        *,
        channel_id: str,
        name: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Rename a public or private channel.
        https://api.slack.com/methods/admin.conversations.rename
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_id&#34;: channel_id, &#34;name&#34;: name})
        return self.api_call(&#34;admin.conversations.rename&#34;, params=kwargs)

    def admin_conversations_search(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        query: Optional[str] = None,
        search_channel_types: Optional[Union[str, Sequence[str]]] = None,
        sort: Optional[str] = None,
        sort_dir: Optional[str] = None,
        team_ids: Optional[Union[str, Sequence[str]]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Search for public or private channels in an Enterprise organization.
        https://api.slack.com/methods/admin.conversations.search
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
                &#34;query&#34;: query,
                &#34;sort&#34;: sort,
                &#34;sort_dir&#34;: sort_dir,
            }
        )

        if isinstance(search_channel_types, (list, Tuple)):
            kwargs.update({&#34;search_channel_types&#34;: &#34;,&#34;.join(search_channel_types)})
        else:
            kwargs.update({&#34;search_channel_types&#34;: search_channel_types})

        if isinstance(team_ids, (list, Tuple)):
            kwargs.update({&#34;team_ids&#34;: &#34;,&#34;.join(team_ids)})
        else:
            kwargs.update({&#34;team_ids&#34;: team_ids})

        return self.api_call(&#34;admin.conversations.search&#34;, params=kwargs)

    def admin_conversations_convertToPrivate(
        self,
        *,
        channel_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Convert a public channel to a private channel.
        https://api.slack.com/methods/admin.conversations.convertToPrivate
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_id&#34;: channel_id})
        return self.api_call(&#34;admin.conversations.convertToPrivate&#34;, params=kwargs)

    def admin_conversations_convertToPublic(
        self,
        *,
        channel_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Convert a privte channel to a public channel.
        https://api.slack.com/methods/admin.conversations.convertToPublic
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_id&#34;: channel_id})
        return self.api_call(&#34;admin.conversations.convertToPublic&#34;, params=kwargs)

    def admin_conversations_setConversationPrefs(
        self,
        *,
        channel_id: str,
        prefs: Union[str, Dict[str, str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Set the posting permissions for a public or private channel.
        https://api.slack.com/methods/admin.conversations.setConversationPrefs
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_id&#34;: channel_id})
        if isinstance(prefs, dict):
            kwargs.update({&#34;prefs&#34;: json.dumps(prefs)})
        else:
            kwargs.update({&#34;prefs&#34;: prefs})
        return self.api_call(&#34;admin.conversations.setConversationPrefs&#34;, params=kwargs)

    def admin_conversations_getConversationPrefs(
        self,
        *,
        channel_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Get conversation preferences for a public or private channel.
        https://api.slack.com/methods/admin.conversations.getConversationPrefs
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_id&#34;: channel_id})
        return self.api_call(&#34;admin.conversations.getConversationPrefs&#34;, params=kwargs)

    def admin_conversations_disconnectShared(
        self,
        *,
        channel_id: str,
        leaving_team_ids: Optional[Union[str, Sequence[str]]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Disconnect a connected channel from one or more workspaces.
        https://api.slack.com/methods/admin.conversations.disconnectShared
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_id&#34;: channel_id})
        if isinstance(leaving_team_ids, (list, Tuple)):
            kwargs.update({&#34;leaving_team_ids&#34;: &#34;,&#34;.join(leaving_team_ids)})
        else:
            kwargs.update({&#34;leaving_team_ids&#34;: leaving_team_ids})
        return self.api_call(&#34;admin.conversations.disconnectShared&#34;, params=kwargs)

    def admin_conversations_lookup(
        self,
        *,
        last_message_activity_before: int,
        team_ids: Union[str, Sequence[str]],
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        max_member_count: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Returns channels on the given team using the filters.
        https://api.slack.com/methods/admin.conversations.lookup
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;last_message_activity_before&#34;: last_message_activity_before,
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
                &#34;max_member_count&#34;: max_member_count,
            }
        )
        if isinstance(team_ids, (list, Tuple)):
            kwargs.update({&#34;team_ids&#34;: &#34;,&#34;.join(team_ids)})
        else:
            kwargs.update({&#34;team_ids&#34;: team_ids})
        return self.api_call(&#34;admin.conversations.lookup&#34;, params=kwargs)

    def admin_conversations_ekm_listOriginalConnectedChannelInfo(
        self,
        *,
        channel_ids: Optional[Union[str, Sequence[str]]] = None,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        team_ids: Optional[Union[str, Sequence[str]]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List all disconnected channels—i.e.,
        channels that were once connected to other workspaces and then disconnected—and
        the corresponding original channel IDs for key revocation with EKM.
        https://api.slack.com/methods/admin.conversations.ekm.listOriginalConnectedChannelInfo
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
            }
        )
        if isinstance(channel_ids, (list, Tuple)):
            kwargs.update({&#34;channel_ids&#34;: &#34;,&#34;.join(channel_ids)})
        else:
            kwargs.update({&#34;channel_ids&#34;: channel_ids})
        if isinstance(team_ids, (list, Tuple)):
            kwargs.update({&#34;team_ids&#34;: &#34;,&#34;.join(team_ids)})
        else:
            kwargs.update({&#34;team_ids&#34;: team_ids})
        return self.api_call(&#34;admin.conversations.ekm.listOriginalConnectedChannelInfo&#34;, params=kwargs)

    def admin_conversations_restrictAccess_addGroup(
        self,
        *,
        channel_id: str,
        group_id: str,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Add an allowlist of IDP groups for accessing a channel.
        https://api.slack.com/methods/admin.conversations.restrictAccess.addGroup
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel_id&#34;: channel_id,
                &#34;group_id&#34;: group_id,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(
            &#34;admin.conversations.restrictAccess.addGroup&#34;,
            http_verb=&#34;GET&#34;,
            params=kwargs,
        )

    def admin_conversations_restrictAccess_listGroups(
        self,
        *,
        channel_id: str,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List all IDP Groups linked to a channel.
        https://api.slack.com/methods/admin.conversations.restrictAccess.listGroups
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel_id&#34;: channel_id,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(
            &#34;admin.conversations.restrictAccess.listGroups&#34;,
            http_verb=&#34;GET&#34;,
            params=kwargs,
        )

    def admin_conversations_restrictAccess_removeGroup(
        self,
        *,
        channel_id: str,
        group_id: str,
        team_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Remove a linked IDP group linked from a private channel.
        https://api.slack.com/methods/admin.conversations.restrictAccess.removeGroup
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel_id&#34;: channel_id,
                &#34;group_id&#34;: group_id,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(
            &#34;admin.conversations.restrictAccess.removeGroup&#34;,
            http_verb=&#34;GET&#34;,
            params=kwargs,
        )

    def admin_conversations_setTeams(
        self,
        *,
        channel_id: str,
        org_channel: Optional[bool] = None,
        target_team_ids: Optional[Union[str, Sequence[str]]] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Set the workspaces in an Enterprise grid org that connect to a public or private channel.
        https://api.slack.com/methods/admin.conversations.setTeams
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel_id&#34;: channel_id,
                &#34;org_channel&#34;: org_channel,
                &#34;team_id&#34;: team_id,
            }
        )
        if isinstance(target_team_ids, (list, Tuple)):
            kwargs.update({&#34;target_team_ids&#34;: &#34;,&#34;.join(target_team_ids)})
        else:
            kwargs.update({&#34;target_team_ids&#34;: target_team_ids})
        return self.api_call(&#34;admin.conversations.setTeams&#34;, params=kwargs)

    def admin_conversations_getTeams(
        self,
        *,
        channel_id: str,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Set the workspaces in an Enterprise grid org that connect to a channel.
        https://api.slack.com/methods/admin.conversations.getTeams
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel_id&#34;: channel_id,
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
            }
        )
        return self.api_call(&#34;admin.conversations.getTeams&#34;, params=kwargs)

    def admin_conversations_getCustomRetention(
        self,
        *,
        channel_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Get a channel&#39;s retention policy
        https://api.slack.com/methods/admin.conversations.getCustomRetention
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_id&#34;: channel_id})
        return self.api_call(&#34;admin.conversations.getCustomRetention&#34;, params=kwargs)

    def admin_conversations_removeCustomRetention(
        self,
        *,
        channel_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Remove a channel&#39;s retention policy
        https://api.slack.com/methods/admin.conversations.removeCustomRetention
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_id&#34;: channel_id})
        return self.api_call(&#34;admin.conversations.removeCustomRetention&#34;, params=kwargs)

    def admin_conversations_setCustomRetention(
        self,
        *,
        channel_id: str,
        duration_days: int,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Set a channel&#39;s retention policy
        https://api.slack.com/methods/admin.conversations.setCustomRetention
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_id&#34;: channel_id, &#34;duration_days&#34;: duration_days})
        return self.api_call(&#34;admin.conversations.setCustomRetention&#34;, params=kwargs)

    def admin_conversations_bulkArchive(
        self,
        *,
        channel_ids: Union[Sequence[str], str],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Archive public or private channels in bulk.
        https://api.slack.com/methods/admin.conversations.bulkArchive
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_ids&#34;: &#34;,&#34;.join(channel_ids) if isinstance(channel_ids, (list, tuple)) else channel_ids})
        return self.api_call(&#34;admin.conversations.bulkArchive&#34;, params=kwargs)

    def admin_conversations_bulkDelete(
        self,
        *,
        channel_ids: Union[Sequence[str], str],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Delete public or private channels in bulk.
        https://slack.com/api/admin.conversations.bulkDelete
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_ids&#34;: &#34;,&#34;.join(channel_ids) if isinstance(channel_ids, (list, tuple)) else channel_ids})
        return self.api_call(&#34;admin.conversations.bulkDelete&#34;, params=kwargs)

    def admin_conversations_bulkMove(
        self,
        *,
        channel_ids: Union[Sequence[str], str],
        target_team_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Move public or private channels in bulk.
        https://api.slack.com/methods/admin.conversations.bulkMove
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;target_team_id&#34;: target_team_id,
                &#34;channel_ids&#34;: &#34;,&#34;.join(channel_ids) if isinstance(channel_ids, (list, tuple)) else channel_ids,
            }
        )
        return self.api_call(&#34;admin.conversations.bulkMove&#34;, params=kwargs)

    def admin_emoji_add(
        self,
        *,
        name: str,
        url: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Add an emoji.
        https://api.slack.com/methods/admin.emoji.add
        &#34;&#34;&#34;
        kwargs.update({&#34;name&#34;: name, &#34;url&#34;: url})
        return self.api_call(&#34;admin.emoji.add&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def admin_emoji_addAlias(
        self,
        *,
        alias_for: str,
        name: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Add an emoji alias.
        https://api.slack.com/methods/admin.emoji.addAlias
        &#34;&#34;&#34;
        kwargs.update({&#34;alias_for&#34;: alias_for, &#34;name&#34;: name})
        return self.api_call(&#34;admin.emoji.addAlias&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def admin_emoji_list(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List emoji for an Enterprise Grid organization.
        https://api.slack.com/methods/admin.emoji.list
        &#34;&#34;&#34;
        kwargs.update({&#34;cursor&#34;: cursor, &#34;limit&#34;: limit})
        return self.api_call(&#34;admin.emoji.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def admin_emoji_remove(
        self,
        *,
        name: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Remove an emoji across an Enterprise Grid organization.
        https://api.slack.com/methods/admin.emoji.remove
        &#34;&#34;&#34;
        kwargs.update({&#34;name&#34;: name})
        return self.api_call(&#34;admin.emoji.remove&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def admin_emoji_rename(
        self,
        *,
        name: str,
        new_name: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Rename an emoji.
        https://api.slack.com/methods/admin.emoji.rename
        &#34;&#34;&#34;
        kwargs.update({&#34;name&#34;: name, &#34;new_name&#34;: new_name})
        return self.api_call(&#34;admin.emoji.rename&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def admin_functions_list(
        self,
        *,
        app_ids: Union[str, Sequence[str]],
        team_id: Optional[str] = None,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Look up functions by a set of apps
        https://api.slack.com/methods/admin.functions.list
        &#34;&#34;&#34;
        if isinstance(app_ids, (list, Tuple)):
            kwargs.update({&#34;app_ids&#34;: &#34;,&#34;.join(app_ids)})
        else:
            kwargs.update({&#34;app_ids&#34;: app_ids})
        kwargs.update(
            {
                &#34;team_id&#34;: team_id,
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
            }
        )
        return self.api_call(&#34;admin.functions.list&#34;, params=kwargs)

    def admin_functions_permissions_lookup(
        self,
        *,
        function_ids: Union[str, Sequence[str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lookup the visibility of multiple Slack functions
        and include the users if it is limited to particular named entities.
        https://api.slack.com/methods/admin.functions.permissions.lookup
        &#34;&#34;&#34;
        if isinstance(function_ids, (list, Tuple)):
            kwargs.update({&#34;function_ids&#34;: &#34;,&#34;.join(function_ids)})
        else:
            kwargs.update({&#34;function_ids&#34;: function_ids})
        return self.api_call(&#34;admin.functions.permissions.lookup&#34;, params=kwargs)

    def admin_functions_permissions_set(
        self,
        *,
        function_id: str,
        visibility: str,
        user_ids: Optional[Union[str, Sequence[str]]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Set the visibility of a Slack function
        and define the users or workspaces if it is set to named_entities
        https://api.slack.com/methods/admin.functions.permissions.set
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;function_id&#34;: function_id,
                &#34;visibility&#34;: visibility,
            }
        )
        if user_ids is not None:
            if isinstance(user_ids, (list, Tuple)):
                kwargs.update({&#34;user_ids&#34;: &#34;,&#34;.join(user_ids)})
            else:
                kwargs.update({&#34;user_ids&#34;: user_ids})
        return self.api_call(&#34;admin.functions.permissions.set&#34;, params=kwargs)

    def admin_roles_addAssignments(
        self,
        *,
        role_id: str,
        entity_ids: Union[str, Sequence[str]],
        user_ids: Union[str, Sequence[str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Adds members to the specified role with the specified scopes
        https://api.slack.com/methods/admin.roles.addAssignments
        &#34;&#34;&#34;
        kwargs.update({&#34;role_id&#34;: role_id})
        if isinstance(entity_ids, (list, Tuple)):
            kwargs.update({&#34;entity_ids&#34;: &#34;,&#34;.join(entity_ids)})
        else:
            kwargs.update({&#34;entity_ids&#34;: entity_ids})
        if isinstance(user_ids, (list, Tuple)):
            kwargs.update({&#34;user_ids&#34;: &#34;,&#34;.join(user_ids)})
        else:
            kwargs.update({&#34;user_ids&#34;: user_ids})
        return self.api_call(&#34;admin.roles.addAssignments&#34;, params=kwargs)

    def admin_roles_listAssignments(
        self,
        *,
        role_ids: Optional[Union[str, Sequence[str]]] = None,
        entity_ids: Optional[Union[str, Sequence[str]]] = None,
        cursor: Optional[str] = None,
        limit: Optional[Union[str, int]] = None,
        sort_dir: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lists assignments for all roles across entities.
            Options to scope results by any combination of roles or entities
        https://api.slack.com/methods/admin.roles.listAssignments
        &#34;&#34;&#34;
        kwargs.update({&#34;cursor&#34;: cursor, &#34;limit&#34;: limit, &#34;sort_dir&#34;: sort_dir})
        if isinstance(entity_ids, (list, Tuple)):
            kwargs.update({&#34;entity_ids&#34;: &#34;,&#34;.join(entity_ids)})
        else:
            kwargs.update({&#34;entity_ids&#34;: entity_ids})
        if isinstance(role_ids, (list, Tuple)):
            kwargs.update({&#34;role_ids&#34;: &#34;,&#34;.join(role_ids)})
        else:
            kwargs.update({&#34;role_ids&#34;: role_ids})
        return self.api_call(&#34;admin.roles.listAssignments&#34;, params=kwargs)

    def admin_roles_removeAssignments(
        self,
        *,
        role_id: str,
        entity_ids: Union[str, Sequence[str]],
        user_ids: Union[str, Sequence[str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Removes a set of users from a role for the given scopes and entities
        https://api.slack.com/methods/admin.roles.removeAssignments
        &#34;&#34;&#34;
        kwargs.update({&#34;role_id&#34;: role_id})
        if isinstance(entity_ids, (list, Tuple)):
            kwargs.update({&#34;entity_ids&#34;: &#34;,&#34;.join(entity_ids)})
        else:
            kwargs.update({&#34;entity_ids&#34;: entity_ids})
        if isinstance(user_ids, (list, Tuple)):
            kwargs.update({&#34;user_ids&#34;: &#34;,&#34;.join(user_ids)})
        else:
            kwargs.update({&#34;user_ids&#34;: user_ids})
        return self.api_call(&#34;admin.roles.removeAssignments&#34;, params=kwargs)

    def admin_users_session_reset(
        self,
        *,
        user_id: str,
        mobile_only: Optional[bool] = None,
        web_only: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Wipes all valid sessions on all devices for a given user.
        https://api.slack.com/methods/admin.users.session.reset
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;user_id&#34;: user_id,
                &#34;mobile_only&#34;: mobile_only,
                &#34;web_only&#34;: web_only,
            }
        )
        return self.api_call(&#34;admin.users.session.reset&#34;, params=kwargs)

    def admin_users_session_resetBulk(
        self,
        *,
        user_ids: Union[str, Sequence[str]],
        mobile_only: Optional[bool] = None,
        web_only: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Enqueues an asynchronous job to wipe all valid sessions on all devices for a given list of users
        https://api.slack.com/methods/admin.users.session.resetBulk
        &#34;&#34;&#34;
        if isinstance(user_ids, (list, Tuple)):
            kwargs.update({&#34;user_ids&#34;: &#34;,&#34;.join(user_ids)})
        else:
            kwargs.update({&#34;user_ids&#34;: user_ids})
        kwargs.update(
            {
                &#34;mobile_only&#34;: mobile_only,
                &#34;web_only&#34;: web_only,
            }
        )
        return self.api_call(&#34;admin.users.session.resetBulk&#34;, params=kwargs)

    def admin_users_session_invalidate(
        self,
        *,
        session_id: str,
        team_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Invalidate a single session for a user by session_id.
        https://api.slack.com/methods/admin.users.session.invalidate
        &#34;&#34;&#34;
        kwargs.update({&#34;session_id&#34;: session_id, &#34;team_id&#34;: team_id})
        return self.api_call(&#34;admin.users.session.invalidate&#34;, params=kwargs)

    def admin_users_session_list(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        team_id: Optional[str] = None,
        user_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lists all active user sessions for an organization
        https://api.slack.com/methods/admin.users.session.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
                &#34;team_id&#34;: team_id,
                &#34;user_id&#34;: user_id,
            }
        )
        return self.api_call(&#34;admin.users.session.list&#34;, params=kwargs)

    def admin_teams_settings_setDefaultChannels(
        self,
        *,
        team_id: str,
        channel_ids: Union[str, Sequence[str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Set the default channels of a workspace.
        https://api.slack.com/methods/admin.teams.settings.setDefaultChannels
        &#34;&#34;&#34;
        kwargs.update({&#34;team_id&#34;: team_id})
        if isinstance(channel_ids, (list, Tuple)):
            kwargs.update({&#34;channel_ids&#34;: &#34;,&#34;.join(channel_ids)})
        else:
            kwargs.update({&#34;channel_ids&#34;: channel_ids})
        return self.api_call(&#34;admin.teams.settings.setDefaultChannels&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def admin_users_session_getSettings(
        self,
        *,
        user_ids: Union[str, Sequence[str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Get user-specific session settings—the session duration
        and what happens when the client closes—given a list of users.
        https://api.slack.com/methods/admin.users.session.getSettings
        &#34;&#34;&#34;
        if isinstance(user_ids, (list, Tuple)):
            kwargs.update({&#34;user_ids&#34;: &#34;,&#34;.join(user_ids)})
        else:
            kwargs.update({&#34;user_ids&#34;: user_ids})
        return self.api_call(&#34;admin.users.session.getSettings&#34;, params=kwargs)

    def admin_users_session_setSettings(
        self,
        *,
        user_ids: Union[str, Sequence[str]],
        desktop_app_browser_quit: Optional[bool] = None,
        duration: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Configure the user-level session settings—the session duration
        and what happens when the client closes—for one or more users.
        https://api.slack.com/methods/admin.users.session.setSettings
        &#34;&#34;&#34;
        if isinstance(user_ids, (list, Tuple)):
            kwargs.update({&#34;user_ids&#34;: &#34;,&#34;.join(user_ids)})
        else:
            kwargs.update({&#34;user_ids&#34;: user_ids})
        kwargs.update(
            {
                &#34;desktop_app_browser_quit&#34;: desktop_app_browser_quit,
                &#34;duration&#34;: duration,
            }
        )
        return self.api_call(&#34;admin.users.session.setSettings&#34;, params=kwargs)

    def admin_users_session_clearSettings(
        self,
        *,
        user_ids: Union[str, Sequence[str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Clear user-specific session settings—the session duration
        and what happens when the client closes—for a list of users.
        https://api.slack.com/methods/admin.users.session.clearSettings
        &#34;&#34;&#34;
        if isinstance(user_ids, (list, Tuple)):
            kwargs.update({&#34;user_ids&#34;: &#34;,&#34;.join(user_ids)})
        else:
            kwargs.update({&#34;user_ids&#34;: user_ids})
        return self.api_call(&#34;admin.users.session.clearSettings&#34;, params=kwargs)

    def admin_users_unsupportedVersions_export(
        self,
        *,
        date_end_of_support: Optional[Union[str, int]] = None,
        date_sessions_started: Optional[Union[str, int]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Ask Slackbot to send you an export listing all workspace members using unsupported software,
        presented as a zipped CSV file.
        https://api.slack.com/methods/admin.users.unsupportedVersions.export
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;date_end_of_support&#34;: date_end_of_support,
                &#34;date_sessions_started&#34;: date_sessions_started,
            }
        )
        return self.api_call(&#34;admin.users.unsupportedVersions.export&#34;, params=kwargs)

    def admin_inviteRequests_approve(
        self,
        *,
        invite_request_id: str,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Approve a workspace invite request.
        https://api.slack.com/methods/admin.inviteRequests.approve
        &#34;&#34;&#34;
        kwargs.update({&#34;invite_request_id&#34;: invite_request_id, &#34;team_id&#34;: team_id})
        return self.api_call(&#34;admin.inviteRequests.approve&#34;, params=kwargs)

    def admin_inviteRequests_approved_list(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List all approved workspace invite requests.
        https://api.slack.com/methods/admin.inviteRequests.approved.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;admin.inviteRequests.approved.list&#34;, params=kwargs)

    def admin_inviteRequests_denied_list(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List all denied workspace invite requests.
        https://api.slack.com/methods/admin.inviteRequests.denied.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;admin.inviteRequests.denied.list&#34;, params=kwargs)

    def admin_inviteRequests_deny(
        self,
        *,
        invite_request_id: str,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Deny a workspace invite request.
        https://api.slack.com/methods/admin.inviteRequests.deny
        &#34;&#34;&#34;
        kwargs.update({&#34;invite_request_id&#34;: invite_request_id, &#34;team_id&#34;: team_id})
        return self.api_call(&#34;admin.inviteRequests.deny&#34;, params=kwargs)

    def admin_inviteRequests_list(
        self,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List all pending workspace invite requests.&#34;&#34;&#34;
        return self.api_call(&#34;admin.inviteRequests.list&#34;, params=kwargs)

    def admin_teams_admins_list(
        self,
        *,
        team_id: str,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List all of the admins on a given workspace.
        https://api.slack.com/methods/admin.inviteRequests.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;admin.teams.admins.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def admin_teams_create(
        self,
        *,
        team_domain: str,
        team_name: str,
        team_description: Optional[str] = None,
        team_discoverability: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Create an Enterprise team.
        https://api.slack.com/methods/admin.teams.create
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;team_domain&#34;: team_domain,
                &#34;team_name&#34;: team_name,
                &#34;team_description&#34;: team_description,
                &#34;team_discoverability&#34;: team_discoverability,
            }
        )
        return self.api_call(&#34;admin.teams.create&#34;, params=kwargs)

    def admin_teams_list(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List all teams on an Enterprise organization.
        https://api.slack.com/methods/admin.teams.list
        &#34;&#34;&#34;
        kwargs.update({&#34;cursor&#34;: cursor, &#34;limit&#34;: limit})
        return self.api_call(&#34;admin.teams.list&#34;, params=kwargs)

    def admin_teams_owners_list(
        self,
        *,
        team_id: str,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List all of the admins on a given workspace.
        https://api.slack.com/methods/admin.teams.owners.list
        &#34;&#34;&#34;
        kwargs.update({&#34;team_id&#34;: team_id, &#34;cursor&#34;: cursor, &#34;limit&#34;: limit})
        return self.api_call(&#34;admin.teams.owners.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def admin_teams_settings_info(
        self,
        *,
        team_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Fetch information about settings in a workspace
        https://api.slack.com/methods/admin.teams.settings.info
        &#34;&#34;&#34;
        kwargs.update({&#34;team_id&#34;: team_id})
        return self.api_call(&#34;admin.teams.settings.info&#34;, params=kwargs)

    def admin_teams_settings_setDescription(
        self,
        *,
        team_id: str,
        description: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Set the description of a given workspace.
        https://api.slack.com/methods/admin.teams.settings.setDescription
        &#34;&#34;&#34;
        kwargs.update({&#34;team_id&#34;: team_id, &#34;description&#34;: description})
        return self.api_call(&#34;admin.teams.settings.setDescription&#34;, params=kwargs)

    def admin_teams_settings_setDiscoverability(
        self,
        *,
        team_id: str,
        discoverability: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sets the icon of a workspace.
        https://api.slack.com/methods/admin.teams.settings.setDiscoverability
        &#34;&#34;&#34;
        kwargs.update({&#34;team_id&#34;: team_id, &#34;discoverability&#34;: discoverability})
        return self.api_call(&#34;admin.teams.settings.setDiscoverability&#34;, params=kwargs)

    def admin_teams_settings_setIcon(
        self,
        *,
        team_id: str,
        image_url: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sets the icon of a workspace.
        https://api.slack.com/methods/admin.teams.settings.setIcon
        &#34;&#34;&#34;
        kwargs.update({&#34;team_id&#34;: team_id, &#34;image_url&#34;: image_url})
        return self.api_call(&#34;admin.teams.settings.setIcon&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def admin_teams_settings_setName(
        self,
        *,
        team_id: str,
        name: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sets the icon of a workspace.
        https://api.slack.com/methods/admin.teams.settings.setName
        &#34;&#34;&#34;
        kwargs.update({&#34;team_id&#34;: team_id, &#34;name&#34;: name})
        return self.api_call(&#34;admin.teams.settings.setName&#34;, params=kwargs)

    def admin_usergroups_addChannels(
        self,
        *,
        channel_ids: Union[str, Sequence[str]],
        usergroup_id: str,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Add one or more default channels to an IDP group.
        https://api.slack.com/methods/admin.usergroups.addChannels
        &#34;&#34;&#34;
        kwargs.update({&#34;team_id&#34;: team_id, &#34;usergroup_id&#34;: usergroup_id})
        if isinstance(channel_ids, (list, Tuple)):
            kwargs.update({&#34;channel_ids&#34;: &#34;,&#34;.join(channel_ids)})
        else:
            kwargs.update({&#34;channel_ids&#34;: channel_ids})
        return self.api_call(&#34;admin.usergroups.addChannels&#34;, params=kwargs)

    def admin_usergroups_addTeams(
        self,
        *,
        usergroup_id: str,
        team_ids: Union[str, Sequence[str]],
        auto_provision: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Associate one or more default workspaces with an organization-wide IDP group.
        https://api.slack.com/methods/admin.usergroups.addTeams
        &#34;&#34;&#34;
        kwargs.update({&#34;usergroup_id&#34;: usergroup_id, &#34;auto_provision&#34;: auto_provision})
        if isinstance(team_ids, (list, Tuple)):
            kwargs.update({&#34;team_ids&#34;: &#34;,&#34;.join(team_ids)})
        else:
            kwargs.update({&#34;team_ids&#34;: team_ids})
        return self.api_call(&#34;admin.usergroups.addTeams&#34;, params=kwargs)

    def admin_usergroups_listChannels(
        self,
        *,
        usergroup_id: str,
        include_num_members: Optional[bool] = None,
        team_id: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Add one or more default channels to an IDP group.
        https://api.slack.com/methods/admin.usergroups.listChannels
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;usergroup_id&#34;: usergroup_id,
                &#34;include_num_members&#34;: include_num_members,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;admin.usergroups.listChannels&#34;, params=kwargs)

    def admin_usergroups_removeChannels(
        self,
        *,
        usergroup_id: str,
        channel_ids: Union[str, Sequence[str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Add one or more default channels to an IDP group.
        https://api.slack.com/methods/admin.usergroups.removeChannels
        &#34;&#34;&#34;
        kwargs.update({&#34;usergroup_id&#34;: usergroup_id})
        if isinstance(channel_ids, (list, Tuple)):
            kwargs.update({&#34;channel_ids&#34;: &#34;,&#34;.join(channel_ids)})
        else:
            kwargs.update({&#34;channel_ids&#34;: channel_ids})
        return self.api_call(&#34;admin.usergroups.removeChannels&#34;, params=kwargs)

    def admin_users_assign(
        self,
        *,
        team_id: str,
        user_id: str,
        channel_ids: Optional[Union[str, Sequence[str]]] = None,
        is_restricted: Optional[bool] = None,
        is_ultra_restricted: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Add an Enterprise user to a workspace.
        https://api.slack.com/methods/admin.users.assign
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;team_id&#34;: team_id,
                &#34;user_id&#34;: user_id,
                &#34;is_restricted&#34;: is_restricted,
                &#34;is_ultra_restricted&#34;: is_ultra_restricted,
            }
        )
        if isinstance(channel_ids, (list, Tuple)):
            kwargs.update({&#34;channel_ids&#34;: &#34;,&#34;.join(channel_ids)})
        else:
            kwargs.update({&#34;channel_ids&#34;: channel_ids})
        return self.api_call(&#34;admin.users.assign&#34;, params=kwargs)

    def admin_users_invite(
        self,
        *,
        team_id: str,
        email: str,
        channel_ids: Union[str, Sequence[str]],
        custom_message: Optional[str] = None,
        email_password_policy_enabled: Optional[bool] = None,
        guest_expiration_ts: Optional[Union[str, float]] = None,
        is_restricted: Optional[bool] = None,
        is_ultra_restricted: Optional[bool] = None,
        real_name: Optional[str] = None,
        resend: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Invite a user to a workspace.
        https://api.slack.com/methods/admin.users.invite
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;team_id&#34;: team_id,
                &#34;email&#34;: email,
                &#34;custom_message&#34;: custom_message,
                &#34;email_password_policy_enabled&#34;: email_password_policy_enabled,
                &#34;guest_expiration_ts&#34;: str(guest_expiration_ts) if guest_expiration_ts is not None else None,
                &#34;is_restricted&#34;: is_restricted,
                &#34;is_ultra_restricted&#34;: is_ultra_restricted,
                &#34;real_name&#34;: real_name,
                &#34;resend&#34;: resend,
            }
        )
        if isinstance(channel_ids, (list, Tuple)):
            kwargs.update({&#34;channel_ids&#34;: &#34;,&#34;.join(channel_ids)})
        else:
            kwargs.update({&#34;channel_ids&#34;: channel_ids})
        return self.api_call(&#34;admin.users.invite&#34;, params=kwargs)

    def admin_users_list(
        self,
        *,
        team_id: str,
        include_deactivated_user_workspaces: Optional[bool] = None,
        is_active: Optional[bool] = None,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List users on a workspace
        https://api.slack.com/methods/admin.users.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;team_id&#34;: team_id,
                &#34;include_deactivated_user_workspaces&#34;: include_deactivated_user_workspaces,
                &#34;is_active&#34;: is_active,
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
            }
        )
        return self.api_call(&#34;admin.users.list&#34;, params=kwargs)

    def admin_users_remove(
        self,
        *,
        team_id: str,
        user_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Remove a user from a workspace.
        https://api.slack.com/methods/admin.users.remove
        &#34;&#34;&#34;
        kwargs.update({&#34;team_id&#34;: team_id, &#34;user_id&#34;: user_id})
        return self.api_call(&#34;admin.users.remove&#34;, params=kwargs)

    def admin_users_setAdmin(
        self,
        *,
        team_id: str,
        user_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Set an existing guest, regular user, or owner to be an admin user.
        https://api.slack.com/methods/admin.users.setAdmin
        &#34;&#34;&#34;
        kwargs.update({&#34;team_id&#34;: team_id, &#34;user_id&#34;: user_id})
        return self.api_call(&#34;admin.users.setAdmin&#34;, params=kwargs)

    def admin_users_setExpiration(
        self,
        *,
        expiration_ts: int,
        user_id: str,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Set an expiration for a guest user.
        https://api.slack.com/methods/admin.users.setExpiration
        &#34;&#34;&#34;
        kwargs.update({&#34;expiration_ts&#34;: expiration_ts, &#34;team_id&#34;: team_id, &#34;user_id&#34;: user_id})
        return self.api_call(&#34;admin.users.setExpiration&#34;, params=kwargs)

    def admin_users_setOwner(
        self,
        *,
        team_id: str,
        user_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Set an existing guest, regular user, or admin user to be a workspace owner.
        https://api.slack.com/methods/admin.users.setOwner
        &#34;&#34;&#34;
        kwargs.update({&#34;team_id&#34;: team_id, &#34;user_id&#34;: user_id})
        return self.api_call(&#34;admin.users.setOwner&#34;, params=kwargs)

    def admin_users_setRegular(
        self,
        *,
        team_id: str,
        user_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Set an existing guest user, admin user, or owner to be a regular user.
        https://api.slack.com/methods/admin.users.setRegular
        &#34;&#34;&#34;
        kwargs.update({&#34;team_id&#34;: team_id, &#34;user_id&#34;: user_id})
        return self.api_call(&#34;admin.users.setRegular&#34;, params=kwargs)

    def admin_workflows_search(
        self,
        *,
        app_id: Optional[str] = None,
        collaborator_ids: Optional[Union[str, Sequence[str]]] = None,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        no_collaborators: Optional[bool] = None,
        num_trigger_ids: Optional[int] = None,
        query: Optional[str] = None,
        sort: Optional[str] = None,
        sort_dir: Optional[str] = None,
        source: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Search workflows within the team or enterprise
        https://api.slack.com/methods/admin.workflows.search
        &#34;&#34;&#34;
        if collaborator_ids is not None:
            if isinstance(collaborator_ids, (list, Tuple)):
                kwargs.update({&#34;collaborator_ids&#34;: &#34;,&#34;.join(collaborator_ids)})
            else:
                kwargs.update({&#34;collaborator_ids&#34;: collaborator_ids})
        kwargs.update(
            {
                &#34;app_id&#34;: app_id,
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
                &#34;no_collaborators&#34;: no_collaborators,
                &#34;num_trigger_ids&#34;: num_trigger_ids,
                &#34;query&#34;: query,
                &#34;sort&#34;: sort,
                &#34;sort_dir&#34;: sort_dir,
                &#34;source&#34;: source,
            }
        )
        return self.api_call(&#34;admin.workflows.search&#34;, params=kwargs)

    def admin_workflows_permissions_lookup(
        self,
        *,
        workflow_ids: Union[str, Sequence[str]],
        max_workflow_triggers: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Look up the permissions for a set of workflows
        https://api.slack.com/methods/admin.workflows.permissions.lookup
        &#34;&#34;&#34;
        if isinstance(workflow_ids, (list, Tuple)):
            kwargs.update({&#34;workflow_ids&#34;: &#34;,&#34;.join(workflow_ids)})
        else:
            kwargs.update({&#34;workflow_ids&#34;: workflow_ids})
        kwargs.update(
            {
                &#34;max_workflow_triggers&#34;: max_workflow_triggers,
            }
        )
        return self.api_call(&#34;admin.workflows.permissions.lookup&#34;, params=kwargs)

    def admin_workflows_collaborators_add(
        self,
        *,
        collaborator_ids: Union[str, Sequence[str]],
        workflow_ids: Union[str, Sequence[str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Add collaborators to workflows within the team or enterprise
        https://api.slack.com/methods/admin.workflows.collaborators.add
        &#34;&#34;&#34;
        if isinstance(collaborator_ids, (list, Tuple)):
            kwargs.update({&#34;collaborator_ids&#34;: &#34;,&#34;.join(collaborator_ids)})
        else:
            kwargs.update({&#34;collaborator_ids&#34;: collaborator_ids})
        if isinstance(workflow_ids, (list, Tuple)):
            kwargs.update({&#34;workflow_ids&#34;: &#34;,&#34;.join(workflow_ids)})
        else:
            kwargs.update({&#34;workflow_ids&#34;: workflow_ids})
        return self.api_call(&#34;admin.workflows.collaborators.add&#34;, params=kwargs)

    def admin_workflows_collaborators_remove(
        self,
        *,
        collaborator_ids: Union[str, Sequence[str]],
        workflow_ids: Union[str, Sequence[str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Remove collaborators from workflows within the team or enterprise
        https://api.slack.com/methods/admin.workflows.collaborators.remove
        &#34;&#34;&#34;
        if isinstance(collaborator_ids, (list, Tuple)):
            kwargs.update({&#34;collaborator_ids&#34;: &#34;,&#34;.join(collaborator_ids)})
        else:
            kwargs.update({&#34;collaborator_ids&#34;: collaborator_ids})
        if isinstance(workflow_ids, (list, Tuple)):
            kwargs.update({&#34;workflow_ids&#34;: &#34;,&#34;.join(workflow_ids)})
        else:
            kwargs.update({&#34;workflow_ids&#34;: workflow_ids})
        return self.api_call(&#34;admin.workflows.collaborators.remove&#34;, params=kwargs)

    def admin_workflows_unpublish(
        self,
        *,
        workflow_ids: Union[str, Sequence[str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Unpublish workflows within the team or enterprise
        https://api.slack.com/methods/admin.workflows.unpublish
        &#34;&#34;&#34;
        if isinstance(workflow_ids, (list, Tuple)):
            kwargs.update({&#34;workflow_ids&#34;: &#34;,&#34;.join(workflow_ids)})
        else:
            kwargs.update({&#34;workflow_ids&#34;: workflow_ids})
        return self.api_call(&#34;admin.workflows.unpublish&#34;, params=kwargs)

    def api_test(
        self,
        *,
        error: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Checks API calling code.
        https://api.slack.com/methods/api.test
        &#34;&#34;&#34;
        kwargs.update({&#34;error&#34;: error})
        return self.api_call(&#34;api.test&#34;, params=kwargs)

    def apps_connections_open(
        self,
        *,
        app_token: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Generate a temporary Socket Mode WebSocket URL that your app can connect to
        in order to receive events and interactive payloads
        https://api.slack.com/methods/apps.connections.open
        &#34;&#34;&#34;
        kwargs.update({&#34;token&#34;: app_token})
        return self.api_call(&#34;apps.connections.open&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def apps_event_authorizations_list(
        self,
        *,
        event_context: str,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Get a list of authorizations for the given event context.
        Each authorization represents an app installation that the event is visible to.
        https://api.slack.com/methods/apps.event.authorizations.list
        &#34;&#34;&#34;
        kwargs.update({&#34;event_context&#34;: event_context, &#34;cursor&#34;: cursor, &#34;limit&#34;: limit})
        return self.api_call(&#34;apps.event.authorizations.list&#34;, params=kwargs)

    def apps_uninstall(
        self,
        *,
        client_id: str,
        client_secret: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Uninstalls your app from a workspace.
        https://api.slack.com/methods/apps.uninstall
        &#34;&#34;&#34;
        kwargs.update({&#34;client_id&#34;: client_id, &#34;client_secret&#34;: client_secret})
        return self.api_call(&#34;apps.uninstall&#34;, params=kwargs)

    def apps_manifest_create(
        self,
        *,
        manifest: Union[str, Dict[str, Any]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Create an app from an app manifest
        https://api.slack.com/methods/apps.manifest.create
        &#34;&#34;&#34;
        if isinstance(manifest, str):
            kwargs.update({&#34;manifest&#34;: manifest})
        else:
            kwargs.update({&#34;manifest&#34;: json.dumps(manifest)})
        return self.api_call(&#34;apps.manifest.create&#34;, params=kwargs)

    def apps_manifest_delete(
        self,
        *,
        app_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Permanently deletes an app created through app manifests
        https://api.slack.com/methods/apps.manifest.delete
        &#34;&#34;&#34;
        kwargs.update({&#34;app_id&#34;: app_id})
        return self.api_call(&#34;apps.manifest.delete&#34;, params=kwargs)

    def apps_manifest_export(
        self,
        *,
        app_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Export an app manifest from an existing app
        https://api.slack.com/methods/apps.manifest.export
        &#34;&#34;&#34;
        kwargs.update({&#34;app_id&#34;: app_id})
        return self.api_call(&#34;apps.manifest.export&#34;, params=kwargs)

    def apps_manifest_update(
        self,
        *,
        app_id: str,
        manifest: Union[str, Dict[str, Any]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Update an app from an app manifest
        https://api.slack.com/methods/apps.manifest.update
        &#34;&#34;&#34;
        if isinstance(manifest, str):
            kwargs.update({&#34;manifest&#34;: manifest})
        else:
            kwargs.update({&#34;manifest&#34;: json.dumps(manifest)})
        kwargs.update({&#34;app_id&#34;: app_id})
        return self.api_call(&#34;apps.manifest.update&#34;, params=kwargs)

    def apps_manifest_validate(
        self,
        *,
        manifest: Union[str, Dict[str, Any]],
        app_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Validate an app manifest
        https://api.slack.com/methods/apps.manifest.validate
        &#34;&#34;&#34;
        if isinstance(manifest, str):
            kwargs.update({&#34;manifest&#34;: manifest})
        else:
            kwargs.update({&#34;manifest&#34;: json.dumps(manifest)})
        kwargs.update({&#34;app_id&#34;: app_id})
        return self.api_call(&#34;apps.manifest.validate&#34;, params=kwargs)

    def tooling_tokens_rotate(
        self,
        *,
        refresh_token: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Exchanges a refresh token for a new app configuration token
        https://api.slack.com/methods/tooling.tokens.rotate
        &#34;&#34;&#34;
        kwargs.update({&#34;refresh_token&#34;: refresh_token})
        return self.api_call(&#34;tooling.tokens.rotate&#34;, params=kwargs)

    def auth_revoke(
        self,
        *,
        test: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Revokes a token.
        https://api.slack.com/methods/auth.revoke
        &#34;&#34;&#34;
        kwargs.update({&#34;test&#34;: test})
        return self.api_call(&#34;auth.revoke&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def auth_test(
        self,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Checks authentication &amp; identity.
        https://api.slack.com/methods/auth.test
        &#34;&#34;&#34;
        return self.api_call(&#34;auth.test&#34;, params=kwargs)

    def auth_teams_list(
        self,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        include_icon: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List the workspaces a token can access.
        https://api.slack.com/methods/auth.teams.list
        &#34;&#34;&#34;
        kwargs.update({&#34;cursor&#34;: cursor, &#34;limit&#34;: limit, &#34;include_icon&#34;: include_icon})
        return self.api_call(&#34;auth.teams.list&#34;, params=kwargs)

    def bookmarks_add(
        self,
        *,
        channel_id: str,
        title: str,
        type: str,
        emoji: Optional[str] = None,
        entity_id: Optional[str] = None,
        link: Optional[str] = None,  # include when type is &#39;link&#39;
        parent_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Add bookmark to a channel.
        https://api.slack.com/methods/bookmarks.add
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel_id&#34;: channel_id,
                &#34;title&#34;: title,
                &#34;type&#34;: type,
                &#34;emoji&#34;: emoji,
                &#34;entity_id&#34;: entity_id,
                &#34;link&#34;: link,
                &#34;parent_id&#34;: parent_id,
            }
        )
        return self.api_call(&#34;bookmarks.add&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def bookmarks_edit(
        self,
        *,
        bookmark_id: str,
        channel_id: str,
        emoji: Optional[str] = None,
        link: Optional[str] = None,
        title: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Edit bookmark.
        https://api.slack.com/methods/bookmarks.edit
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;bookmark_id&#34;: bookmark_id,
                &#34;channel_id&#34;: channel_id,
                &#34;emoji&#34;: emoji,
                &#34;link&#34;: link,
                &#34;title&#34;: title,
            }
        )
        return self.api_call(&#34;bookmarks.edit&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def bookmarks_list(
        self,
        *,
        channel_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List bookmark for the channel.
        https://api.slack.com/methods/bookmarks.list
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_id&#34;: channel_id})
        return self.api_call(&#34;bookmarks.list&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def bookmarks_remove(
        self,
        *,
        bookmark_id: str,
        channel_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Remove bookmark from the channel.
        https://api.slack.com/methods/bookmarks.remove
        &#34;&#34;&#34;
        kwargs.update({&#34;bookmark_id&#34;: bookmark_id, &#34;channel_id&#34;: channel_id})
        return self.api_call(&#34;bookmarks.remove&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def bots_info(
        self,
        *,
        bot: Optional[str] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Gets information about a bot user.
        https://api.slack.com/methods/bots.info
        &#34;&#34;&#34;
        kwargs.update({&#34;bot&#34;: bot, &#34;team_id&#34;: team_id})
        return self.api_call(&#34;bots.info&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def calls_add(
        self,
        *,
        external_unique_id: str,
        join_url: str,
        created_by: Optional[str] = None,
        date_start: Optional[int] = None,
        desktop_app_join_url: Optional[str] = None,
        external_display_id: Optional[str] = None,
        title: Optional[str] = None,
        users: Optional[Union[str, Sequence[Dict[str, str]]]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Registers a new Call.
        https://api.slack.com/methods/calls.add
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;external_unique_id&#34;: external_unique_id,
                &#34;join_url&#34;: join_url,
                &#34;created_by&#34;: created_by,
                &#34;date_start&#34;: date_start,
                &#34;desktop_app_join_url&#34;: desktop_app_join_url,
                &#34;external_display_id&#34;: external_display_id,
                &#34;title&#34;: title,
            }
        )
        _update_call_participants(  # skipcq: PTC-W0039
            kwargs,
            users if users is not None else kwargs.get(&#34;users&#34;),  # skipcq: PTC-W0039
        )  # skipcq: PTC-W0039
        return self.api_call(&#34;calls.add&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def calls_end(
        self,
        *,
        id: str,
        duration: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:  # skipcq: PYL-W0622
        &#34;&#34;&#34;Ends a Call.
        https://api.slack.com/methods/calls.end
        &#34;&#34;&#34;
        kwargs.update({&#34;id&#34;: id, &#34;duration&#34;: duration})
        return self.api_call(&#34;calls.end&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def calls_info(
        self,
        *,
        id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:  # skipcq: PYL-W0622
        &#34;&#34;&#34;Returns information about a Call.
        https://api.slack.com/methods/calls.info
        &#34;&#34;&#34;
        kwargs.update({&#34;id&#34;: id})
        return self.api_call(&#34;calls.info&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def calls_participants_add(
        self,
        *,
        id: str,  # skipcq: PYL-W0622
        users: Union[str, Sequence[Dict[str, str]]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Registers new participants added to a Call.
        https://api.slack.com/methods/calls.participants.add
        &#34;&#34;&#34;
        kwargs.update({&#34;id&#34;: id})
        _update_call_participants(kwargs, users)
        return self.api_call(&#34;calls.participants.add&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def calls_participants_remove(
        self,
        *,
        id: str,  # skipcq: PYL-W0622
        users: Union[str, Sequence[Dict[str, str]]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Registers participants removed from a Call.
        https://api.slack.com/methods/calls.participants.remove
        &#34;&#34;&#34;
        kwargs.update({&#34;id&#34;: id})
        _update_call_participants(kwargs, users)
        return self.api_call(&#34;calls.participants.remove&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def calls_update(
        self,
        *,
        id: str,
        desktop_app_join_url: Optional[str] = None,
        join_url: Optional[str] = None,
        title: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:  # skipcq: PYL-W0622
        &#34;&#34;&#34;Updates information about a Call.
        https://api.slack.com/methods/calls.update
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;id&#34;: id,
                &#34;desktop_app_join_url&#34;: desktop_app_join_url,
                &#34;join_url&#34;: join_url,
                &#34;title&#34;: title,
            }
        )
        return self.api_call(&#34;calls.update&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    # --------------------------
    # Deprecated: channels.*
    # You can use conversations.* APIs instead.
    # https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api
    # --------------------------

    def channels_archive(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Archives a channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;channels.archive&#34;, json=kwargs)

    def channels_create(
        self,
        *,
        name: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Creates a channel.&#34;&#34;&#34;
        kwargs.update({&#34;name&#34;: name})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;channels.create&#34;, json=kwargs)

    def channels_history(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Fetches history of messages and events from a channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        return self.api_call(&#34;channels.history&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def channels_info(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Gets information about a channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        return self.api_call(&#34;channels.info&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def channels_invite(
        self,
        *,
        channel: str,
        user: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Invites a user to a channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;user&#34;: user})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;channels.invite&#34;, json=kwargs)

    def channels_join(
        self,
        *,
        name: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Joins a channel, creating it if needed.&#34;&#34;&#34;
        kwargs.update({&#34;name&#34;: name})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;channels.join&#34;, json=kwargs)

    def channels_kick(
        self,
        *,
        channel: str,
        user: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Removes a user from a channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;user&#34;: user})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;channels.kick&#34;, json=kwargs)

    def channels_leave(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Leaves a channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;channels.leave&#34;, json=kwargs)

    def channels_list(
        self,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lists all channels in a Slack team.&#34;&#34;&#34;
        return self.api_call(&#34;channels.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def channels_mark(
        self,
        *,
        channel: str,
        ts: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sets the read cursor in a channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;ts&#34;: ts})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;channels.mark&#34;, json=kwargs)

    def channels_rename(
        self,
        *,
        channel: str,
        name: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Renames a channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;name&#34;: name})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;channels.rename&#34;, json=kwargs)

    def channels_replies(
        self,
        *,
        channel: str,
        thread_ts: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieve a thread of messages posted to a channel&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;thread_ts&#34;: thread_ts})
        return self.api_call(&#34;channels.replies&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def channels_setPurpose(
        self,
        *,
        channel: str,
        purpose: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sets the purpose for a channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;purpose&#34;: purpose})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;channels.setPurpose&#34;, json=kwargs)

    def channels_setTopic(
        self,
        *,
        channel: str,
        topic: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sets the topic for a channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;topic&#34;: topic})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;channels.setTopic&#34;, json=kwargs)

    def channels_unarchive(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Unarchives a channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;channels.unarchive&#34;, json=kwargs)

    # --------------------------

    def chat_delete(
        self,
        *,
        channel: str,
        ts: str,
        as_user: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Deletes a message.
        https://api.slack.com/methods/chat.delete
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;ts&#34;: ts, &#34;as_user&#34;: as_user})
        return self.api_call(&#34;chat.delete&#34;, params=kwargs)

    def chat_deleteScheduledMessage(
        self,
        *,
        channel: str,
        scheduled_message_id: str,
        as_user: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Deletes a scheduled message.
        https://api.slack.com/methods/chat.deleteScheduledMessage
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;scheduled_message_id&#34;: scheduled_message_id,
                &#34;as_user&#34;: as_user,
            }
        )
        return self.api_call(&#34;chat.deleteScheduledMessage&#34;, params=kwargs)

    def chat_getPermalink(
        self,
        *,
        channel: str,
        message_ts: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieve a permalink URL for a specific extant message
        https://api.slack.com/methods/chat.getPermalink
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;message_ts&#34;: message_ts})
        return self.api_call(&#34;chat.getPermalink&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def chat_meMessage(
        self,
        *,
        channel: str,
        text: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Share a me message into a channel.
        https://api.slack.com/methods/chat.meMessage
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;text&#34;: text})
        return self.api_call(&#34;chat.meMessage&#34;, params=kwargs)

    def chat_postEphemeral(
        self,
        *,
        channel: str,
        user: str,
        text: Optional[str] = None,
        as_user: Optional[bool] = None,
        attachments: Optional[Union[str, Sequence[Union[Dict, Attachment]]]] = None,
        blocks: Optional[Union[str, Sequence[Union[Dict, Block]]]] = None,
        thread_ts: Optional[str] = None,
        icon_emoji: Optional[str] = None,
        icon_url: Optional[str] = None,
        link_names: Optional[bool] = None,
        username: Optional[str] = None,
        parse: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sends an ephemeral message to a user in a channel.
        https://api.slack.com/methods/chat.postEphemeral
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;user&#34;: user,
                &#34;text&#34;: text,
                &#34;as_user&#34;: as_user,
                &#34;attachments&#34;: attachments,
                &#34;blocks&#34;: blocks,
                &#34;thread_ts&#34;: thread_ts,
                &#34;icon_emoji&#34;: icon_emoji,
                &#34;icon_url&#34;: icon_url,
                &#34;link_names&#34;: link_names,
                &#34;username&#34;: username,
                &#34;parse&#34;: parse,
            }
        )
        _parse_web_class_objects(kwargs)
        kwargs = _remove_none_values(kwargs)
        _warn_if_text_or_attachment_fallback_is_missing(&#34;chat.postEphemeral&#34;, kwargs)
        # NOTE: intentionally using json over params for the API methods using blocks/attachments
        return self.api_call(&#34;chat.postEphemeral&#34;, json=kwargs)

    def chat_postMessage(
        self,
        *,
        channel: str,
        text: Optional[str] = None,
        as_user: Optional[bool] = None,
        attachments: Optional[Union[str, Sequence[Union[Dict, Attachment]]]] = None,
        blocks: Optional[Union[str, Sequence[Union[Dict, Block]]]] = None,
        thread_ts: Optional[str] = None,
        reply_broadcast: Optional[bool] = None,
        unfurl_links: Optional[bool] = None,
        unfurl_media: Optional[bool] = None,
        container_id: Optional[str] = None,
        icon_emoji: Optional[str] = None,
        icon_url: Optional[str] = None,
        mrkdwn: Optional[bool] = None,
        link_names: Optional[bool] = None,
        username: Optional[str] = None,
        parse: Optional[str] = None,  # none, full
        metadata: Optional[Union[Dict, Metadata]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sends a message to a channel.
        https://api.slack.com/methods/chat.postMessage
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;text&#34;: text,
                &#34;as_user&#34;: as_user,
                &#34;attachments&#34;: attachments,
                &#34;blocks&#34;: blocks,
                &#34;thread_ts&#34;: thread_ts,
                &#34;reply_broadcast&#34;: reply_broadcast,
                &#34;unfurl_links&#34;: unfurl_links,
                &#34;unfurl_media&#34;: unfurl_media,
                &#34;container_id&#34;: container_id,
                &#34;icon_emoji&#34;: icon_emoji,
                &#34;icon_url&#34;: icon_url,
                &#34;mrkdwn&#34;: mrkdwn,
                &#34;link_names&#34;: link_names,
                &#34;username&#34;: username,
                &#34;parse&#34;: parse,
                &#34;metadata&#34;: metadata,
            }
        )
        _parse_web_class_objects(kwargs)
        kwargs = _remove_none_values(kwargs)
        _warn_if_text_or_attachment_fallback_is_missing(&#34;chat.postMessage&#34;, kwargs)
        # NOTE: intentionally using json over params for the API methods using blocks/attachments
        return self.api_call(&#34;chat.postMessage&#34;, json=kwargs)

    def chat_scheduleMessage(
        self,
        *,
        channel: str,
        post_at: Union[str, int],
        text: str,
        as_user: Optional[bool] = None,
        attachments: Optional[Union[str, Sequence[Union[Dict, Attachment]]]] = None,
        blocks: Optional[Union[str, Sequence[Union[Dict, Block]]]] = None,
        thread_ts: Optional[str] = None,
        parse: Optional[str] = None,
        reply_broadcast: Optional[bool] = None,
        unfurl_links: Optional[bool] = None,
        unfurl_media: Optional[bool] = None,
        link_names: Optional[bool] = None,
        metadata: Optional[Union[Dict, Metadata]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Schedules a message.
        https://api.slack.com/methods/chat.scheduleMessage
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;post_at&#34;: post_at,
                &#34;text&#34;: text,
                &#34;as_user&#34;: as_user,
                &#34;attachments&#34;: attachments,
                &#34;blocks&#34;: blocks,
                &#34;thread_ts&#34;: thread_ts,
                &#34;reply_broadcast&#34;: reply_broadcast,
                &#34;parse&#34;: parse,
                &#34;unfurl_links&#34;: unfurl_links,
                &#34;unfurl_media&#34;: unfurl_media,
                &#34;link_names&#34;: link_names,
                &#34;metadata&#34;: metadata,
            }
        )
        _parse_web_class_objects(kwargs)
        kwargs = _remove_none_values(kwargs)
        _warn_if_text_or_attachment_fallback_is_missing(&#34;chat.scheduleMessage&#34;, kwargs)
        # NOTE: intentionally using json over params for the API methods using blocks/attachments
        return self.api_call(&#34;chat.scheduleMessage&#34;, json=kwargs)

    def chat_unfurl(
        self,
        *,
        channel: Optional[str] = None,
        ts: Optional[str] = None,
        source: Optional[str] = None,
        unfurl_id: Optional[str] = None,
        unfurls: Optional[Dict[str, Dict]] = None,  # or user_auth_*
        user_auth_blocks: Optional[Union[str, Sequence[Union[Dict, Block]]]] = None,
        user_auth_message: Optional[str] = None,
        user_auth_required: Optional[bool] = None,
        user_auth_url: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Provide custom unfurl behavior for user-posted URLs.
        https://api.slack.com/methods/chat.unfurl
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;ts&#34;: ts,
                &#34;source&#34;: source,
                &#34;unfurl_id&#34;: unfurl_id,
                &#34;unfurls&#34;: unfurls,
                &#34;user_auth_blocks&#34;: user_auth_blocks,
                &#34;user_auth_message&#34;: user_auth_message,
                &#34;user_auth_required&#34;: user_auth_required,
                &#34;user_auth_url&#34;: user_auth_url,
            }
        )
        _parse_web_class_objects(kwargs)  # for user_auth_blocks
        kwargs = _remove_none_values(kwargs)
        # NOTE: intentionally using json over params for API methods using blocks/attachments
        return self.api_call(&#34;chat.unfurl&#34;, json=kwargs)

    def chat_update(
        self,
        *,
        channel: str,
        ts: str,
        text: Optional[str] = None,
        attachments: Optional[Union[str, Sequence[Union[Dict, Attachment]]]] = None,
        blocks: Optional[Union[str, Sequence[Union[Dict, Block]]]] = None,
        as_user: Optional[bool] = None,
        file_ids: Optional[Union[str, Sequence[str]]] = None,
        link_names: Optional[bool] = None,
        parse: Optional[str] = None,  # none, full
        reply_broadcast: Optional[bool] = None,
        metadata: Optional[Union[Dict, Metadata]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Updates a message in a channel.
        https://api.slack.com/methods/chat.update
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;ts&#34;: ts,
                &#34;text&#34;: text,
                &#34;attachments&#34;: attachments,
                &#34;blocks&#34;: blocks,
                &#34;as_user&#34;: as_user,
                &#34;link_names&#34;: link_names,
                &#34;parse&#34;: parse,
                &#34;reply_broadcast&#34;: reply_broadcast,
                &#34;metadata&#34;: metadata,
            }
        )
        if isinstance(file_ids, (list, Tuple)):
            kwargs.update({&#34;file_ids&#34;: &#34;,&#34;.join(file_ids)})
        else:
            kwargs.update({&#34;file_ids&#34;: file_ids})
        _parse_web_class_objects(kwargs)
        kwargs = _remove_none_values(kwargs)
        _warn_if_text_or_attachment_fallback_is_missing(&#34;chat.update&#34;, kwargs)
        # NOTE: intentionally using json over params for API methods using blocks/attachments
        return self.api_call(&#34;chat.update&#34;, json=kwargs)

    def chat_scheduledMessages_list(
        self,
        *,
        channel: Optional[str] = None,
        cursor: Optional[str] = None,
        latest: Optional[str] = None,
        limit: Optional[int] = None,
        oldest: Optional[str] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lists all scheduled messages.
        https://api.slack.com/methods/chat.scheduledMessages.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;cursor&#34;: cursor,
                &#34;latest&#34;: latest,
                &#34;limit&#34;: limit,
                &#34;oldest&#34;: oldest,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;chat.scheduledMessages.list&#34;, params=kwargs)

    def conversations_acceptSharedInvite(
        self,
        *,
        channel_name: str,
        channel_id: Optional[str] = None,
        invite_id: Optional[str] = None,
        free_trial_accepted: Optional[bool] = None,
        is_private: Optional[bool] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Accepts an invitation to a Slack Connect channel.
        https://api.slack.com/methods/conversations.acceptSharedInvite
        &#34;&#34;&#34;
        if channel_id is None and invite_id is None:
            raise e.SlackRequestError(&#34;Either channel_id or invite_id must be provided.&#34;)
        kwargs.update(
            {
                &#34;channel_name&#34;: channel_name,
                &#34;channel_id&#34;: channel_id,
                &#34;invite_id&#34;: invite_id,
                &#34;free_trial_accepted&#34;: free_trial_accepted,
                &#34;is_private&#34;: is_private,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;conversations.acceptSharedInvite&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def conversations_approveSharedInvite(
        self,
        *,
        invite_id: str,
        target_team: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Approves an invitation to a Slack Connect channel.
        https://api.slack.com/methods/conversations.approveSharedInvite
        &#34;&#34;&#34;
        kwargs.update({&#34;invite_id&#34;: invite_id, &#34;target_team&#34;: target_team})
        return self.api_call(&#34;conversations.approveSharedInvite&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def conversations_archive(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Archives a conversation.
        https://api.slack.com/methods/conversations.archive
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        return self.api_call(&#34;conversations.archive&#34;, params=kwargs)

    def conversations_close(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Closes a direct message or multi-person direct message.
        https://api.slack.com/methods/conversations.close
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        return self.api_call(&#34;conversations.close&#34;, params=kwargs)

    def conversations_create(
        self,
        *,
        name: str,
        is_private: Optional[bool] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Initiates a public or private channel-based conversation
        https://api.slack.com/methods/conversations.create
        &#34;&#34;&#34;
        kwargs.update({&#34;name&#34;: name, &#34;is_private&#34;: is_private, &#34;team_id&#34;: team_id})
        return self.api_call(&#34;conversations.create&#34;, params=kwargs)

    def conversations_declineSharedInvite(
        self,
        *,
        invite_id: str,
        target_team: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Declines a Slack Connect channel invite.
        https://api.slack.com/methods/conversations.declineSharedInvite
        &#34;&#34;&#34;
        kwargs.update({&#34;invite_id&#34;: invite_id, &#34;target_team&#34;: target_team})
        return self.api_call(&#34;conversations.declineSharedInvite&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def conversations_history(
        self,
        *,
        channel: str,
        cursor: Optional[str] = None,
        inclusive: Optional[bool] = None,
        include_all_metadata: Optional[bool] = None,
        latest: Optional[str] = None,
        limit: Optional[int] = None,
        oldest: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Fetches a conversation&#39;s history of messages and events.
        https://api.slack.com/methods/conversations.history
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;cursor&#34;: cursor,
                &#34;inclusive&#34;: inclusive,
                &#34;include_all_metadata&#34;: include_all_metadata,
                &#34;limit&#34;: limit,
                &#34;latest&#34;: latest,
                &#34;oldest&#34;: oldest,
            }
        )
        return self.api_call(&#34;conversations.history&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def conversations_info(
        self,
        *,
        channel: str,
        include_locale: Optional[bool] = None,
        include_num_members: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieve information about a conversation.
        https://api.slack.com/methods/conversations.info
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;include_locale&#34;: include_locale,
                &#34;include_num_members&#34;: include_num_members,
            }
        )
        return self.api_call(&#34;conversations.info&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def conversations_invite(
        self,
        *,
        channel: str,
        users: Union[str, Sequence[str]],
        force: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Invites users to a channel.
        https://api.slack.com/methods/conversations.invite
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;force&#34;: force,
            }
        )
        if isinstance(users, (list, Tuple)):
            kwargs.update({&#34;users&#34;: &#34;,&#34;.join(users)})
        else:
            kwargs.update({&#34;users&#34;: users})
        return self.api_call(&#34;conversations.invite&#34;, params=kwargs)

    def conversations_inviteShared(
        self,
        *,
        channel: str,
        emails: Optional[Union[str, Sequence[str]]] = None,
        user_ids: Optional[Union[str, Sequence[str]]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sends an invitation to a Slack Connect channel.
        https://api.slack.com/methods/conversations.inviteShared
        &#34;&#34;&#34;
        if emails is None and user_ids is None:
            raise e.SlackRequestError(&#34;Either emails or user ids must be provided.&#34;)
        kwargs.update({&#34;channel&#34;: channel})
        if isinstance(emails, (list, Tuple)):
            kwargs.update({&#34;emails&#34;: &#34;,&#34;.join(emails)})
        else:
            kwargs.update({&#34;emails&#34;: emails})
        if isinstance(user_ids, (list, Tuple)):
            kwargs.update({&#34;user_ids&#34;: &#34;,&#34;.join(user_ids)})
        else:
            kwargs.update({&#34;user_ids&#34;: user_ids})
        return self.api_call(&#34;conversations.inviteShared&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def conversations_join(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Joins an existing conversation.
        https://api.slack.com/methods/conversations.join
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        return self.api_call(&#34;conversations.join&#34;, params=kwargs)

    def conversations_kick(
        self,
        *,
        channel: str,
        user: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Removes a user from a conversation.
        https://api.slack.com/methods/conversations.kick
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;user&#34;: user})
        return self.api_call(&#34;conversations.kick&#34;, params=kwargs)

    def conversations_leave(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Leaves a conversation.
        https://api.slack.com/methods/conversations.leave
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        return self.api_call(&#34;conversations.leave&#34;, params=kwargs)

    def conversations_list(
        self,
        *,
        cursor: Optional[str] = None,
        exclude_archived: Optional[bool] = None,
        limit: Optional[int] = None,
        team_id: Optional[str] = None,
        types: Optional[Union[str, Sequence[str]]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lists all channels in a Slack team.
        https://api.slack.com/methods/conversations.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;cursor&#34;: cursor,
                &#34;exclude_archived&#34;: exclude_archived,
                &#34;limit&#34;: limit,
                &#34;team_id&#34;: team_id,
            }
        )
        if isinstance(types, (list, Tuple)):
            kwargs.update({&#34;types&#34;: &#34;,&#34;.join(types)})
        else:
            kwargs.update({&#34;types&#34;: types})
        return self.api_call(&#34;conversations.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def conversations_listConnectInvites(
        self,
        *,
        count: Optional[int] = None,
        cursor: Optional[str] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List shared channel invites that have been generated
        or received but have not yet been approved by all parties.
        https://api.slack.com/methods/conversations.listConnectInvites
        &#34;&#34;&#34;
        kwargs.update({&#34;count&#34;: count, &#34;cursor&#34;: cursor, &#34;team_id&#34;: team_id})
        return self.api_call(&#34;conversations.listConnectInvites&#34;, params=kwargs)

    def conversations_mark(
        self,
        *,
        channel: str,
        ts: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sets the read cursor in a channel.
        https://api.slack.com/methods/conversations.mark
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;ts&#34;: ts})
        return self.api_call(&#34;conversations.mark&#34;, params=kwargs)

    def conversations_members(
        self,
        *,
        channel: str,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieve members of a conversation.
        https://api.slack.com/methods/conversations.members
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;cursor&#34;: cursor, &#34;limit&#34;: limit})
        return self.api_call(&#34;conversations.members&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def conversations_open(
        self,
        *,
        channel: Optional[str] = None,
        return_im: Optional[bool] = None,
        users: Optional[Union[str, Sequence[str]]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Opens or resumes a direct message or multi-person direct message.
        https://api.slack.com/methods/conversations.open
        &#34;&#34;&#34;
        if channel is None and users is None:
            raise e.SlackRequestError(&#34;Either channel or users must be provided.&#34;)
        kwargs.update({&#34;channel&#34;: channel, &#34;return_im&#34;: return_im})
        if isinstance(users, (list, Tuple)):
            kwargs.update({&#34;users&#34;: &#34;,&#34;.join(users)})
        else:
            kwargs.update({&#34;users&#34;: users})
        return self.api_call(&#34;conversations.open&#34;, params=kwargs)

    def conversations_rename(
        self,
        *,
        channel: str,
        name: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Renames a conversation.
        https://api.slack.com/methods/conversations.rename
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;name&#34;: name})
        return self.api_call(&#34;conversations.rename&#34;, params=kwargs)

    def conversations_replies(
        self,
        *,
        channel: str,
        ts: str,
        cursor: Optional[str] = None,
        inclusive: Optional[bool] = None,
        include_all_metadata: Optional[bool] = None,
        latest: Optional[str] = None,
        limit: Optional[int] = None,
        oldest: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieve a thread of messages posted to a conversation
        https://api.slack.com/methods/conversations.replies
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;ts&#34;: ts,
                &#34;cursor&#34;: cursor,
                &#34;inclusive&#34;: inclusive,
                &#34;include_all_metadata&#34;: include_all_metadata,
                &#34;limit&#34;: limit,
                &#34;latest&#34;: latest,
                &#34;oldest&#34;: oldest,
            }
        )
        return self.api_call(&#34;conversations.replies&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def conversations_setPurpose(
        self,
        *,
        channel: str,
        purpose: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sets the purpose for a conversation.
        https://api.slack.com/methods/conversations.setPurpose
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;purpose&#34;: purpose})
        return self.api_call(&#34;conversations.setPurpose&#34;, params=kwargs)

    def conversations_setTopic(
        self,
        *,
        channel: str,
        topic: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sets the topic for a conversation.
        https://api.slack.com/methods/conversations.setTopic
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;topic&#34;: topic})
        return self.api_call(&#34;conversations.setTopic&#34;, params=kwargs)

    def conversations_unarchive(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Reverses conversation archival.
        https://api.slack.com/methods/conversations.unarchive
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        return self.api_call(&#34;conversations.unarchive&#34;, params=kwargs)

    def dialog_open(
        self,
        *,
        dialog: Dict[str, Any],
        trigger_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Open a dialog with a user.
        https://api.slack.com/methods/dialog.open
        &#34;&#34;&#34;
        kwargs.update({&#34;dialog&#34;: dialog, &#34;trigger_id&#34;: trigger_id})
        kwargs = _remove_none_values(kwargs)
        # NOTE: As the dialog can be a dict, this API call works only with json format.
        return self.api_call(&#34;dialog.open&#34;, json=kwargs)

    def dnd_endDnd(
        self,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Ends the current user&#39;s Do Not Disturb session immediately.
        https://api.slack.com/methods/dnd.endDnd
        &#34;&#34;&#34;
        return self.api_call(&#34;dnd.endDnd&#34;, params=kwargs)

    def dnd_endSnooze(
        self,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Ends the current user&#39;s snooze mode immediately.
        https://api.slack.com/methods/dnd.endSnooze
        &#34;&#34;&#34;
        return self.api_call(&#34;dnd.endSnooze&#34;, params=kwargs)

    def dnd_info(
        self,
        *,
        team_id: Optional[str] = None,
        user: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieves a user&#39;s current Do Not Disturb status.
        https://api.slack.com/methods/dnd.info
        &#34;&#34;&#34;
        kwargs.update({&#34;team_id&#34;: team_id, &#34;user&#34;: user})
        return self.api_call(&#34;dnd.info&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def dnd_setSnooze(
        self,
        *,
        num_minutes: Union[int, str],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Turns on Do Not Disturb mode for the current user, or changes its duration.
        https://api.slack.com/methods/dnd.setSnooze
        &#34;&#34;&#34;
        kwargs.update({&#34;num_minutes&#34;: num_minutes})
        return self.api_call(&#34;dnd.setSnooze&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def dnd_teamInfo(
        self,
        users: Union[str, Sequence[str]],
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieves the Do Not Disturb status for users on a team.
        https://api.slack.com/methods/dnd.teamInfo
        &#34;&#34;&#34;
        if isinstance(users, (list, Tuple)):
            kwargs.update({&#34;users&#34;: &#34;,&#34;.join(users)})
        else:
            kwargs.update({&#34;users&#34;: users})
        kwargs.update({&#34;team_id&#34;: team_id})
        return self.api_call(&#34;dnd.teamInfo&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def emoji_list(
        self,
        include_categories: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lists custom emoji for a team.
        https://api.slack.com/methods/emoji.list
        &#34;&#34;&#34;
        kwargs.update({&#34;include_categories&#34;: include_categories})
        return self.api_call(&#34;emoji.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def files_comments_delete(
        self,
        *,
        file: str,
        id: str,
        **kwargs,  # skipcq: PYL-W0622
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Deletes an existing comment on a file.
        https://api.slack.com/methods/files.comments.delete
        &#34;&#34;&#34;
        kwargs.update({&#34;file&#34;: file, &#34;id&#34;: id})
        return self.api_call(&#34;files.comments.delete&#34;, params=kwargs)

    def files_delete(
        self,
        *,
        file: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Deletes a file.
        https://api.slack.com/methods/files.delete
        &#34;&#34;&#34;
        kwargs.update({&#34;file&#34;: file})
        return self.api_call(&#34;files.delete&#34;, params=kwargs)

    def files_info(
        self,
        *,
        file: str,
        count: Optional[int] = None,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        page: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Gets information about a team file.
        https://api.slack.com/methods/files.info
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;file&#34;: file,
                &#34;count&#34;: count,
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
                &#34;page&#34;: page,
            }
        )
        return self.api_call(&#34;files.info&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def files_list(
        self,
        *,
        channel: Optional[str] = None,
        count: Optional[int] = None,
        page: Optional[int] = None,
        show_files_hidden_by_limit: Optional[bool] = None,
        team_id: Optional[str] = None,
        ts_from: Optional[str] = None,
        ts_to: Optional[str] = None,
        types: Optional[Union[str, Sequence[str]]] = None,
        user: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lists &amp; filters team files.
        https://api.slack.com/methods/files.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;count&#34;: count,
                &#34;page&#34;: page,
                &#34;show_files_hidden_by_limit&#34;: show_files_hidden_by_limit,
                &#34;team_id&#34;: team_id,
                &#34;ts_from&#34;: ts_from,
                &#34;ts_to&#34;: ts_to,
                &#34;user&#34;: user,
            }
        )
        if isinstance(types, (list, Tuple)):
            kwargs.update({&#34;types&#34;: &#34;,&#34;.join(types)})
        else:
            kwargs.update({&#34;types&#34;: types})
        return self.api_call(&#34;files.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def files_remote_info(
        self,
        *,
        external_id: Optional[str] = None,
        file: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieve information about a remote file added to Slack.
        https://api.slack.com/methods/files.remote.info
        &#34;&#34;&#34;
        kwargs.update({&#34;external_id&#34;: external_id, &#34;file&#34;: file})
        return self.api_call(&#34;files.remote.info&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def files_remote_list(
        self,
        *,
        channel: Optional[str] = None,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        ts_from: Optional[str] = None,
        ts_to: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieve information about a remote file added to Slack.
        https://api.slack.com/methods/files.remote.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
                &#34;ts_from&#34;: ts_from,
                &#34;ts_to&#34;: ts_to,
            }
        )
        return self.api_call(&#34;files.remote.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def files_remote_add(
        self,
        *,
        external_id: str,
        external_url: str,
        title: str,
        filetype: Optional[str] = None,
        indexable_file_contents: Optional[Union[str, bytes, IOBase]] = None,
        preview_image: Optional[Union[str, bytes, IOBase]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Adds a file from a remote service.
        https://api.slack.com/methods/files.remote.add
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;external_id&#34;: external_id,
                &#34;external_url&#34;: external_url,
                &#34;title&#34;: title,
                &#34;filetype&#34;: filetype,
            }
        )
        files = None
        # preview_image (file): Preview of the document via multipart/form-data.
        if preview_image is not None or indexable_file_contents is not None:
            files = {
                &#34;preview_image&#34;: preview_image,
                &#34;indexable_file_contents&#34;: indexable_file_contents,
            }

        return self.api_call(
            # Intentionally using &#34;POST&#34; method over &#34;GET&#34; here
            &#34;files.remote.add&#34;,
            http_verb=&#34;POST&#34;,
            data=kwargs,
            files=files,
        )

    def files_remote_update(
        self,
        *,
        external_id: Optional[str] = None,
        external_url: Optional[str] = None,
        file: Optional[str] = None,
        title: Optional[str] = None,
        filetype: Optional[str] = None,
        indexable_file_contents: Optional[str] = None,
        preview_image: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Updates an existing remote file.
        https://api.slack.com/methods/files.remote.update
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;external_id&#34;: external_id,
                &#34;external_url&#34;: external_url,
                &#34;file&#34;: file,
                &#34;title&#34;: title,
                &#34;filetype&#34;: filetype,
            }
        )
        files = None
        # preview_image (file): Preview of the document via multipart/form-data.
        if preview_image is not None or indexable_file_contents is not None:
            files = {
                &#34;preview_image&#34;: preview_image,
                &#34;indexable_file_contents&#34;: indexable_file_contents,
            }

        return self.api_call(
            # Intentionally using &#34;POST&#34; method over &#34;GET&#34; here
            &#34;files.remote.update&#34;,
            http_verb=&#34;POST&#34;,
            data=kwargs,
            files=files,
        )

    def files_remote_remove(
        self,
        *,
        external_id: Optional[str] = None,
        file: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Remove a remote file.
        https://api.slack.com/methods/files.remote.remove
        &#34;&#34;&#34;
        kwargs.update({&#34;external_id&#34;: external_id, &#34;file&#34;: file})
        return self.api_call(&#34;files.remote.remove&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def files_remote_share(
        self,
        *,
        channels: Union[str, Sequence[str]],
        external_id: Optional[str] = None,
        file: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Share a remote file into a channel.
        https://api.slack.com/methods/files.remote.share
        &#34;&#34;&#34;
        if external_id is None and file is None:
            raise e.SlackRequestError(&#34;Either external_id or file must be provided.&#34;)
        if isinstance(channels, (list, Tuple)):
            kwargs.update({&#34;channels&#34;: &#34;,&#34;.join(channels)})
        else:
            kwargs.update({&#34;channels&#34;: channels})
        kwargs.update({&#34;external_id&#34;: external_id, &#34;file&#34;: file})
        return self.api_call(&#34;files.remote.share&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def files_revokePublicURL(
        self,
        *,
        file: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Revokes public/external sharing access for a file
        https://api.slack.com/methods/files.revokePublicURL
        &#34;&#34;&#34;
        kwargs.update({&#34;file&#34;: file})
        return self.api_call(&#34;files.revokePublicURL&#34;, params=kwargs)

    def files_sharedPublicURL(
        self,
        *,
        file: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Enables a file for public/external sharing.
        https://api.slack.com/methods/files.sharedPublicURL
        &#34;&#34;&#34;
        kwargs.update({&#34;file&#34;: file})
        return self.api_call(&#34;files.sharedPublicURL&#34;, params=kwargs)

    def files_upload(
        self,
        *,
        file: Optional[Union[str, bytes, IOBase]] = None,
        content: Optional[Union[str, bytes]] = None,
        filename: Optional[str] = None,
        filetype: Optional[str] = None,
        initial_comment: Optional[str] = None,
        thread_ts: Optional[str] = None,
        title: Optional[str] = None,
        channels: Optional[Union[str, Sequence[str]]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Uploads or creates a file.
        https://api.slack.com/methods/files.upload
        &#34;&#34;&#34;
        _print_files_upload_v2_suggestion()

        if file is None and content is None:
            raise e.SlackRequestError(&#34;The file or content argument must be specified.&#34;)
        if file is not None and content is not None:
            raise e.SlackRequestError(&#34;You cannot specify both the file and the content argument.&#34;)

        if isinstance(channels, (list, Tuple)):
            kwargs.update({&#34;channels&#34;: &#34;,&#34;.join(channels)})
        else:
            kwargs.update({&#34;channels&#34;: channels})
        kwargs.update(
            {
                &#34;filename&#34;: filename,
                &#34;filetype&#34;: filetype,
                &#34;initial_comment&#34;: initial_comment,
                &#34;thread_ts&#34;: thread_ts,
                &#34;title&#34;: title,
            }
        )
        if file:
            if kwargs.get(&#34;filename&#34;) is None and isinstance(file, str):
                # use the local filename if filename is missing
                if kwargs.get(&#34;filename&#34;) is None:
                    kwargs[&#34;filename&#34;] = file.split(os.path.sep)[-1]
            return self.api_call(&#34;files.upload&#34;, files={&#34;file&#34;: file}, data=kwargs)
        else:
            kwargs[&#34;content&#34;] = content
            return self.api_call(&#34;files.upload&#34;, data=kwargs)

    def files_upload_v2(
        self,
        *,
        # for sending a single file
        filename: Optional[str] = None,  # you can skip this only when sending along with content parameter
        file: Optional[Union[str, bytes, IOBase]] = None,
        content: Optional[Union[str, bytes]] = None,
        title: Optional[str] = None,
        alt_txt: Optional[str] = None,
        snippet_type: Optional[str] = None,
        # To upload multiple files at a time
        file_uploads: Optional[List[Dict[str, Any]]] = None,
        channel: Optional[str] = None,
        initial_comment: Optional[str] = None,
        thread_ts: Optional[str] = None,
        request_file_info: bool = True,  # since v3.23, this flag is no longer necessary
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;This wrapper method provides an easy way to upload files using the following endpoints:

        - step1: https://api.slack.com/methods/files.getUploadURLExternal

        - step2: &#34;https://files.slack.com/upload/v1/...&#34; URLs returned from files.getUploadURLExternal API

        - step3: https://api.slack.com/methods/files.completeUploadExternal
            and https://api.slack.com/methods/files.info

        &#34;&#34;&#34;
        if file is None and content is None and file_uploads is None:
            raise e.SlackRequestError(&#34;Any of file, content, and file_uploads must be specified.&#34;)
        if file is not None and content is not None:
            raise e.SlackRequestError(&#34;You cannot specify both the file and the content argument.&#34;)

        # deprecated arguments:
        channels, filetype = kwargs.get(&#34;channels&#34;), kwargs.get(&#34;filetype&#34;)

        if channels is not None:
            warnings.warn(
                &#34;Although the channels parameter is still supported for smooth migration from legacy files.upload, &#34;
                &#34;we recommend using the new channel parameter with a single str value instead for more clarity.&#34;
            )
            if (isinstance(channels, (list, Tuple)) and len(channels) &gt; 1) or (
                isinstance(channels, str) and len(channels.split(&#34;,&#34;)) &gt; 1
            ):
                raise e.SlackRequestError(
                    &#34;Sharing files with multiple channels is no longer supported in v2. &#34;
                    &#34;Share files in each channel separately instead.&#34;
                )
        if filetype is not None:
            warnings.warn(&#34;The filetype parameter is no longer supported. Please remove it from the arguments.&#34;)

        # step1: files.getUploadURLExternal per file
        files: List[Dict[str, Any]] = []
        if file_uploads is not None:
            for f in file_uploads:
                files.append(_to_v2_file_upload_item(f))
        else:
            f = _to_v2_file_upload_item(
                {
                    &#34;filename&#34;: filename,
                    &#34;file&#34;: file,
                    &#34;content&#34;: content,
                    &#34;title&#34;: title,
                    &#34;alt_txt&#34;: alt_txt,
                    &#34;snippet_type&#34;: snippet_type,
                }
            )
            files.append(f)

        for f in files:
            url_response = self.files_getUploadURLExternal(
                filename=f.get(&#34;filename&#34;),
                length=f.get(&#34;length&#34;),
                alt_txt=f.get(&#34;alt_txt&#34;),
                snippet_type=f.get(&#34;snippet_type&#34;),
                token=kwargs.get(&#34;token&#34;),
            )
            _validate_for_legacy_client(url_response)
            f[&#34;file_id&#34;] = url_response.get(&#34;file_id&#34;)  # type: ignore
            f[&#34;upload_url&#34;] = url_response.get(&#34;upload_url&#34;)  # type: ignore

        # step2: &#34;https://files.slack.com/upload/v1/...&#34; per file
        for f in files:
            upload_result = _upload_file_via_v2_url(
                url=f[&#34;upload_url&#34;],
                data=f[&#34;data&#34;],
                logger=self._logger,
                timeout=self.timeout,
                proxy=self.proxy,
                ssl=self.ssl,
            )
            if upload_result.get(&#34;status&#34;) != 200:
                status = upload_result.get(&#34;status&#34;)
                body = upload_result.get(&#34;body&#34;)
                message = (
                    &#34;Failed to upload a file &#34;
                    f&#34;(status: {status}, body: {body}, filename: {f.get(&#39;filename&#39;)}, title: {f.get(&#39;title&#39;)})&#34;
                )
                raise e.SlackRequestError(message)

        # step3: files.completeUploadExternal with all the sets of (file_id + title)
        channel_to_share = channel
        if channels is not None:
            if isinstance(channels, str):
                channel_to_share = channels.split(&#34;,&#34;)[0]
            else:
                channel_to_share = channels[0]
        completion = self.files_completeUploadExternal(
            files=[{&#34;id&#34;: f[&#34;file_id&#34;], &#34;title&#34;: f[&#34;title&#34;]} for f in files],
            channel_id=channel_to_share,
            initial_comment=initial_comment,
            thread_ts=thread_ts,
            **kwargs,
        )
        if len(completion.get(&#34;files&#34;)) == 1:  # type: ignore
            completion.data[&#34;file&#34;] = completion.get(&#34;files&#34;)[0]  # type: ignore
        return completion

    def files_getUploadURLExternal(
        self,
        *,
        filename: str,
        length: int,
        alt_txt: Optional[str] = None,
        snippet_type: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Gets a URL for an edge external upload.
        https://api.slack.com/methods/files.getUploadURLExternal
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;filename&#34;: filename,
                &#34;length&#34;: length,
                &#34;alt_txt&#34;: alt_txt,
                &#34;snippet_type&#34;: snippet_type,
            }
        )
        return self.api_call(&#34;files.getUploadURLExternal&#34;, params=kwargs)

    def files_completeUploadExternal(
        self,
        *,
        files: List[Dict[str, str]],
        channel_id: Optional[str] = None,
        initial_comment: Optional[str] = None,
        thread_ts: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Finishes an upload started with files.getUploadURLExternal.
        https://api.slack.com/methods/files.completeUploadExternal
        &#34;&#34;&#34;
        _files = [{k: v for k, v in f.items() if v is not None} for f in files]
        kwargs.update(
            {
                &#34;files&#34;: json.dumps(_files),
                &#34;channel_id&#34;: channel_id,
                &#34;initial_comment&#34;: initial_comment,
                &#34;thread_ts&#34;: thread_ts,
            }
        )
        return self.api_call(&#34;files.completeUploadExternal&#34;, params=kwargs)

    def functions_completeSuccess(
        self,
        *,
        function_execution_id: str,
        outputs: Dict[str, Any],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Signal the successful completion of a function
        https://api.slack.com/methods/functions.completeSuccess
        &#34;&#34;&#34;
        kwargs.update({&#34;function_execution_id&#34;: function_execution_id, &#34;outputs&#34;: json.dumps(outputs)})
        return self.api_call(&#34;functions.completeSuccess&#34;, params=kwargs)

    def functions_completeError(
        self,
        *,
        function_execution_id: str,
        error: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Signal the failure to execute a function
        https://api.slack.com/methods/functions.completeError
        &#34;&#34;&#34;
        kwargs.update({&#34;function_execution_id&#34;: function_execution_id, &#34;error&#34;: error})
        return self.api_call(&#34;functions.completeError&#34;, params=kwargs)

    # --------------------------
    # Deprecated: groups.*
    # You can use conversations.* APIs instead.
    # https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api
    # --------------------------

    def groups_archive(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Archives a private channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;groups.archive&#34;, json=kwargs)

    def groups_create(
        self,
        *,
        name: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Creates a private channel.&#34;&#34;&#34;
        kwargs.update({&#34;name&#34;: name})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;groups.create&#34;, json=kwargs)

    def groups_createChild(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Clones and archives a private channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        return self.api_call(&#34;groups.createChild&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def groups_history(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Fetches history of messages and events from a private channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        return self.api_call(&#34;groups.history&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def groups_info(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Gets information about a private channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        return self.api_call(&#34;groups.info&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def groups_invite(
        self,
        *,
        channel: str,
        user: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Invites a user to a private channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;user&#34;: user})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;groups.invite&#34;, json=kwargs)

    def groups_kick(
        self,
        *,
        channel: str,
        user: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Removes a user from a private channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;user&#34;: user})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;groups.kick&#34;, json=kwargs)

    def groups_leave(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Leaves a private channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;groups.leave&#34;, json=kwargs)

    def groups_list(
        self,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lists private channels that the calling user has access to.&#34;&#34;&#34;
        return self.api_call(&#34;groups.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def groups_mark(
        self,
        *,
        channel: str,
        ts: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sets the read cursor in a private channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;ts&#34;: ts})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;groups.mark&#34;, json=kwargs)

    def groups_open(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Opens a private channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;groups.open&#34;, json=kwargs)

    def groups_rename(
        self,
        *,
        channel: str,
        name: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Renames a private channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;name&#34;: name})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;groups.rename&#34;, json=kwargs)

    def groups_replies(
        self,
        *,
        channel: str,
        thread_ts: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieve a thread of messages posted to a private channel&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;thread_ts&#34;: thread_ts})
        return self.api_call(&#34;groups.replies&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def groups_setPurpose(
        self,
        *,
        channel: str,
        purpose: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sets the purpose for a private channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;purpose&#34;: purpose})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;groups.setPurpose&#34;, json=kwargs)

    def groups_setTopic(
        self,
        *,
        channel: str,
        topic: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sets the topic for a private channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;topic&#34;: topic})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;groups.setTopic&#34;, json=kwargs)

    def groups_unarchive(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Unarchives a private channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;groups.unarchive&#34;, json=kwargs)

    # --------------------------
    # Deprecated: im.*
    # You can use conversations.* APIs instead.
    # https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api
    # --------------------------

    def im_close(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Close a direct message channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;im.close&#34;, json=kwargs)

    def im_history(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Fetches history of messages and events from direct message channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        return self.api_call(&#34;im.history&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def im_list(
        self,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lists direct message channels for the calling user.&#34;&#34;&#34;
        return self.api_call(&#34;im.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def im_mark(
        self,
        *,
        channel: str,
        ts: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sets the read cursor in a direct message channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;ts&#34;: ts})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;im.mark&#34;, json=kwargs)

    def im_open(
        self,
        *,
        user: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Opens a direct message channel.&#34;&#34;&#34;
        kwargs.update({&#34;user&#34;: user})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;im.open&#34;, json=kwargs)

    def im_replies(
        self,
        *,
        channel: str,
        thread_ts: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieve a thread of messages posted to a direct message conversation&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;thread_ts&#34;: thread_ts})
        return self.api_call(&#34;im.replies&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    # --------------------------

    def migration_exchange(
        self,
        *,
        users: Union[str, Sequence[str]],
        team_id: Optional[str] = None,
        to_old: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;For Enterprise Grid workspaces, map local user IDs to global user IDs
        https://api.slack.com/methods/migration.exchange
        &#34;&#34;&#34;
        if isinstance(users, (list, Tuple)):
            kwargs.update({&#34;users&#34;: &#34;,&#34;.join(users)})
        else:
            kwargs.update({&#34;users&#34;: users})
        kwargs.update({&#34;team_id&#34;: team_id, &#34;to_old&#34;: to_old})
        return self.api_call(&#34;migration.exchange&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    # --------------------------
    # Deprecated: mpim.*
    # You can use conversations.* APIs instead.
    # https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api
    # --------------------------

    def mpim_close(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Closes a multiparty direct message channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;mpim.close&#34;, json=kwargs)

    def mpim_history(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Fetches history of messages and events from a multiparty direct message.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        return self.api_call(&#34;mpim.history&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def mpim_list(
        self,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lists multiparty direct message channels for the calling user.&#34;&#34;&#34;
        return self.api_call(&#34;mpim.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def mpim_mark(
        self,
        *,
        channel: str,
        ts: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sets the read cursor in a multiparty direct message channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;ts&#34;: ts})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;mpim.mark&#34;, json=kwargs)

    def mpim_open(
        self,
        *,
        users: Union[str, Sequence[str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;This method opens a multiparty direct message.&#34;&#34;&#34;
        if isinstance(users, (list, Tuple)):
            kwargs.update({&#34;users&#34;: &#34;,&#34;.join(users)})
        else:
            kwargs.update({&#34;users&#34;: users})
        return self.api_call(&#34;mpim.open&#34;, params=kwargs)

    def mpim_replies(
        self,
        *,
        channel: str,
        thread_ts: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieve a thread of messages posted to a direct message conversation from a
        multiparty direct message.
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;thread_ts&#34;: thread_ts})
        return self.api_call(&#34;mpim.replies&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    # --------------------------

    def oauth_v2_access(
        self,
        *,
        client_id: str,
        client_secret: str,
        # This field is required when processing the OAuth redirect URL requests
        # while it&#39;s absent for token rotation
        code: Optional[str] = None,
        redirect_uri: Optional[str] = None,
        # This field is required for token rotation
        grant_type: Optional[str] = None,
        # This field is required for token rotation
        refresh_token: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Exchanges a temporary OAuth verifier code for an access token.
        https://api.slack.com/methods/oauth.v2.access
        &#34;&#34;&#34;
        if redirect_uri is not None:
            kwargs.update({&#34;redirect_uri&#34;: redirect_uri})
        if code is not None:
            kwargs.update({&#34;code&#34;: code})
        if grant_type is not None:
            kwargs.update({&#34;grant_type&#34;: grant_type})
        if refresh_token is not None:
            kwargs.update({&#34;refresh_token&#34;: refresh_token})
        return self.api_call(
            &#34;oauth.v2.access&#34;,
            data=kwargs,
            auth={&#34;client_id&#34;: client_id, &#34;client_secret&#34;: client_secret},
        )

    def oauth_access(
        self,
        *,
        client_id: str,
        client_secret: str,
        code: str,
        redirect_uri: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Exchanges a temporary OAuth verifier code for an access token.
        https://api.slack.com/methods/oauth.access
        &#34;&#34;&#34;
        if redirect_uri is not None:
            kwargs.update({&#34;redirect_uri&#34;: redirect_uri})
        kwargs.update({&#34;code&#34;: code})
        return self.api_call(
            &#34;oauth.access&#34;,
            data=kwargs,
            auth={&#34;client_id&#34;: client_id, &#34;client_secret&#34;: client_secret},
        )

    def oauth_v2_exchange(
        self,
        *,
        token: str,
        client_id: str,
        client_secret: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Exchanges a legacy access token for a new expiring access token and refresh token
        https://api.slack.com/methods/oauth.v2.exchange
        &#34;&#34;&#34;
        kwargs.update({&#34;client_id&#34;: client_id, &#34;client_secret&#34;: client_secret, &#34;token&#34;: token})
        return self.api_call(&#34;oauth.v2.exchange&#34;, params=kwargs)

    def openid_connect_token(
        self,
        client_id: str,
        client_secret: str,
        code: Optional[str] = None,
        redirect_uri: Optional[str] = None,
        grant_type: Optional[str] = None,
        refresh_token: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Exchanges a temporary OAuth verifier code for an access token for Sign in with Slack.
        https://api.slack.com/methods/openid.connect.token
        &#34;&#34;&#34;
        if redirect_uri is not None:
            kwargs.update({&#34;redirect_uri&#34;: redirect_uri})
        if code is not None:
            kwargs.update({&#34;code&#34;: code})
        if grant_type is not None:
            kwargs.update({&#34;grant_type&#34;: grant_type})
        if refresh_token is not None:
            kwargs.update({&#34;refresh_token&#34;: refresh_token})
        return self.api_call(
            &#34;openid.connect.token&#34;,
            data=kwargs,
            auth={&#34;client_id&#34;: client_id, &#34;client_secret&#34;: client_secret},
        )

    def openid_connect_userInfo(
        self,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Get the identity of a user who has authorized Sign in with Slack.
        https://api.slack.com/methods/openid.connect.userInfo
        &#34;&#34;&#34;
        return self.api_call(&#34;openid.connect.userInfo&#34;, params=kwargs)

    def pins_add(
        self,
        *,
        channel: str,
        timestamp: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Pins an item to a channel.
        https://api.slack.com/methods/pins.add
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;timestamp&#34;: timestamp})
        return self.api_call(&#34;pins.add&#34;, params=kwargs)

    def pins_list(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lists items pinned to a channel.
        https://api.slack.com/methods/pins.list
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        return self.api_call(&#34;pins.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def pins_remove(
        self,
        *,
        channel: str,
        timestamp: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Un-pins an item from a channel.
        https://api.slack.com/methods/pins.remove
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;timestamp&#34;: timestamp})
        return self.api_call(&#34;pins.remove&#34;, params=kwargs)

    def reactions_add(
        self,
        *,
        channel: str,
        name: str,
        timestamp: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Adds a reaction to an item.
        https://api.slack.com/methods/reactions.add
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;name&#34;: name, &#34;timestamp&#34;: timestamp})
        return self.api_call(&#34;reactions.add&#34;, params=kwargs)

    def reactions_get(
        self,
        *,
        channel: Optional[str] = None,
        file: Optional[str] = None,
        file_comment: Optional[str] = None,
        full: Optional[bool] = None,
        timestamp: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Gets reactions for an item.
        https://api.slack.com/methods/reactions.get
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;file&#34;: file,
                &#34;file_comment&#34;: file_comment,
                &#34;full&#34;: full,
                &#34;timestamp&#34;: timestamp,
            }
        )
        return self.api_call(&#34;reactions.get&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def reactions_list(
        self,
        *,
        count: Optional[int] = None,
        cursor: Optional[str] = None,
        full: Optional[bool] = None,
        limit: Optional[int] = None,
        page: Optional[int] = None,
        team_id: Optional[str] = None,
        user: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lists reactions made by a user.
        https://api.slack.com/methods/reactions.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;count&#34;: count,
                &#34;cursor&#34;: cursor,
                &#34;full&#34;: full,
                &#34;limit&#34;: limit,
                &#34;page&#34;: page,
                &#34;team_id&#34;: team_id,
                &#34;user&#34;: user,
            }
        )
        return self.api_call(&#34;reactions.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def reactions_remove(
        self,
        *,
        name: str,
        channel: Optional[str] = None,
        file: Optional[str] = None,
        file_comment: Optional[str] = None,
        timestamp: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Removes a reaction from an item.
        https://api.slack.com/methods/reactions.remove
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;name&#34;: name,
                &#34;channel&#34;: channel,
                &#34;file&#34;: file,
                &#34;file_comment&#34;: file_comment,
                &#34;timestamp&#34;: timestamp,
            }
        )
        return self.api_call(&#34;reactions.remove&#34;, params=kwargs)

    def reminders_add(
        self,
        *,
        text: str,
        time: str,
        team_id: Optional[str] = None,
        user: Optional[str] = None,
        recurrence: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Creates a reminder.
        https://api.slack.com/methods/reminders.add
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;text&#34;: text,
                &#34;time&#34;: time,
                &#34;team_id&#34;: team_id,
                &#34;user&#34;: user,
                &#34;recurrence&#34;: recurrence,
            }
        )
        return self.api_call(&#34;reminders.add&#34;, params=kwargs)

    def reminders_complete(
        self,
        *,
        reminder: str,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Marks a reminder as complete.
        https://api.slack.com/methods/reminders.complete
        &#34;&#34;&#34;
        kwargs.update({&#34;reminder&#34;: reminder, &#34;team_id&#34;: team_id})
        return self.api_call(&#34;reminders.complete&#34;, params=kwargs)

    def reminders_delete(
        self,
        *,
        reminder: str,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Deletes a reminder.
        https://api.slack.com/methods/reminders.delete
        &#34;&#34;&#34;
        kwargs.update({&#34;reminder&#34;: reminder, &#34;team_id&#34;: team_id})
        return self.api_call(&#34;reminders.delete&#34;, params=kwargs)

    def reminders_info(
        self,
        *,
        reminder: str,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Gets information about a reminder.
        https://api.slack.com/methods/reminders.info
        &#34;&#34;&#34;
        kwargs.update({&#34;reminder&#34;: reminder, &#34;team_id&#34;: team_id})
        return self.api_call(&#34;reminders.info&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def reminders_list(
        self,
        *,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lists all reminders created by or for a given user.
        https://api.slack.com/methods/reminders.list
        &#34;&#34;&#34;
        kwargs.update({&#34;team_id&#34;: team_id})
        return self.api_call(&#34;reminders.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def rtm_connect(
        self,
        *,
        batch_presence_aware: Optional[bool] = None,
        presence_sub: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Starts a Real Time Messaging session.
        https://api.slack.com/methods/rtm.connect
        &#34;&#34;&#34;
        kwargs.update({&#34;batch_presence_aware&#34;: batch_presence_aware, &#34;presence_sub&#34;: presence_sub})
        return self.api_call(&#34;rtm.connect&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def rtm_start(
        self,
        *,
        batch_presence_aware: Optional[bool] = None,
        include_locale: Optional[bool] = None,
        mpim_aware: Optional[bool] = None,
        no_latest: Optional[bool] = None,
        no_unreads: Optional[bool] = None,
        presence_sub: Optional[bool] = None,
        simple_latest: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Starts a Real Time Messaging session.
        https://api.slack.com/methods/rtm.start
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;batch_presence_aware&#34;: batch_presence_aware,
                &#34;include_locale&#34;: include_locale,
                &#34;mpim_aware&#34;: mpim_aware,
                &#34;no_latest&#34;: no_latest,
                &#34;no_unreads&#34;: no_unreads,
                &#34;presence_sub&#34;: presence_sub,
                &#34;simple_latest&#34;: simple_latest,
            }
        )
        return self.api_call(&#34;rtm.start&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def search_all(
        self,
        *,
        query: str,
        count: Optional[int] = None,
        highlight: Optional[bool] = None,
        page: Optional[int] = None,
        sort: Optional[str] = None,
        sort_dir: Optional[str] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Searches for messages and files matching a query.
        https://api.slack.com/methods/search.all
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;query&#34;: query,
                &#34;count&#34;: count,
                &#34;highlight&#34;: highlight,
                &#34;page&#34;: page,
                &#34;sort&#34;: sort,
                &#34;sort_dir&#34;: sort_dir,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;search.all&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def search_files(
        self,
        *,
        query: str,
        count: Optional[int] = None,
        highlight: Optional[bool] = None,
        page: Optional[int] = None,
        sort: Optional[str] = None,
        sort_dir: Optional[str] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Searches for files matching a query.
        https://api.slack.com/methods/search.files
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;query&#34;: query,
                &#34;count&#34;: count,
                &#34;highlight&#34;: highlight,
                &#34;page&#34;: page,
                &#34;sort&#34;: sort,
                &#34;sort_dir&#34;: sort_dir,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;search.files&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def search_messages(
        self,
        *,
        query: str,
        count: Optional[int] = None,
        cursor: Optional[str] = None,
        highlight: Optional[bool] = None,
        page: Optional[int] = None,
        sort: Optional[str] = None,
        sort_dir: Optional[str] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Searches for messages matching a query.
        https://api.slack.com/methods/search.messages
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;query&#34;: query,
                &#34;count&#34;: count,
                &#34;cursor&#34;: cursor,
                &#34;highlight&#34;: highlight,
                &#34;page&#34;: page,
                &#34;sort&#34;: sort,
                &#34;sort_dir&#34;: sort_dir,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;search.messages&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def stars_add(
        self,
        *,
        channel: Optional[str] = None,
        file: Optional[str] = None,
        file_comment: Optional[str] = None,
        timestamp: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Adds a star to an item.
        https://api.slack.com/methods/stars.add
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;file&#34;: file,
                &#34;file_comment&#34;: file_comment,
                &#34;timestamp&#34;: timestamp,
            }
        )
        return self.api_call(&#34;stars.add&#34;, params=kwargs)

    def stars_list(
        self,
        *,
        count: Optional[int] = None,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        page: Optional[int] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lists stars for a user.
        https://api.slack.com/methods/stars.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;count&#34;: count,
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
                &#34;page&#34;: page,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;stars.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def stars_remove(
        self,
        *,
        channel: Optional[str] = None,
        file: Optional[str] = None,
        file_comment: Optional[str] = None,
        timestamp: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Removes a star from an item.
        https://api.slack.com/methods/stars.remove
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;file&#34;: file,
                &#34;file_comment&#34;: file_comment,
                &#34;timestamp&#34;: timestamp,
            }
        )
        return self.api_call(&#34;stars.remove&#34;, params=kwargs)

    def team_accessLogs(
        self,
        *,
        before: Optional[Union[int, str]] = None,
        count: Optional[Union[int, str]] = None,
        page: Optional[Union[int, str]] = None,
        team_id: Optional[str] = None,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Gets the access logs for the current team.
        https://api.slack.com/methods/team.accessLogs
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;before&#34;: before,
                &#34;count&#34;: count,
                &#34;page&#34;: page,
                &#34;team_id&#34;: team_id,
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
            }
        )
        return self.api_call(&#34;team.accessLogs&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def team_billableInfo(
        self,
        *,
        team_id: Optional[str] = None,
        user: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Gets billable users information for the current team.
        https://api.slack.com/methods/team.billableInfo
        &#34;&#34;&#34;
        kwargs.update({&#34;team_id&#34;: team_id, &#34;user&#34;: user})
        return self.api_call(&#34;team.billableInfo&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def team_billing_info(
        self,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Reads a workspace&#39;s billing plan information.
        https://api.slack.com/methods/team.billing.info
        &#34;&#34;&#34;
        return self.api_call(&#34;team.billing.info&#34;, params=kwargs)

    def team_info(
        self,
        *,
        team: Optional[str] = None,
        domain: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Gets information about the current team.
        https://api.slack.com/methods/team.info
        &#34;&#34;&#34;
        kwargs.update({&#34;team&#34;: team, &#34;domain&#34;: domain})
        return self.api_call(&#34;team.info&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def team_integrationLogs(
        self,
        *,
        app_id: Optional[str] = None,
        change_type: Optional[str] = None,
        count: Optional[Union[int, str]] = None,
        page: Optional[Union[int, str]] = None,
        service_id: Optional[str] = None,
        team_id: Optional[str] = None,
        user: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Gets the integration logs for the current team.
        https://api.slack.com/methods/team.integrationLogs
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;app_id&#34;: app_id,
                &#34;change_type&#34;: change_type,
                &#34;count&#34;: count,
                &#34;page&#34;: page,
                &#34;service_id&#34;: service_id,
                &#34;team_id&#34;: team_id,
                &#34;user&#34;: user,
            }
        )
        return self.api_call(&#34;team.integrationLogs&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def team_profile_get(
        self,
        *,
        visibility: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieve a team&#39;s profile.
        https://api.slack.com/methods/team.profile.get
        &#34;&#34;&#34;
        kwargs.update({&#34;visibility&#34;: visibility})
        return self.api_call(&#34;team.profile.get&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def team_preferences_list(
        self,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieve a list of a workspace&#39;s team preferences.
        https://api.slack.com/methods/team.preferences.list
        &#34;&#34;&#34;
        return self.api_call(&#34;team.preferences.list&#34;, params=kwargs)

    def usergroups_create(
        self,
        *,
        name: str,
        channels: Optional[Union[str, Sequence[str]]] = None,
        description: Optional[str] = None,
        handle: Optional[str] = None,
        include_count: Optional[bool] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Create a User Group
        https://api.slack.com/methods/usergroups.create
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;name&#34;: name,
                &#34;description&#34;: description,
                &#34;handle&#34;: handle,
                &#34;include_count&#34;: include_count,
                &#34;team_id&#34;: team_id,
            }
        )
        if isinstance(channels, (list, Tuple)):
            kwargs.update({&#34;channels&#34;: &#34;,&#34;.join(channels)})
        else:
            kwargs.update({&#34;channels&#34;: channels})
        return self.api_call(&#34;usergroups.create&#34;, params=kwargs)

    def usergroups_disable(
        self,
        *,
        usergroup: str,
        include_count: Optional[bool] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Disable an existing User Group
        https://api.slack.com/methods/usergroups.disable
        &#34;&#34;&#34;
        kwargs.update({&#34;usergroup&#34;: usergroup, &#34;include_count&#34;: include_count, &#34;team_id&#34;: team_id})
        return self.api_call(&#34;usergroups.disable&#34;, params=kwargs)

    def usergroups_enable(
        self,
        *,
        usergroup: str,
        include_count: Optional[bool] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Enable a User Group
        https://api.slack.com/methods/usergroups.enable
        &#34;&#34;&#34;
        kwargs.update({&#34;usergroup&#34;: usergroup, &#34;include_count&#34;: include_count, &#34;team_id&#34;: team_id})
        return self.api_call(&#34;usergroups.enable&#34;, params=kwargs)

    def usergroups_list(
        self,
        *,
        include_count: Optional[bool] = None,
        include_disabled: Optional[bool] = None,
        include_users: Optional[bool] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List all User Groups for a team
        https://api.slack.com/methods/usergroups.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;include_count&#34;: include_count,
                &#34;include_disabled&#34;: include_disabled,
                &#34;include_users&#34;: include_users,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;usergroups.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def usergroups_update(
        self,
        *,
        usergroup: str,
        channels: Optional[Union[str, Sequence[str]]] = None,
        description: Optional[str] = None,
        handle: Optional[str] = None,
        include_count: Optional[bool] = None,
        name: Optional[str] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Update an existing User Group
        https://api.slack.com/methods/usergroups.update
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;usergroup&#34;: usergroup,
                &#34;description&#34;: description,
                &#34;handle&#34;: handle,
                &#34;include_count&#34;: include_count,
                &#34;name&#34;: name,
                &#34;team_id&#34;: team_id,
            }
        )
        if isinstance(channels, (list, Tuple)):
            kwargs.update({&#34;channels&#34;: &#34;,&#34;.join(channels)})
        else:
            kwargs.update({&#34;channels&#34;: channels})
        return self.api_call(&#34;usergroups.update&#34;, params=kwargs)

    def usergroups_users_list(
        self,
        *,
        usergroup: str,
        include_disabled: Optional[bool] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List all users in a User Group
        https://api.slack.com/methods/usergroups.users.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;usergroup&#34;: usergroup,
                &#34;include_disabled&#34;: include_disabled,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;usergroups.users.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def usergroups_users_update(
        self,
        *,
        usergroup: str,
        users: Union[str, Sequence[str]],
        include_count: Optional[bool] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Update the list of users for a User Group
        https://api.slack.com/methods/usergroups.users.update
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;usergroup&#34;: usergroup,
                &#34;include_count&#34;: include_count,
                &#34;team_id&#34;: team_id,
            }
        )
        if isinstance(users, (list, Tuple)):
            kwargs.update({&#34;users&#34;: &#34;,&#34;.join(users)})
        else:
            kwargs.update({&#34;users&#34;: users})
        return self.api_call(&#34;usergroups.users.update&#34;, params=kwargs)

    def users_conversations(
        self,
        *,
        cursor: Optional[str] = None,
        exclude_archived: Optional[bool] = None,
        limit: Optional[int] = None,
        team_id: Optional[str] = None,
        types: Optional[Union[str, Sequence[str]]] = None,
        user: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List conversations the calling user may access.
        https://api.slack.com/methods/users.conversations
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;cursor&#34;: cursor,
                &#34;exclude_archived&#34;: exclude_archived,
                &#34;limit&#34;: limit,
                &#34;team_id&#34;: team_id,
                &#34;user&#34;: user,
            }
        )
        if isinstance(types, (list, Tuple)):
            kwargs.update({&#34;types&#34;: &#34;,&#34;.join(types)})
        else:
            kwargs.update({&#34;types&#34;: types})
        return self.api_call(&#34;users.conversations&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def users_deletePhoto(
        self,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Delete the user profile photo
        https://api.slack.com/methods/users.deletePhoto
        &#34;&#34;&#34;
        return self.api_call(&#34;users.deletePhoto&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def users_getPresence(
        self,
        *,
        user: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Gets user presence information.
        https://api.slack.com/methods/users.getPresence
        &#34;&#34;&#34;
        kwargs.update({&#34;user&#34;: user})
        return self.api_call(&#34;users.getPresence&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def users_identity(
        self,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Get a user&#39;s identity.
        https://api.slack.com/methods/users.identity
        &#34;&#34;&#34;
        return self.api_call(&#34;users.identity&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def users_info(
        self,
        *,
        user: str,
        include_locale: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Gets information about a user.
        https://api.slack.com/methods/users.info
        &#34;&#34;&#34;
        kwargs.update({&#34;user&#34;: user, &#34;include_locale&#34;: include_locale})
        return self.api_call(&#34;users.info&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def users_list(
        self,
        *,
        cursor: Optional[str] = None,
        include_locale: Optional[bool] = None,
        limit: Optional[int] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lists all users in a Slack team.
        https://api.slack.com/methods/users.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;cursor&#34;: cursor,
                &#34;include_locale&#34;: include_locale,
                &#34;limit&#34;: limit,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;users.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def users_lookupByEmail(
        self,
        *,
        email: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Find a user with an email address.
        https://api.slack.com/methods/users.lookupByEmail
        &#34;&#34;&#34;
        kwargs.update({&#34;email&#34;: email})
        return self.api_call(&#34;users.lookupByEmail&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def users_setPhoto(
        self,
        *,
        image: Union[str, IOBase],
        crop_w: Optional[Union[int, str]] = None,
        crop_x: Optional[Union[int, str]] = None,
        crop_y: Optional[Union[int, str]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Set the user profile photo
        https://api.slack.com/methods/users.setPhoto
        &#34;&#34;&#34;
        kwargs.update({&#34;crop_w&#34;: crop_w, &#34;crop_x&#34;: crop_x, &#34;crop_y&#34;: crop_y})
        return self.api_call(&#34;users.setPhoto&#34;, files={&#34;image&#34;: image}, data=kwargs)

    def users_setPresence(
        self,
        *,
        presence: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Manually sets user presence.
        https://api.slack.com/methods/users.setPresence
        &#34;&#34;&#34;
        kwargs.update({&#34;presence&#34;: presence})
        return self.api_call(&#34;users.setPresence&#34;, params=kwargs)

    def users_profile_get(
        self,
        *,
        user: Optional[str] = None,
        include_labels: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieves a user&#39;s profile information.
        https://api.slack.com/methods/users.profile.get
        &#34;&#34;&#34;
        kwargs.update({&#34;user&#34;: user, &#34;include_labels&#34;: include_labels})
        return self.api_call(&#34;users.profile.get&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def users_profile_set(
        self,
        *,
        name: Optional[str] = None,
        value: Optional[str] = None,
        user: Optional[str] = None,
        profile: Optional[Dict] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Set the profile information for a user.
        https://api.slack.com/methods/users.profile.set
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;name&#34;: name,
                &#34;profile&#34;: profile,
                &#34;user&#34;: user,
                &#34;value&#34;: value,
            }
        )
        kwargs = _remove_none_values(kwargs)
        # NOTE: Intentionally using json for the &#34;profile&#34; parameter
        return self.api_call(&#34;users.profile.set&#34;, json=kwargs)

    def views_open(
        self,
        *,
        trigger_id: str,
        view: Union[dict, View],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Open a view for a user.
        https://api.slack.com/methods/views.open
        See https://api.slack.com/block-kit/surfaces/modals for details.
        &#34;&#34;&#34;
        kwargs.update({&#34;trigger_id&#34;: trigger_id})
        if isinstance(view, View):
            kwargs.update({&#34;view&#34;: view.to_dict()})
        else:
            kwargs.update({&#34;view&#34;: view})
        kwargs = _remove_none_values(kwargs)
        # NOTE: Intentionally using json for the &#34;view&#34; parameter
        return self.api_call(&#34;views.open&#34;, json=kwargs)

    def views_push(
        self,
        *,
        trigger_id: str,
        view: Union[dict, View],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Push a view onto the stack of a root view.
        Push a new view onto the existing view stack by passing a view
        payload and a valid trigger_id generated from an interaction
        within the existing modal.
        Read the modals documentation (https://api.slack.com/block-kit/surfaces/modals)
        to learn more about the lifecycle and intricacies of views.
        https://api.slack.com/methods/views.push
        &#34;&#34;&#34;
        kwargs.update({&#34;trigger_id&#34;: trigger_id})
        if isinstance(view, View):
            kwargs.update({&#34;view&#34;: view.to_dict()})
        else:
            kwargs.update({&#34;view&#34;: view})
        kwargs = _remove_none_values(kwargs)
        # NOTE: Intentionally using json for the &#34;view&#34; parameter
        return self.api_call(&#34;views.push&#34;, json=kwargs)

    def views_update(
        self,
        *,
        view: Union[dict, View],
        external_id: Optional[str] = None,
        view_id: Optional[str] = None,
        hash: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Update an existing view.
        Update a view by passing a new view definition along with the
        view_id returned in views.open or the external_id.
        See the modals documentation (https://api.slack.com/block-kit/surfaces/modals#updating_views)
        to learn more about updating views and avoiding race conditions with the hash argument.
        https://api.slack.com/methods/views.update
        &#34;&#34;&#34;
        if isinstance(view, View):
            kwargs.update({&#34;view&#34;: view.to_dict()})
        else:
            kwargs.update({&#34;view&#34;: view})
        if external_id:
            kwargs.update({&#34;external_id&#34;: external_id})
        elif view_id:
            kwargs.update({&#34;view_id&#34;: view_id})
        else:
            raise e.SlackRequestError(&#34;Either view_id or external_id is required.&#34;)
        kwargs.update({&#34;hash&#34;: hash})
        kwargs = _remove_none_values(kwargs)
        # NOTE: Intentionally using json for the &#34;view&#34; parameter
        return self.api_call(&#34;views.update&#34;, json=kwargs)

    def views_publish(
        self,
        *,
        user_id: str,
        view: Union[dict, View],
        hash: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Publish a static view for a User.
        Create or update the view that comprises an
        app&#39;s Home tab (https://api.slack.com/surfaces/tabs)
        https://api.slack.com/methods/views.publish
        &#34;&#34;&#34;
        kwargs.update({&#34;user_id&#34;: user_id, &#34;hash&#34;: hash})
        if isinstance(view, View):
            kwargs.update({&#34;view&#34;: view.to_dict()})
        else:
            kwargs.update({&#34;view&#34;: view})
        kwargs = _remove_none_values(kwargs)
        # NOTE: Intentionally using json for the &#34;view&#34; parameter
        return self.api_call(&#34;views.publish&#34;, json=kwargs)

    def workflows_stepCompleted(
        self,
        *,
        workflow_step_execute_id: str,
        outputs: Optional[dict] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Indicate a successful outcome of a workflow step&#39;s execution.
        https://api.slack.com/methods/workflows.stepCompleted
        &#34;&#34;&#34;
        kwargs.update({&#34;workflow_step_execute_id&#34;: workflow_step_execute_id})
        if outputs is not None:
            kwargs.update({&#34;outputs&#34;: outputs})
        kwargs = _remove_none_values(kwargs)
        # NOTE: Intentionally using json for the &#34;outputs&#34; parameter
        return self.api_call(&#34;workflows.stepCompleted&#34;, json=kwargs)

    def workflows_stepFailed(
        self,
        *,
        workflow_step_execute_id: str,
        error: Dict[str, str],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Indicate an unsuccessful outcome of a workflow step&#39;s execution.
        https://api.slack.com/methods/workflows.stepFailed
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;workflow_step_execute_id&#34;: workflow_step_execute_id,
                &#34;error&#34;: error,
            }
        )
        kwargs = _remove_none_values(kwargs)
        # NOTE: Intentionally using json for the &#34;error&#34; parameter
        return self.api_call(&#34;workflows.stepFailed&#34;, json=kwargs)

    def workflows_updateStep(
        self,
        *,
        workflow_step_edit_id: str,
        inputs: Optional[Dict[str, Any]] = None,
        outputs: Optional[List[Dict[str, str]]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Update the configuration for a workflow extension step.
        https://api.slack.com/methods/workflows.updateStep
        &#34;&#34;&#34;
        kwargs.update({&#34;workflow_step_edit_id&#34;: workflow_step_edit_id})
        if inputs is not None:
            kwargs.update({&#34;inputs&#34;: inputs})
        if outputs is not None:
            kwargs.update({&#34;outputs&#34;: outputs})
        kwargs = _remove_none_values(kwargs)
        # NOTE: Intentionally using json for the &#34;inputs&#34; / &#34;outputs&#34; parameters
        return self.api_call(&#34;workflows.updateStep&#34;, json=kwargs)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient"><code class="flex name class">
<span>class <span class="ident">LegacyWebClient</span></span>
<span>(</span><span>token: Optional[str] = None, base_url: str = 'https://www.slack.com/api/', timeout: int = 30, loop: Optional[asyncio.events.AbstractEventLoop] = None, ssl: Optional[ssl.SSLContext] = None, proxy: Optional[str] = None, run_async: bool = False, use_sync_aiohttp: bool = False, session: Optional[aiohttp.client.ClientSession] = None, headers: Optional[dict] = None, user_agent_prefix: Optional[str] = None, user_agent_suffix: Optional[str] = None, team_id: Optional[str] = None, logger: Optional[logging.Logger] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A WebClient allows apps to communicate with the Slack Platform's Web API.</p>
<p><a href="https://api.slack.com/methods">https://api.slack.com/methods</a></p>
<p>The Slack Web API is an interface for querying information from
and enacting change in a Slack workspace.</p>
<p>This client handles constructing and sending HTTP requests to Slack
as well as parsing any responses received into a <code>SlackResponse</code>.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>token</code></strong> :&ensp;<code>str</code></dt>
<dd>A string specifying an <code>xoxp-*</code> or <code>xoxb-*</code> token.</dd>
<dt><strong><code>base_url</code></strong> :&ensp;<code>str</code></dt>
<dd>A string representing the Slack API base URL.
Default is <code>'https://www.slack.com/api/'</code></dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>The maximum number of seconds the client will wait
to connect and receive a response from Slack.
Default is 30 seconds.</dd>
<dt><strong><code>ssl</code></strong> :&ensp;<code>SSLContext</code></dt>
<dd>An <a href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext"><code>ssl.SSLContext</code></a> instance, helpful for specifying
your own custom certificate chain.</dd>
<dt><strong><code>proxy</code></strong> :&ensp;<code>str</code></dt>
<dd>String representing a fully-qualified URL to a proxy through
which to route all requests to the Slack API. Even if this parameter
is not specified, if any of the following environment variables are
present, they will be loaded into this parameter: <code>HTTPS_PROXY</code>,
<code>https_proxy</code>, <code>HTTP_PROXY</code> or <code>http_proxy</code>.</dd>
<dt><strong><code>headers</code></strong> :&ensp;<code>dict</code></dt>
<dd>Additional request headers to attach to all requests.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p><code>api_call</code>: Constructs a request and executes the API call to Slack.</p>
<p>Example of recommended usage:</p>
<pre><code class="language-python">    import os
    from slack_sdk.web.legacy_client import LegacyWebClient

    client = LegacyWebClient(token=os.environ['SLACK_API_TOKEN'])
    response = client.chat_postMessage(
        channel='#random',
        text=&quot;Hello world!&quot;)
    assert response[&quot;ok&quot;]
    assert response[&quot;message&quot;][&quot;text&quot;] == &quot;Hello world!&quot;
</code></pre>
<p>Example manually creating an API request:</p>
<pre><code class="language-python">    import os
    from slack_sdk.web.legacy_client import LegacyWebClient

    client = LegacyWebClient(token=os.environ['SLACK_API_TOKEN'])
    response = client.api_call(
        api_method='chat.postMessage',
        json={'channel': '#random','text': &quot;Hello world!&quot;}
    )
    assert response[&quot;ok&quot;]
    assert response[&quot;message&quot;][&quot;text&quot;] == &quot;Hello world!&quot;
</code></pre>
<h2 id="note">Note</h2>
<p>Any attributes or methods prefixed with _underscores are
intended to be "private" internal use only. They may be changed or
removed at anytime.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LegacyWebClient(LegacyBaseClient):
    &#34;&#34;&#34;A WebClient allows apps to communicate with the Slack Platform&#39;s Web API.

    https://api.slack.com/methods

    The Slack Web API is an interface for querying information from
    and enacting change in a Slack workspace.

    This client handles constructing and sending HTTP requests to Slack
    as well as parsing any responses received into a `SlackResponse`.

    Attributes:
        token (str): A string specifying an `xoxp-*` or `xoxb-*` token.
        base_url (str): A string representing the Slack API base URL.
            Default is `&#39;https://www.slack.com/api/&#39;`
        timeout (int): The maximum number of seconds the client will wait
            to connect and receive a response from Slack.
            Default is 30 seconds.
        ssl (SSLContext): An [`ssl.SSLContext`][1] instance, helpful for specifying
            your own custom certificate chain.
        proxy (str): String representing a fully-qualified URL to a proxy through
            which to route all requests to the Slack API. Even if this parameter
            is not specified, if any of the following environment variables are
            present, they will be loaded into this parameter: `HTTPS_PROXY`,
            `https_proxy`, `HTTP_PROXY` or `http_proxy`.
        headers (dict): Additional request headers to attach to all requests.

    Methods:
        `api_call`: Constructs a request and executes the API call to Slack.

    Example of recommended usage:
    ```python
        import os
        from slack_sdk.web.legacy_client import LegacyWebClient

        client = LegacyWebClient(token=os.environ[&#39;SLACK_API_TOKEN&#39;])
        response = client.chat_postMessage(
            channel=&#39;#random&#39;,
            text=&#34;Hello world!&#34;)
        assert response[&#34;ok&#34;]
        assert response[&#34;message&#34;][&#34;text&#34;] == &#34;Hello world!&#34;
    ```

    Example manually creating an API request:
    ```python
        import os
        from slack_sdk.web.legacy_client import LegacyWebClient

        client = LegacyWebClient(token=os.environ[&#39;SLACK_API_TOKEN&#39;])
        response = client.api_call(
            api_method=&#39;chat.postMessage&#39;,
            json={&#39;channel&#39;: &#39;#random&#39;,&#39;text&#39;: &#34;Hello world!&#34;}
        )
        assert response[&#34;ok&#34;]
        assert response[&#34;message&#34;][&#34;text&#34;] == &#34;Hello world!&#34;
    ```

    Note:
        Any attributes or methods prefixed with _underscores are
        intended to be &#34;private&#34; internal use only. They may be changed or
        removed at anytime.

    [1]: https://docs.python.org/3/library/ssl.html#ssl.SSLContext
    &#34;&#34;&#34;

    def admin_analytics_getFile(
        self,
        *,
        type: str,
        date: Optional[str] = None,
        metadata_only: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieve analytics data for a given date, presented as a compressed JSON file
        https://api.slack.com/methods/admin.analytics.getFile
        &#34;&#34;&#34;
        kwargs.update({&#34;type&#34;: type})
        if date is not None:
            kwargs.update({&#34;date&#34;: date})
        if metadata_only is not None:
            kwargs.update({&#34;metadata_only&#34;: metadata_only})
        return self.api_call(&#34;admin.analytics.getFile&#34;, params=kwargs)

    def admin_apps_approve(
        self,
        *,
        app_id: Optional[str] = None,
        request_id: Optional[str] = None,
        enterprise_id: Optional[str] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Approve an app for installation on a workspace.
        Either app_id or request_id is required.
        These IDs can be obtained either directly via the app_requested event,
        or by the admin.apps.requests.list method.
        https://api.slack.com/methods/admin.apps.approve
        &#34;&#34;&#34;
        if app_id:
            kwargs.update({&#34;app_id&#34;: app_id})
        elif request_id:
            kwargs.update({&#34;request_id&#34;: request_id})
        else:
            raise e.SlackRequestError(&#34;The app_id or request_id argument must be specified.&#34;)

        kwargs.update(
            {
                &#34;enterprise_id&#34;: enterprise_id,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;admin.apps.approve&#34;, params=kwargs)

    def admin_apps_approved_list(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        enterprise_id: Optional[str] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List approved apps for an org or workspace.
        https://api.slack.com/methods/admin.apps.approved.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
                &#34;enterprise_id&#34;: enterprise_id,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;admin.apps.approved.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def admin_apps_clearResolution(
        self,
        *,
        app_id: str,
        enterprise_id: Optional[str] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Clear an app resolution
        https://api.slack.com/methods/admin.apps.clearResolution
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;app_id&#34;: app_id,
                &#34;enterprise_id&#34;: enterprise_id,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;admin.apps.clearResolution&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def admin_apps_requests_cancel(
        self,
        *,
        request_id: str,
        enterprise_id: Optional[str] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List app requests for a team/workspace.
        https://api.slack.com/methods/admin.apps.requests.cancel
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;request_id&#34;: request_id,
                &#34;enterprise_id&#34;: enterprise_id,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;admin.apps.requests.cancel&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def admin_apps_requests_list(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List app requests for a team/workspace.
        https://api.slack.com/methods/admin.apps.requests.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;admin.apps.requests.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def admin_apps_restrict(
        self,
        *,
        app_id: Optional[str] = None,
        request_id: Optional[str] = None,
        enterprise_id: Optional[str] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Restrict an app for installation on a workspace.
        Exactly one of the team_id or enterprise_id arguments is required, not both.
        Either app_id or request_id is required. These IDs can be obtained either directly
        via the app_requested event, or by the admin.apps.requests.list method.
        https://api.slack.com/methods/admin.apps.restrict
        &#34;&#34;&#34;
        if app_id:
            kwargs.update({&#34;app_id&#34;: app_id})
        elif request_id:
            kwargs.update({&#34;request_id&#34;: request_id})
        else:
            raise e.SlackRequestError(&#34;The app_id or request_id argument must be specified.&#34;)

        kwargs.update(
            {
                &#34;enterprise_id&#34;: enterprise_id,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;admin.apps.restrict&#34;, params=kwargs)

    def admin_apps_restricted_list(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        enterprise_id: Optional[str] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List restricted apps for an org or workspace.
        https://api.slack.com/methods/admin.apps.restricted.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
                &#34;enterprise_id&#34;: enterprise_id,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;admin.apps.restricted.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def admin_apps_uninstall(
        self,
        *,
        app_id: str,
        enterprise_id: Optional[str] = None,
        team_ids: Optional[Union[str, Sequence[str]]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Uninstall an app from one or many workspaces, or an entire enterprise organization.
        With an org-level token, enterprise_id or team_ids is required.
        https://api.slack.com/methods/admin.apps.uninstall
        &#34;&#34;&#34;
        kwargs.update({&#34;app_id&#34;: app_id})
        if enterprise_id is not None:
            kwargs.update({&#34;enterprise_id&#34;: enterprise_id})
        if team_ids is not None:
            if isinstance(team_ids, (list, Tuple)):
                kwargs.update({&#34;team_ids&#34;: &#34;,&#34;.join(team_ids)})
            else:
                kwargs.update({&#34;team_ids&#34;: team_ids})
        return self.api_call(&#34;admin.apps.uninstall&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def admin_apps_activities_list(
        self,
        *,
        app_id: Optional[str] = None,
        component_id: Optional[str] = None,
        component_type: Optional[str] = None,
        log_event_type: Optional[str] = None,
        max_date_created: Optional[int] = None,
        min_date_created: Optional[int] = None,
        min_log_level: Optional[str] = None,
        sort_direction: Optional[str] = None,
        source: Optional[str] = None,
        team_id: Optional[str] = None,
        trace_id: Optional[str] = None,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Get logs for a specified team/org
        https://api.slack.com/methods/admin.apps.activities.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;app_id&#34;: app_id,
                &#34;component_id&#34;: component_id,
                &#34;component_type&#34;: component_type,
                &#34;log_event_type&#34;: log_event_type,
                &#34;max_date_created&#34;: max_date_created,
                &#34;min_date_created&#34;: min_date_created,
                &#34;min_log_level&#34;: min_log_level,
                &#34;sort_direction&#34;: sort_direction,
                &#34;source&#34;: source,
                &#34;team_id&#34;: team_id,
                &#34;trace_id&#34;: trace_id,
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
            }
        )
        return self.api_call(&#34;admin.apps.activities.list&#34;, params=kwargs)

    def admin_apps_config_lookup(
        self,
        *,
        app_ids: Union[str, Sequence[str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Look up the app config for connectors by their IDs
        https://api.slack.com/methods/admin.apps.config.lookup
        &#34;&#34;&#34;
        if isinstance(app_ids, (list, Tuple)):
            kwargs.update({&#34;app_ids&#34;: &#34;,&#34;.join(app_ids)})
        else:
            kwargs.update({&#34;app_ids&#34;: app_ids})
        return self.api_call(&#34;admin.apps.config.lookup&#34;, params=kwargs)

    def admin_apps_config_set(
        self,
        *,
        app_id: str,
        domain_restrictions: Optional[Dict[str, Any]] = None,
        workflow_auth_strategy: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Set the app config for a connector
        https://api.slack.com/methods/admin.apps.config.set
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;app_id&#34;: app_id,
                &#34;workflow_auth_strategy&#34;: workflow_auth_strategy,
            }
        )
        if domain_restrictions is not None:
            kwargs.update({&#34;domain_restrictions&#34;: json.dumps(domain_restrictions)})
        return self.api_call(&#34;admin.apps.config.set&#34;, params=kwargs)

    def admin_auth_policy_getEntities(
        self,
        *,
        policy_name: str,
        cursor: Optional[str] = None,
        entity_type: Optional[str] = None,
        limit: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Fetch all the entities assigned to a particular authentication policy by name.
        https://api.slack.com/methods/admin.auth.policy.getEntities
        &#34;&#34;&#34;
        kwargs.update({&#34;policy_name&#34;: policy_name})
        if cursor is not None:
            kwargs.update({&#34;cursor&#34;: cursor})
        if entity_type is not None:
            kwargs.update({&#34;entity_type&#34;: entity_type})
        if limit is not None:
            kwargs.update({&#34;limit&#34;: limit})
        return self.api_call(&#34;admin.auth.policy.getEntities&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def admin_auth_policy_assignEntities(
        self,
        *,
        entity_ids: Union[str, Sequence[str]],
        policy_name: str,
        entity_type: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Assign entities to a particular authentication policy.
        https://api.slack.com/methods/admin.auth.policy.assignEntities
        &#34;&#34;&#34;
        if isinstance(entity_ids, (list, Tuple)):
            kwargs.update({&#34;entity_ids&#34;: &#34;,&#34;.join(entity_ids)})
        else:
            kwargs.update({&#34;entity_ids&#34;: entity_ids})
        kwargs.update({&#34;policy_name&#34;: policy_name})
        kwargs.update({&#34;entity_type&#34;: entity_type})
        return self.api_call(&#34;admin.auth.policy.assignEntities&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def admin_auth_policy_removeEntities(
        self,
        *,
        entity_ids: Union[str, Sequence[str]],
        policy_name: str,
        entity_type: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Remove specified entities from a specified authentication policy.
        https://api.slack.com/methods/admin.auth.policy.removeEntities
        &#34;&#34;&#34;
        if isinstance(entity_ids, (list, Tuple)):
            kwargs.update({&#34;entity_ids&#34;: &#34;,&#34;.join(entity_ids)})
        else:
            kwargs.update({&#34;entity_ids&#34;: entity_ids})
        kwargs.update({&#34;policy_name&#34;: policy_name})
        kwargs.update({&#34;entity_type&#34;: entity_type})
        return self.api_call(&#34;admin.auth.policy.removeEntities&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def admin_barriers_create(
        self,
        *,
        barriered_from_usergroup_ids: Union[str, Sequence[str]],
        primary_usergroup_id: str,
        restricted_subjects: Union[str, Sequence[str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Create an Information Barrier
        https://api.slack.com/methods/admin.barriers.create
        &#34;&#34;&#34;
        kwargs.update({&#34;primary_usergroup_id&#34;: primary_usergroup_id})
        if isinstance(barriered_from_usergroup_ids, (list, Tuple)):
            kwargs.update({&#34;barriered_from_usergroup_ids&#34;: &#34;,&#34;.join(barriered_from_usergroup_ids)})
        else:
            kwargs.update({&#34;barriered_from_usergroup_ids&#34;: barriered_from_usergroup_ids})
        if isinstance(restricted_subjects, (list, Tuple)):
            kwargs.update({&#34;restricted_subjects&#34;: &#34;,&#34;.join(restricted_subjects)})
        else:
            kwargs.update({&#34;restricted_subjects&#34;: restricted_subjects})
        return self.api_call(&#34;admin.barriers.create&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def admin_barriers_delete(
        self,
        *,
        barrier_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Delete an existing Information Barrier
        https://api.slack.com/methods/admin.barriers.delete
        &#34;&#34;&#34;
        kwargs.update({&#34;barrier_id&#34;: barrier_id})
        return self.api_call(&#34;admin.barriers.delete&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def admin_barriers_update(
        self,
        *,
        barrier_id: str,
        barriered_from_usergroup_ids: Union[str, Sequence[str]],
        primary_usergroup_id: str,
        restricted_subjects: Union[str, Sequence[str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Update an existing Information Barrier
        https://api.slack.com/methods/admin.barriers.update
        &#34;&#34;&#34;
        kwargs.update({&#34;barrier_id&#34;: barrier_id, &#34;primary_usergroup_id&#34;: primary_usergroup_id})
        if isinstance(barriered_from_usergroup_ids, (list, Tuple)):
            kwargs.update({&#34;barriered_from_usergroup_ids&#34;: &#34;,&#34;.join(barriered_from_usergroup_ids)})
        else:
            kwargs.update({&#34;barriered_from_usergroup_ids&#34;: barriered_from_usergroup_ids})
        if isinstance(restricted_subjects, (list, Tuple)):
            kwargs.update({&#34;restricted_subjects&#34;: &#34;,&#34;.join(restricted_subjects)})
        else:
            kwargs.update({&#34;restricted_subjects&#34;: restricted_subjects})
        return self.api_call(&#34;admin.barriers.update&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def admin_barriers_list(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Get all Information Barriers for your organization
        https://api.slack.com/methods/admin.barriers.list&#34;&#34;&#34;
        kwargs.update(
            {
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
            }
        )
        return self.api_call(&#34;admin.barriers.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def admin_conversations_create(
        self,
        *,
        is_private: bool,
        name: str,
        description: Optional[str] = None,
        org_wide: Optional[bool] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Create a public or private channel-based conversation.
        https://api.slack.com/methods/admin.conversations.create
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;is_private&#34;: is_private,
                &#34;name&#34;: name,
                &#34;description&#34;: description,
                &#34;org_wide&#34;: org_wide,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;admin.conversations.create&#34;, params=kwargs)

    def admin_conversations_delete(
        self,
        *,
        channel_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Delete a public or private channel.
        https://api.slack.com/methods/admin.conversations.delete
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_id&#34;: channel_id})
        return self.api_call(&#34;admin.conversations.delete&#34;, params=kwargs)

    def admin_conversations_invite(
        self,
        *,
        channel_id: str,
        user_ids: Union[str, Sequence[str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Invite a user to a public or private channel.
        https://api.slack.com/methods/admin.conversations.invite
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_id&#34;: channel_id})
        if isinstance(user_ids, (list, Tuple)):
            kwargs.update({&#34;user_ids&#34;: &#34;,&#34;.join(user_ids)})
        else:
            kwargs.update({&#34;user_ids&#34;: user_ids})
        # NOTE: the endpoint is unable to handle Content-Type: application/json as of Sep 3, 2020.
        return self.api_call(&#34;admin.conversations.invite&#34;, params=kwargs)

    def admin_conversations_archive(
        self,
        *,
        channel_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Archive a public or private channel.
        https://api.slack.com/methods/admin.conversations.archive
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_id&#34;: channel_id})
        return self.api_call(&#34;admin.conversations.archive&#34;, params=kwargs)

    def admin_conversations_unarchive(
        self,
        *,
        channel_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Unarchive a public or private channel.
        https://api.slack.com/methods/admin.conversations.archive
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_id&#34;: channel_id})
        return self.api_call(&#34;admin.conversations.unarchive&#34;, params=kwargs)

    def admin_conversations_rename(
        self,
        *,
        channel_id: str,
        name: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Rename a public or private channel.
        https://api.slack.com/methods/admin.conversations.rename
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_id&#34;: channel_id, &#34;name&#34;: name})
        return self.api_call(&#34;admin.conversations.rename&#34;, params=kwargs)

    def admin_conversations_search(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        query: Optional[str] = None,
        search_channel_types: Optional[Union[str, Sequence[str]]] = None,
        sort: Optional[str] = None,
        sort_dir: Optional[str] = None,
        team_ids: Optional[Union[str, Sequence[str]]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Search for public or private channels in an Enterprise organization.
        https://api.slack.com/methods/admin.conversations.search
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
                &#34;query&#34;: query,
                &#34;sort&#34;: sort,
                &#34;sort_dir&#34;: sort_dir,
            }
        )

        if isinstance(search_channel_types, (list, Tuple)):
            kwargs.update({&#34;search_channel_types&#34;: &#34;,&#34;.join(search_channel_types)})
        else:
            kwargs.update({&#34;search_channel_types&#34;: search_channel_types})

        if isinstance(team_ids, (list, Tuple)):
            kwargs.update({&#34;team_ids&#34;: &#34;,&#34;.join(team_ids)})
        else:
            kwargs.update({&#34;team_ids&#34;: team_ids})

        return self.api_call(&#34;admin.conversations.search&#34;, params=kwargs)

    def admin_conversations_convertToPrivate(
        self,
        *,
        channel_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Convert a public channel to a private channel.
        https://api.slack.com/methods/admin.conversations.convertToPrivate
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_id&#34;: channel_id})
        return self.api_call(&#34;admin.conversations.convertToPrivate&#34;, params=kwargs)

    def admin_conversations_convertToPublic(
        self,
        *,
        channel_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Convert a privte channel to a public channel.
        https://api.slack.com/methods/admin.conversations.convertToPublic
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_id&#34;: channel_id})
        return self.api_call(&#34;admin.conversations.convertToPublic&#34;, params=kwargs)

    def admin_conversations_setConversationPrefs(
        self,
        *,
        channel_id: str,
        prefs: Union[str, Dict[str, str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Set the posting permissions for a public or private channel.
        https://api.slack.com/methods/admin.conversations.setConversationPrefs
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_id&#34;: channel_id})
        if isinstance(prefs, dict):
            kwargs.update({&#34;prefs&#34;: json.dumps(prefs)})
        else:
            kwargs.update({&#34;prefs&#34;: prefs})
        return self.api_call(&#34;admin.conversations.setConversationPrefs&#34;, params=kwargs)

    def admin_conversations_getConversationPrefs(
        self,
        *,
        channel_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Get conversation preferences for a public or private channel.
        https://api.slack.com/methods/admin.conversations.getConversationPrefs
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_id&#34;: channel_id})
        return self.api_call(&#34;admin.conversations.getConversationPrefs&#34;, params=kwargs)

    def admin_conversations_disconnectShared(
        self,
        *,
        channel_id: str,
        leaving_team_ids: Optional[Union[str, Sequence[str]]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Disconnect a connected channel from one or more workspaces.
        https://api.slack.com/methods/admin.conversations.disconnectShared
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_id&#34;: channel_id})
        if isinstance(leaving_team_ids, (list, Tuple)):
            kwargs.update({&#34;leaving_team_ids&#34;: &#34;,&#34;.join(leaving_team_ids)})
        else:
            kwargs.update({&#34;leaving_team_ids&#34;: leaving_team_ids})
        return self.api_call(&#34;admin.conversations.disconnectShared&#34;, params=kwargs)

    def admin_conversations_lookup(
        self,
        *,
        last_message_activity_before: int,
        team_ids: Union[str, Sequence[str]],
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        max_member_count: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Returns channels on the given team using the filters.
        https://api.slack.com/methods/admin.conversations.lookup
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;last_message_activity_before&#34;: last_message_activity_before,
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
                &#34;max_member_count&#34;: max_member_count,
            }
        )
        if isinstance(team_ids, (list, Tuple)):
            kwargs.update({&#34;team_ids&#34;: &#34;,&#34;.join(team_ids)})
        else:
            kwargs.update({&#34;team_ids&#34;: team_ids})
        return self.api_call(&#34;admin.conversations.lookup&#34;, params=kwargs)

    def admin_conversations_ekm_listOriginalConnectedChannelInfo(
        self,
        *,
        channel_ids: Optional[Union[str, Sequence[str]]] = None,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        team_ids: Optional[Union[str, Sequence[str]]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List all disconnected channels—i.e.,
        channels that were once connected to other workspaces and then disconnected—and
        the corresponding original channel IDs for key revocation with EKM.
        https://api.slack.com/methods/admin.conversations.ekm.listOriginalConnectedChannelInfo
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
            }
        )
        if isinstance(channel_ids, (list, Tuple)):
            kwargs.update({&#34;channel_ids&#34;: &#34;,&#34;.join(channel_ids)})
        else:
            kwargs.update({&#34;channel_ids&#34;: channel_ids})
        if isinstance(team_ids, (list, Tuple)):
            kwargs.update({&#34;team_ids&#34;: &#34;,&#34;.join(team_ids)})
        else:
            kwargs.update({&#34;team_ids&#34;: team_ids})
        return self.api_call(&#34;admin.conversations.ekm.listOriginalConnectedChannelInfo&#34;, params=kwargs)

    def admin_conversations_restrictAccess_addGroup(
        self,
        *,
        channel_id: str,
        group_id: str,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Add an allowlist of IDP groups for accessing a channel.
        https://api.slack.com/methods/admin.conversations.restrictAccess.addGroup
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel_id&#34;: channel_id,
                &#34;group_id&#34;: group_id,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(
            &#34;admin.conversations.restrictAccess.addGroup&#34;,
            http_verb=&#34;GET&#34;,
            params=kwargs,
        )

    def admin_conversations_restrictAccess_listGroups(
        self,
        *,
        channel_id: str,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List all IDP Groups linked to a channel.
        https://api.slack.com/methods/admin.conversations.restrictAccess.listGroups
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel_id&#34;: channel_id,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(
            &#34;admin.conversations.restrictAccess.listGroups&#34;,
            http_verb=&#34;GET&#34;,
            params=kwargs,
        )

    def admin_conversations_restrictAccess_removeGroup(
        self,
        *,
        channel_id: str,
        group_id: str,
        team_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Remove a linked IDP group linked from a private channel.
        https://api.slack.com/methods/admin.conversations.restrictAccess.removeGroup
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel_id&#34;: channel_id,
                &#34;group_id&#34;: group_id,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(
            &#34;admin.conversations.restrictAccess.removeGroup&#34;,
            http_verb=&#34;GET&#34;,
            params=kwargs,
        )

    def admin_conversations_setTeams(
        self,
        *,
        channel_id: str,
        org_channel: Optional[bool] = None,
        target_team_ids: Optional[Union[str, Sequence[str]]] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Set the workspaces in an Enterprise grid org that connect to a public or private channel.
        https://api.slack.com/methods/admin.conversations.setTeams
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel_id&#34;: channel_id,
                &#34;org_channel&#34;: org_channel,
                &#34;team_id&#34;: team_id,
            }
        )
        if isinstance(target_team_ids, (list, Tuple)):
            kwargs.update({&#34;target_team_ids&#34;: &#34;,&#34;.join(target_team_ids)})
        else:
            kwargs.update({&#34;target_team_ids&#34;: target_team_ids})
        return self.api_call(&#34;admin.conversations.setTeams&#34;, params=kwargs)

    def admin_conversations_getTeams(
        self,
        *,
        channel_id: str,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Set the workspaces in an Enterprise grid org that connect to a channel.
        https://api.slack.com/methods/admin.conversations.getTeams
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel_id&#34;: channel_id,
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
            }
        )
        return self.api_call(&#34;admin.conversations.getTeams&#34;, params=kwargs)

    def admin_conversations_getCustomRetention(
        self,
        *,
        channel_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Get a channel&#39;s retention policy
        https://api.slack.com/methods/admin.conversations.getCustomRetention
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_id&#34;: channel_id})
        return self.api_call(&#34;admin.conversations.getCustomRetention&#34;, params=kwargs)

    def admin_conversations_removeCustomRetention(
        self,
        *,
        channel_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Remove a channel&#39;s retention policy
        https://api.slack.com/methods/admin.conversations.removeCustomRetention
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_id&#34;: channel_id})
        return self.api_call(&#34;admin.conversations.removeCustomRetention&#34;, params=kwargs)

    def admin_conversations_setCustomRetention(
        self,
        *,
        channel_id: str,
        duration_days: int,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Set a channel&#39;s retention policy
        https://api.slack.com/methods/admin.conversations.setCustomRetention
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_id&#34;: channel_id, &#34;duration_days&#34;: duration_days})
        return self.api_call(&#34;admin.conversations.setCustomRetention&#34;, params=kwargs)

    def admin_conversations_bulkArchive(
        self,
        *,
        channel_ids: Union[Sequence[str], str],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Archive public or private channels in bulk.
        https://api.slack.com/methods/admin.conversations.bulkArchive
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_ids&#34;: &#34;,&#34;.join(channel_ids) if isinstance(channel_ids, (list, tuple)) else channel_ids})
        return self.api_call(&#34;admin.conversations.bulkArchive&#34;, params=kwargs)

    def admin_conversations_bulkDelete(
        self,
        *,
        channel_ids: Union[Sequence[str], str],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Delete public or private channels in bulk.
        https://slack.com/api/admin.conversations.bulkDelete
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_ids&#34;: &#34;,&#34;.join(channel_ids) if isinstance(channel_ids, (list, tuple)) else channel_ids})
        return self.api_call(&#34;admin.conversations.bulkDelete&#34;, params=kwargs)

    def admin_conversations_bulkMove(
        self,
        *,
        channel_ids: Union[Sequence[str], str],
        target_team_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Move public or private channels in bulk.
        https://api.slack.com/methods/admin.conversations.bulkMove
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;target_team_id&#34;: target_team_id,
                &#34;channel_ids&#34;: &#34;,&#34;.join(channel_ids) if isinstance(channel_ids, (list, tuple)) else channel_ids,
            }
        )
        return self.api_call(&#34;admin.conversations.bulkMove&#34;, params=kwargs)

    def admin_emoji_add(
        self,
        *,
        name: str,
        url: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Add an emoji.
        https://api.slack.com/methods/admin.emoji.add
        &#34;&#34;&#34;
        kwargs.update({&#34;name&#34;: name, &#34;url&#34;: url})
        return self.api_call(&#34;admin.emoji.add&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def admin_emoji_addAlias(
        self,
        *,
        alias_for: str,
        name: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Add an emoji alias.
        https://api.slack.com/methods/admin.emoji.addAlias
        &#34;&#34;&#34;
        kwargs.update({&#34;alias_for&#34;: alias_for, &#34;name&#34;: name})
        return self.api_call(&#34;admin.emoji.addAlias&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def admin_emoji_list(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List emoji for an Enterprise Grid organization.
        https://api.slack.com/methods/admin.emoji.list
        &#34;&#34;&#34;
        kwargs.update({&#34;cursor&#34;: cursor, &#34;limit&#34;: limit})
        return self.api_call(&#34;admin.emoji.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def admin_emoji_remove(
        self,
        *,
        name: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Remove an emoji across an Enterprise Grid organization.
        https://api.slack.com/methods/admin.emoji.remove
        &#34;&#34;&#34;
        kwargs.update({&#34;name&#34;: name})
        return self.api_call(&#34;admin.emoji.remove&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def admin_emoji_rename(
        self,
        *,
        name: str,
        new_name: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Rename an emoji.
        https://api.slack.com/methods/admin.emoji.rename
        &#34;&#34;&#34;
        kwargs.update({&#34;name&#34;: name, &#34;new_name&#34;: new_name})
        return self.api_call(&#34;admin.emoji.rename&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def admin_functions_list(
        self,
        *,
        app_ids: Union[str, Sequence[str]],
        team_id: Optional[str] = None,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Look up functions by a set of apps
        https://api.slack.com/methods/admin.functions.list
        &#34;&#34;&#34;
        if isinstance(app_ids, (list, Tuple)):
            kwargs.update({&#34;app_ids&#34;: &#34;,&#34;.join(app_ids)})
        else:
            kwargs.update({&#34;app_ids&#34;: app_ids})
        kwargs.update(
            {
                &#34;team_id&#34;: team_id,
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
            }
        )
        return self.api_call(&#34;admin.functions.list&#34;, params=kwargs)

    def admin_functions_permissions_lookup(
        self,
        *,
        function_ids: Union[str, Sequence[str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lookup the visibility of multiple Slack functions
        and include the users if it is limited to particular named entities.
        https://api.slack.com/methods/admin.functions.permissions.lookup
        &#34;&#34;&#34;
        if isinstance(function_ids, (list, Tuple)):
            kwargs.update({&#34;function_ids&#34;: &#34;,&#34;.join(function_ids)})
        else:
            kwargs.update({&#34;function_ids&#34;: function_ids})
        return self.api_call(&#34;admin.functions.permissions.lookup&#34;, params=kwargs)

    def admin_functions_permissions_set(
        self,
        *,
        function_id: str,
        visibility: str,
        user_ids: Optional[Union[str, Sequence[str]]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Set the visibility of a Slack function
        and define the users or workspaces if it is set to named_entities
        https://api.slack.com/methods/admin.functions.permissions.set
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;function_id&#34;: function_id,
                &#34;visibility&#34;: visibility,
            }
        )
        if user_ids is not None:
            if isinstance(user_ids, (list, Tuple)):
                kwargs.update({&#34;user_ids&#34;: &#34;,&#34;.join(user_ids)})
            else:
                kwargs.update({&#34;user_ids&#34;: user_ids})
        return self.api_call(&#34;admin.functions.permissions.set&#34;, params=kwargs)

    def admin_roles_addAssignments(
        self,
        *,
        role_id: str,
        entity_ids: Union[str, Sequence[str]],
        user_ids: Union[str, Sequence[str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Adds members to the specified role with the specified scopes
        https://api.slack.com/methods/admin.roles.addAssignments
        &#34;&#34;&#34;
        kwargs.update({&#34;role_id&#34;: role_id})
        if isinstance(entity_ids, (list, Tuple)):
            kwargs.update({&#34;entity_ids&#34;: &#34;,&#34;.join(entity_ids)})
        else:
            kwargs.update({&#34;entity_ids&#34;: entity_ids})
        if isinstance(user_ids, (list, Tuple)):
            kwargs.update({&#34;user_ids&#34;: &#34;,&#34;.join(user_ids)})
        else:
            kwargs.update({&#34;user_ids&#34;: user_ids})
        return self.api_call(&#34;admin.roles.addAssignments&#34;, params=kwargs)

    def admin_roles_listAssignments(
        self,
        *,
        role_ids: Optional[Union[str, Sequence[str]]] = None,
        entity_ids: Optional[Union[str, Sequence[str]]] = None,
        cursor: Optional[str] = None,
        limit: Optional[Union[str, int]] = None,
        sort_dir: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lists assignments for all roles across entities.
            Options to scope results by any combination of roles or entities
        https://api.slack.com/methods/admin.roles.listAssignments
        &#34;&#34;&#34;
        kwargs.update({&#34;cursor&#34;: cursor, &#34;limit&#34;: limit, &#34;sort_dir&#34;: sort_dir})
        if isinstance(entity_ids, (list, Tuple)):
            kwargs.update({&#34;entity_ids&#34;: &#34;,&#34;.join(entity_ids)})
        else:
            kwargs.update({&#34;entity_ids&#34;: entity_ids})
        if isinstance(role_ids, (list, Tuple)):
            kwargs.update({&#34;role_ids&#34;: &#34;,&#34;.join(role_ids)})
        else:
            kwargs.update({&#34;role_ids&#34;: role_ids})
        return self.api_call(&#34;admin.roles.listAssignments&#34;, params=kwargs)

    def admin_roles_removeAssignments(
        self,
        *,
        role_id: str,
        entity_ids: Union[str, Sequence[str]],
        user_ids: Union[str, Sequence[str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Removes a set of users from a role for the given scopes and entities
        https://api.slack.com/methods/admin.roles.removeAssignments
        &#34;&#34;&#34;
        kwargs.update({&#34;role_id&#34;: role_id})
        if isinstance(entity_ids, (list, Tuple)):
            kwargs.update({&#34;entity_ids&#34;: &#34;,&#34;.join(entity_ids)})
        else:
            kwargs.update({&#34;entity_ids&#34;: entity_ids})
        if isinstance(user_ids, (list, Tuple)):
            kwargs.update({&#34;user_ids&#34;: &#34;,&#34;.join(user_ids)})
        else:
            kwargs.update({&#34;user_ids&#34;: user_ids})
        return self.api_call(&#34;admin.roles.removeAssignments&#34;, params=kwargs)

    def admin_users_session_reset(
        self,
        *,
        user_id: str,
        mobile_only: Optional[bool] = None,
        web_only: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Wipes all valid sessions on all devices for a given user.
        https://api.slack.com/methods/admin.users.session.reset
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;user_id&#34;: user_id,
                &#34;mobile_only&#34;: mobile_only,
                &#34;web_only&#34;: web_only,
            }
        )
        return self.api_call(&#34;admin.users.session.reset&#34;, params=kwargs)

    def admin_users_session_resetBulk(
        self,
        *,
        user_ids: Union[str, Sequence[str]],
        mobile_only: Optional[bool] = None,
        web_only: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Enqueues an asynchronous job to wipe all valid sessions on all devices for a given list of users
        https://api.slack.com/methods/admin.users.session.resetBulk
        &#34;&#34;&#34;
        if isinstance(user_ids, (list, Tuple)):
            kwargs.update({&#34;user_ids&#34;: &#34;,&#34;.join(user_ids)})
        else:
            kwargs.update({&#34;user_ids&#34;: user_ids})
        kwargs.update(
            {
                &#34;mobile_only&#34;: mobile_only,
                &#34;web_only&#34;: web_only,
            }
        )
        return self.api_call(&#34;admin.users.session.resetBulk&#34;, params=kwargs)

    def admin_users_session_invalidate(
        self,
        *,
        session_id: str,
        team_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Invalidate a single session for a user by session_id.
        https://api.slack.com/methods/admin.users.session.invalidate
        &#34;&#34;&#34;
        kwargs.update({&#34;session_id&#34;: session_id, &#34;team_id&#34;: team_id})
        return self.api_call(&#34;admin.users.session.invalidate&#34;, params=kwargs)

    def admin_users_session_list(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        team_id: Optional[str] = None,
        user_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lists all active user sessions for an organization
        https://api.slack.com/methods/admin.users.session.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
                &#34;team_id&#34;: team_id,
                &#34;user_id&#34;: user_id,
            }
        )
        return self.api_call(&#34;admin.users.session.list&#34;, params=kwargs)

    def admin_teams_settings_setDefaultChannels(
        self,
        *,
        team_id: str,
        channel_ids: Union[str, Sequence[str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Set the default channels of a workspace.
        https://api.slack.com/methods/admin.teams.settings.setDefaultChannels
        &#34;&#34;&#34;
        kwargs.update({&#34;team_id&#34;: team_id})
        if isinstance(channel_ids, (list, Tuple)):
            kwargs.update({&#34;channel_ids&#34;: &#34;,&#34;.join(channel_ids)})
        else:
            kwargs.update({&#34;channel_ids&#34;: channel_ids})
        return self.api_call(&#34;admin.teams.settings.setDefaultChannels&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def admin_users_session_getSettings(
        self,
        *,
        user_ids: Union[str, Sequence[str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Get user-specific session settings—the session duration
        and what happens when the client closes—given a list of users.
        https://api.slack.com/methods/admin.users.session.getSettings
        &#34;&#34;&#34;
        if isinstance(user_ids, (list, Tuple)):
            kwargs.update({&#34;user_ids&#34;: &#34;,&#34;.join(user_ids)})
        else:
            kwargs.update({&#34;user_ids&#34;: user_ids})
        return self.api_call(&#34;admin.users.session.getSettings&#34;, params=kwargs)

    def admin_users_session_setSettings(
        self,
        *,
        user_ids: Union[str, Sequence[str]],
        desktop_app_browser_quit: Optional[bool] = None,
        duration: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Configure the user-level session settings—the session duration
        and what happens when the client closes—for one or more users.
        https://api.slack.com/methods/admin.users.session.setSettings
        &#34;&#34;&#34;
        if isinstance(user_ids, (list, Tuple)):
            kwargs.update({&#34;user_ids&#34;: &#34;,&#34;.join(user_ids)})
        else:
            kwargs.update({&#34;user_ids&#34;: user_ids})
        kwargs.update(
            {
                &#34;desktop_app_browser_quit&#34;: desktop_app_browser_quit,
                &#34;duration&#34;: duration,
            }
        )
        return self.api_call(&#34;admin.users.session.setSettings&#34;, params=kwargs)

    def admin_users_session_clearSettings(
        self,
        *,
        user_ids: Union[str, Sequence[str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Clear user-specific session settings—the session duration
        and what happens when the client closes—for a list of users.
        https://api.slack.com/methods/admin.users.session.clearSettings
        &#34;&#34;&#34;
        if isinstance(user_ids, (list, Tuple)):
            kwargs.update({&#34;user_ids&#34;: &#34;,&#34;.join(user_ids)})
        else:
            kwargs.update({&#34;user_ids&#34;: user_ids})
        return self.api_call(&#34;admin.users.session.clearSettings&#34;, params=kwargs)

    def admin_users_unsupportedVersions_export(
        self,
        *,
        date_end_of_support: Optional[Union[str, int]] = None,
        date_sessions_started: Optional[Union[str, int]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Ask Slackbot to send you an export listing all workspace members using unsupported software,
        presented as a zipped CSV file.
        https://api.slack.com/methods/admin.users.unsupportedVersions.export
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;date_end_of_support&#34;: date_end_of_support,
                &#34;date_sessions_started&#34;: date_sessions_started,
            }
        )
        return self.api_call(&#34;admin.users.unsupportedVersions.export&#34;, params=kwargs)

    def admin_inviteRequests_approve(
        self,
        *,
        invite_request_id: str,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Approve a workspace invite request.
        https://api.slack.com/methods/admin.inviteRequests.approve
        &#34;&#34;&#34;
        kwargs.update({&#34;invite_request_id&#34;: invite_request_id, &#34;team_id&#34;: team_id})
        return self.api_call(&#34;admin.inviteRequests.approve&#34;, params=kwargs)

    def admin_inviteRequests_approved_list(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List all approved workspace invite requests.
        https://api.slack.com/methods/admin.inviteRequests.approved.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;admin.inviteRequests.approved.list&#34;, params=kwargs)

    def admin_inviteRequests_denied_list(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List all denied workspace invite requests.
        https://api.slack.com/methods/admin.inviteRequests.denied.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;admin.inviteRequests.denied.list&#34;, params=kwargs)

    def admin_inviteRequests_deny(
        self,
        *,
        invite_request_id: str,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Deny a workspace invite request.
        https://api.slack.com/methods/admin.inviteRequests.deny
        &#34;&#34;&#34;
        kwargs.update({&#34;invite_request_id&#34;: invite_request_id, &#34;team_id&#34;: team_id})
        return self.api_call(&#34;admin.inviteRequests.deny&#34;, params=kwargs)

    def admin_inviteRequests_list(
        self,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List all pending workspace invite requests.&#34;&#34;&#34;
        return self.api_call(&#34;admin.inviteRequests.list&#34;, params=kwargs)

    def admin_teams_admins_list(
        self,
        *,
        team_id: str,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List all of the admins on a given workspace.
        https://api.slack.com/methods/admin.inviteRequests.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;admin.teams.admins.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def admin_teams_create(
        self,
        *,
        team_domain: str,
        team_name: str,
        team_description: Optional[str] = None,
        team_discoverability: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Create an Enterprise team.
        https://api.slack.com/methods/admin.teams.create
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;team_domain&#34;: team_domain,
                &#34;team_name&#34;: team_name,
                &#34;team_description&#34;: team_description,
                &#34;team_discoverability&#34;: team_discoverability,
            }
        )
        return self.api_call(&#34;admin.teams.create&#34;, params=kwargs)

    def admin_teams_list(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List all teams on an Enterprise organization.
        https://api.slack.com/methods/admin.teams.list
        &#34;&#34;&#34;
        kwargs.update({&#34;cursor&#34;: cursor, &#34;limit&#34;: limit})
        return self.api_call(&#34;admin.teams.list&#34;, params=kwargs)

    def admin_teams_owners_list(
        self,
        *,
        team_id: str,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List all of the admins on a given workspace.
        https://api.slack.com/methods/admin.teams.owners.list
        &#34;&#34;&#34;
        kwargs.update({&#34;team_id&#34;: team_id, &#34;cursor&#34;: cursor, &#34;limit&#34;: limit})
        return self.api_call(&#34;admin.teams.owners.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def admin_teams_settings_info(
        self,
        *,
        team_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Fetch information about settings in a workspace
        https://api.slack.com/methods/admin.teams.settings.info
        &#34;&#34;&#34;
        kwargs.update({&#34;team_id&#34;: team_id})
        return self.api_call(&#34;admin.teams.settings.info&#34;, params=kwargs)

    def admin_teams_settings_setDescription(
        self,
        *,
        team_id: str,
        description: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Set the description of a given workspace.
        https://api.slack.com/methods/admin.teams.settings.setDescription
        &#34;&#34;&#34;
        kwargs.update({&#34;team_id&#34;: team_id, &#34;description&#34;: description})
        return self.api_call(&#34;admin.teams.settings.setDescription&#34;, params=kwargs)

    def admin_teams_settings_setDiscoverability(
        self,
        *,
        team_id: str,
        discoverability: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sets the icon of a workspace.
        https://api.slack.com/methods/admin.teams.settings.setDiscoverability
        &#34;&#34;&#34;
        kwargs.update({&#34;team_id&#34;: team_id, &#34;discoverability&#34;: discoverability})
        return self.api_call(&#34;admin.teams.settings.setDiscoverability&#34;, params=kwargs)

    def admin_teams_settings_setIcon(
        self,
        *,
        team_id: str,
        image_url: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sets the icon of a workspace.
        https://api.slack.com/methods/admin.teams.settings.setIcon
        &#34;&#34;&#34;
        kwargs.update({&#34;team_id&#34;: team_id, &#34;image_url&#34;: image_url})
        return self.api_call(&#34;admin.teams.settings.setIcon&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def admin_teams_settings_setName(
        self,
        *,
        team_id: str,
        name: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sets the icon of a workspace.
        https://api.slack.com/methods/admin.teams.settings.setName
        &#34;&#34;&#34;
        kwargs.update({&#34;team_id&#34;: team_id, &#34;name&#34;: name})
        return self.api_call(&#34;admin.teams.settings.setName&#34;, params=kwargs)

    def admin_usergroups_addChannels(
        self,
        *,
        channel_ids: Union[str, Sequence[str]],
        usergroup_id: str,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Add one or more default channels to an IDP group.
        https://api.slack.com/methods/admin.usergroups.addChannels
        &#34;&#34;&#34;
        kwargs.update({&#34;team_id&#34;: team_id, &#34;usergroup_id&#34;: usergroup_id})
        if isinstance(channel_ids, (list, Tuple)):
            kwargs.update({&#34;channel_ids&#34;: &#34;,&#34;.join(channel_ids)})
        else:
            kwargs.update({&#34;channel_ids&#34;: channel_ids})
        return self.api_call(&#34;admin.usergroups.addChannels&#34;, params=kwargs)

    def admin_usergroups_addTeams(
        self,
        *,
        usergroup_id: str,
        team_ids: Union[str, Sequence[str]],
        auto_provision: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Associate one or more default workspaces with an organization-wide IDP group.
        https://api.slack.com/methods/admin.usergroups.addTeams
        &#34;&#34;&#34;
        kwargs.update({&#34;usergroup_id&#34;: usergroup_id, &#34;auto_provision&#34;: auto_provision})
        if isinstance(team_ids, (list, Tuple)):
            kwargs.update({&#34;team_ids&#34;: &#34;,&#34;.join(team_ids)})
        else:
            kwargs.update({&#34;team_ids&#34;: team_ids})
        return self.api_call(&#34;admin.usergroups.addTeams&#34;, params=kwargs)

    def admin_usergroups_listChannels(
        self,
        *,
        usergroup_id: str,
        include_num_members: Optional[bool] = None,
        team_id: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Add one or more default channels to an IDP group.
        https://api.slack.com/methods/admin.usergroups.listChannels
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;usergroup_id&#34;: usergroup_id,
                &#34;include_num_members&#34;: include_num_members,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;admin.usergroups.listChannels&#34;, params=kwargs)

    def admin_usergroups_removeChannels(
        self,
        *,
        usergroup_id: str,
        channel_ids: Union[str, Sequence[str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Add one or more default channels to an IDP group.
        https://api.slack.com/methods/admin.usergroups.removeChannels
        &#34;&#34;&#34;
        kwargs.update({&#34;usergroup_id&#34;: usergroup_id})
        if isinstance(channel_ids, (list, Tuple)):
            kwargs.update({&#34;channel_ids&#34;: &#34;,&#34;.join(channel_ids)})
        else:
            kwargs.update({&#34;channel_ids&#34;: channel_ids})
        return self.api_call(&#34;admin.usergroups.removeChannels&#34;, params=kwargs)

    def admin_users_assign(
        self,
        *,
        team_id: str,
        user_id: str,
        channel_ids: Optional[Union[str, Sequence[str]]] = None,
        is_restricted: Optional[bool] = None,
        is_ultra_restricted: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Add an Enterprise user to a workspace.
        https://api.slack.com/methods/admin.users.assign
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;team_id&#34;: team_id,
                &#34;user_id&#34;: user_id,
                &#34;is_restricted&#34;: is_restricted,
                &#34;is_ultra_restricted&#34;: is_ultra_restricted,
            }
        )
        if isinstance(channel_ids, (list, Tuple)):
            kwargs.update({&#34;channel_ids&#34;: &#34;,&#34;.join(channel_ids)})
        else:
            kwargs.update({&#34;channel_ids&#34;: channel_ids})
        return self.api_call(&#34;admin.users.assign&#34;, params=kwargs)

    def admin_users_invite(
        self,
        *,
        team_id: str,
        email: str,
        channel_ids: Union[str, Sequence[str]],
        custom_message: Optional[str] = None,
        email_password_policy_enabled: Optional[bool] = None,
        guest_expiration_ts: Optional[Union[str, float]] = None,
        is_restricted: Optional[bool] = None,
        is_ultra_restricted: Optional[bool] = None,
        real_name: Optional[str] = None,
        resend: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Invite a user to a workspace.
        https://api.slack.com/methods/admin.users.invite
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;team_id&#34;: team_id,
                &#34;email&#34;: email,
                &#34;custom_message&#34;: custom_message,
                &#34;email_password_policy_enabled&#34;: email_password_policy_enabled,
                &#34;guest_expiration_ts&#34;: str(guest_expiration_ts) if guest_expiration_ts is not None else None,
                &#34;is_restricted&#34;: is_restricted,
                &#34;is_ultra_restricted&#34;: is_ultra_restricted,
                &#34;real_name&#34;: real_name,
                &#34;resend&#34;: resend,
            }
        )
        if isinstance(channel_ids, (list, Tuple)):
            kwargs.update({&#34;channel_ids&#34;: &#34;,&#34;.join(channel_ids)})
        else:
            kwargs.update({&#34;channel_ids&#34;: channel_ids})
        return self.api_call(&#34;admin.users.invite&#34;, params=kwargs)

    def admin_users_list(
        self,
        *,
        team_id: str,
        include_deactivated_user_workspaces: Optional[bool] = None,
        is_active: Optional[bool] = None,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List users on a workspace
        https://api.slack.com/methods/admin.users.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;team_id&#34;: team_id,
                &#34;include_deactivated_user_workspaces&#34;: include_deactivated_user_workspaces,
                &#34;is_active&#34;: is_active,
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
            }
        )
        return self.api_call(&#34;admin.users.list&#34;, params=kwargs)

    def admin_users_remove(
        self,
        *,
        team_id: str,
        user_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Remove a user from a workspace.
        https://api.slack.com/methods/admin.users.remove
        &#34;&#34;&#34;
        kwargs.update({&#34;team_id&#34;: team_id, &#34;user_id&#34;: user_id})
        return self.api_call(&#34;admin.users.remove&#34;, params=kwargs)

    def admin_users_setAdmin(
        self,
        *,
        team_id: str,
        user_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Set an existing guest, regular user, or owner to be an admin user.
        https://api.slack.com/methods/admin.users.setAdmin
        &#34;&#34;&#34;
        kwargs.update({&#34;team_id&#34;: team_id, &#34;user_id&#34;: user_id})
        return self.api_call(&#34;admin.users.setAdmin&#34;, params=kwargs)

    def admin_users_setExpiration(
        self,
        *,
        expiration_ts: int,
        user_id: str,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Set an expiration for a guest user.
        https://api.slack.com/methods/admin.users.setExpiration
        &#34;&#34;&#34;
        kwargs.update({&#34;expiration_ts&#34;: expiration_ts, &#34;team_id&#34;: team_id, &#34;user_id&#34;: user_id})
        return self.api_call(&#34;admin.users.setExpiration&#34;, params=kwargs)

    def admin_users_setOwner(
        self,
        *,
        team_id: str,
        user_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Set an existing guest, regular user, or admin user to be a workspace owner.
        https://api.slack.com/methods/admin.users.setOwner
        &#34;&#34;&#34;
        kwargs.update({&#34;team_id&#34;: team_id, &#34;user_id&#34;: user_id})
        return self.api_call(&#34;admin.users.setOwner&#34;, params=kwargs)

    def admin_users_setRegular(
        self,
        *,
        team_id: str,
        user_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Set an existing guest user, admin user, or owner to be a regular user.
        https://api.slack.com/methods/admin.users.setRegular
        &#34;&#34;&#34;
        kwargs.update({&#34;team_id&#34;: team_id, &#34;user_id&#34;: user_id})
        return self.api_call(&#34;admin.users.setRegular&#34;, params=kwargs)

    def admin_workflows_search(
        self,
        *,
        app_id: Optional[str] = None,
        collaborator_ids: Optional[Union[str, Sequence[str]]] = None,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        no_collaborators: Optional[bool] = None,
        num_trigger_ids: Optional[int] = None,
        query: Optional[str] = None,
        sort: Optional[str] = None,
        sort_dir: Optional[str] = None,
        source: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Search workflows within the team or enterprise
        https://api.slack.com/methods/admin.workflows.search
        &#34;&#34;&#34;
        if collaborator_ids is not None:
            if isinstance(collaborator_ids, (list, Tuple)):
                kwargs.update({&#34;collaborator_ids&#34;: &#34;,&#34;.join(collaborator_ids)})
            else:
                kwargs.update({&#34;collaborator_ids&#34;: collaborator_ids})
        kwargs.update(
            {
                &#34;app_id&#34;: app_id,
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
                &#34;no_collaborators&#34;: no_collaborators,
                &#34;num_trigger_ids&#34;: num_trigger_ids,
                &#34;query&#34;: query,
                &#34;sort&#34;: sort,
                &#34;sort_dir&#34;: sort_dir,
                &#34;source&#34;: source,
            }
        )
        return self.api_call(&#34;admin.workflows.search&#34;, params=kwargs)

    def admin_workflows_permissions_lookup(
        self,
        *,
        workflow_ids: Union[str, Sequence[str]],
        max_workflow_triggers: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Look up the permissions for a set of workflows
        https://api.slack.com/methods/admin.workflows.permissions.lookup
        &#34;&#34;&#34;
        if isinstance(workflow_ids, (list, Tuple)):
            kwargs.update({&#34;workflow_ids&#34;: &#34;,&#34;.join(workflow_ids)})
        else:
            kwargs.update({&#34;workflow_ids&#34;: workflow_ids})
        kwargs.update(
            {
                &#34;max_workflow_triggers&#34;: max_workflow_triggers,
            }
        )
        return self.api_call(&#34;admin.workflows.permissions.lookup&#34;, params=kwargs)

    def admin_workflows_collaborators_add(
        self,
        *,
        collaborator_ids: Union[str, Sequence[str]],
        workflow_ids: Union[str, Sequence[str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Add collaborators to workflows within the team or enterprise
        https://api.slack.com/methods/admin.workflows.collaborators.add
        &#34;&#34;&#34;
        if isinstance(collaborator_ids, (list, Tuple)):
            kwargs.update({&#34;collaborator_ids&#34;: &#34;,&#34;.join(collaborator_ids)})
        else:
            kwargs.update({&#34;collaborator_ids&#34;: collaborator_ids})
        if isinstance(workflow_ids, (list, Tuple)):
            kwargs.update({&#34;workflow_ids&#34;: &#34;,&#34;.join(workflow_ids)})
        else:
            kwargs.update({&#34;workflow_ids&#34;: workflow_ids})
        return self.api_call(&#34;admin.workflows.collaborators.add&#34;, params=kwargs)

    def admin_workflows_collaborators_remove(
        self,
        *,
        collaborator_ids: Union[str, Sequence[str]],
        workflow_ids: Union[str, Sequence[str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Remove collaborators from workflows within the team or enterprise
        https://api.slack.com/methods/admin.workflows.collaborators.remove
        &#34;&#34;&#34;
        if isinstance(collaborator_ids, (list, Tuple)):
            kwargs.update({&#34;collaborator_ids&#34;: &#34;,&#34;.join(collaborator_ids)})
        else:
            kwargs.update({&#34;collaborator_ids&#34;: collaborator_ids})
        if isinstance(workflow_ids, (list, Tuple)):
            kwargs.update({&#34;workflow_ids&#34;: &#34;,&#34;.join(workflow_ids)})
        else:
            kwargs.update({&#34;workflow_ids&#34;: workflow_ids})
        return self.api_call(&#34;admin.workflows.collaborators.remove&#34;, params=kwargs)

    def admin_workflows_unpublish(
        self,
        *,
        workflow_ids: Union[str, Sequence[str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Unpublish workflows within the team or enterprise
        https://api.slack.com/methods/admin.workflows.unpublish
        &#34;&#34;&#34;
        if isinstance(workflow_ids, (list, Tuple)):
            kwargs.update({&#34;workflow_ids&#34;: &#34;,&#34;.join(workflow_ids)})
        else:
            kwargs.update({&#34;workflow_ids&#34;: workflow_ids})
        return self.api_call(&#34;admin.workflows.unpublish&#34;, params=kwargs)

    def api_test(
        self,
        *,
        error: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Checks API calling code.
        https://api.slack.com/methods/api.test
        &#34;&#34;&#34;
        kwargs.update({&#34;error&#34;: error})
        return self.api_call(&#34;api.test&#34;, params=kwargs)

    def apps_connections_open(
        self,
        *,
        app_token: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Generate a temporary Socket Mode WebSocket URL that your app can connect to
        in order to receive events and interactive payloads
        https://api.slack.com/methods/apps.connections.open
        &#34;&#34;&#34;
        kwargs.update({&#34;token&#34;: app_token})
        return self.api_call(&#34;apps.connections.open&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def apps_event_authorizations_list(
        self,
        *,
        event_context: str,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Get a list of authorizations for the given event context.
        Each authorization represents an app installation that the event is visible to.
        https://api.slack.com/methods/apps.event.authorizations.list
        &#34;&#34;&#34;
        kwargs.update({&#34;event_context&#34;: event_context, &#34;cursor&#34;: cursor, &#34;limit&#34;: limit})
        return self.api_call(&#34;apps.event.authorizations.list&#34;, params=kwargs)

    def apps_uninstall(
        self,
        *,
        client_id: str,
        client_secret: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Uninstalls your app from a workspace.
        https://api.slack.com/methods/apps.uninstall
        &#34;&#34;&#34;
        kwargs.update({&#34;client_id&#34;: client_id, &#34;client_secret&#34;: client_secret})
        return self.api_call(&#34;apps.uninstall&#34;, params=kwargs)

    def apps_manifest_create(
        self,
        *,
        manifest: Union[str, Dict[str, Any]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Create an app from an app manifest
        https://api.slack.com/methods/apps.manifest.create
        &#34;&#34;&#34;
        if isinstance(manifest, str):
            kwargs.update({&#34;manifest&#34;: manifest})
        else:
            kwargs.update({&#34;manifest&#34;: json.dumps(manifest)})
        return self.api_call(&#34;apps.manifest.create&#34;, params=kwargs)

    def apps_manifest_delete(
        self,
        *,
        app_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Permanently deletes an app created through app manifests
        https://api.slack.com/methods/apps.manifest.delete
        &#34;&#34;&#34;
        kwargs.update({&#34;app_id&#34;: app_id})
        return self.api_call(&#34;apps.manifest.delete&#34;, params=kwargs)

    def apps_manifest_export(
        self,
        *,
        app_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Export an app manifest from an existing app
        https://api.slack.com/methods/apps.manifest.export
        &#34;&#34;&#34;
        kwargs.update({&#34;app_id&#34;: app_id})
        return self.api_call(&#34;apps.manifest.export&#34;, params=kwargs)

    def apps_manifest_update(
        self,
        *,
        app_id: str,
        manifest: Union[str, Dict[str, Any]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Update an app from an app manifest
        https://api.slack.com/methods/apps.manifest.update
        &#34;&#34;&#34;
        if isinstance(manifest, str):
            kwargs.update({&#34;manifest&#34;: manifest})
        else:
            kwargs.update({&#34;manifest&#34;: json.dumps(manifest)})
        kwargs.update({&#34;app_id&#34;: app_id})
        return self.api_call(&#34;apps.manifest.update&#34;, params=kwargs)

    def apps_manifest_validate(
        self,
        *,
        manifest: Union[str, Dict[str, Any]],
        app_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Validate an app manifest
        https://api.slack.com/methods/apps.manifest.validate
        &#34;&#34;&#34;
        if isinstance(manifest, str):
            kwargs.update({&#34;manifest&#34;: manifest})
        else:
            kwargs.update({&#34;manifest&#34;: json.dumps(manifest)})
        kwargs.update({&#34;app_id&#34;: app_id})
        return self.api_call(&#34;apps.manifest.validate&#34;, params=kwargs)

    def tooling_tokens_rotate(
        self,
        *,
        refresh_token: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Exchanges a refresh token for a new app configuration token
        https://api.slack.com/methods/tooling.tokens.rotate
        &#34;&#34;&#34;
        kwargs.update({&#34;refresh_token&#34;: refresh_token})
        return self.api_call(&#34;tooling.tokens.rotate&#34;, params=kwargs)

    def auth_revoke(
        self,
        *,
        test: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Revokes a token.
        https://api.slack.com/methods/auth.revoke
        &#34;&#34;&#34;
        kwargs.update({&#34;test&#34;: test})
        return self.api_call(&#34;auth.revoke&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def auth_test(
        self,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Checks authentication &amp; identity.
        https://api.slack.com/methods/auth.test
        &#34;&#34;&#34;
        return self.api_call(&#34;auth.test&#34;, params=kwargs)

    def auth_teams_list(
        self,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        include_icon: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List the workspaces a token can access.
        https://api.slack.com/methods/auth.teams.list
        &#34;&#34;&#34;
        kwargs.update({&#34;cursor&#34;: cursor, &#34;limit&#34;: limit, &#34;include_icon&#34;: include_icon})
        return self.api_call(&#34;auth.teams.list&#34;, params=kwargs)

    def bookmarks_add(
        self,
        *,
        channel_id: str,
        title: str,
        type: str,
        emoji: Optional[str] = None,
        entity_id: Optional[str] = None,
        link: Optional[str] = None,  # include when type is &#39;link&#39;
        parent_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Add bookmark to a channel.
        https://api.slack.com/methods/bookmarks.add
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel_id&#34;: channel_id,
                &#34;title&#34;: title,
                &#34;type&#34;: type,
                &#34;emoji&#34;: emoji,
                &#34;entity_id&#34;: entity_id,
                &#34;link&#34;: link,
                &#34;parent_id&#34;: parent_id,
            }
        )
        return self.api_call(&#34;bookmarks.add&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def bookmarks_edit(
        self,
        *,
        bookmark_id: str,
        channel_id: str,
        emoji: Optional[str] = None,
        link: Optional[str] = None,
        title: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Edit bookmark.
        https://api.slack.com/methods/bookmarks.edit
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;bookmark_id&#34;: bookmark_id,
                &#34;channel_id&#34;: channel_id,
                &#34;emoji&#34;: emoji,
                &#34;link&#34;: link,
                &#34;title&#34;: title,
            }
        )
        return self.api_call(&#34;bookmarks.edit&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def bookmarks_list(
        self,
        *,
        channel_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List bookmark for the channel.
        https://api.slack.com/methods/bookmarks.list
        &#34;&#34;&#34;
        kwargs.update({&#34;channel_id&#34;: channel_id})
        return self.api_call(&#34;bookmarks.list&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def bookmarks_remove(
        self,
        *,
        bookmark_id: str,
        channel_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Remove bookmark from the channel.
        https://api.slack.com/methods/bookmarks.remove
        &#34;&#34;&#34;
        kwargs.update({&#34;bookmark_id&#34;: bookmark_id, &#34;channel_id&#34;: channel_id})
        return self.api_call(&#34;bookmarks.remove&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def bots_info(
        self,
        *,
        bot: Optional[str] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Gets information about a bot user.
        https://api.slack.com/methods/bots.info
        &#34;&#34;&#34;
        kwargs.update({&#34;bot&#34;: bot, &#34;team_id&#34;: team_id})
        return self.api_call(&#34;bots.info&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def calls_add(
        self,
        *,
        external_unique_id: str,
        join_url: str,
        created_by: Optional[str] = None,
        date_start: Optional[int] = None,
        desktop_app_join_url: Optional[str] = None,
        external_display_id: Optional[str] = None,
        title: Optional[str] = None,
        users: Optional[Union[str, Sequence[Dict[str, str]]]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Registers a new Call.
        https://api.slack.com/methods/calls.add
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;external_unique_id&#34;: external_unique_id,
                &#34;join_url&#34;: join_url,
                &#34;created_by&#34;: created_by,
                &#34;date_start&#34;: date_start,
                &#34;desktop_app_join_url&#34;: desktop_app_join_url,
                &#34;external_display_id&#34;: external_display_id,
                &#34;title&#34;: title,
            }
        )
        _update_call_participants(  # skipcq: PTC-W0039
            kwargs,
            users if users is not None else kwargs.get(&#34;users&#34;),  # skipcq: PTC-W0039
        )  # skipcq: PTC-W0039
        return self.api_call(&#34;calls.add&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def calls_end(
        self,
        *,
        id: str,
        duration: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:  # skipcq: PYL-W0622
        &#34;&#34;&#34;Ends a Call.
        https://api.slack.com/methods/calls.end
        &#34;&#34;&#34;
        kwargs.update({&#34;id&#34;: id, &#34;duration&#34;: duration})
        return self.api_call(&#34;calls.end&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def calls_info(
        self,
        *,
        id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:  # skipcq: PYL-W0622
        &#34;&#34;&#34;Returns information about a Call.
        https://api.slack.com/methods/calls.info
        &#34;&#34;&#34;
        kwargs.update({&#34;id&#34;: id})
        return self.api_call(&#34;calls.info&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def calls_participants_add(
        self,
        *,
        id: str,  # skipcq: PYL-W0622
        users: Union[str, Sequence[Dict[str, str]]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Registers new participants added to a Call.
        https://api.slack.com/methods/calls.participants.add
        &#34;&#34;&#34;
        kwargs.update({&#34;id&#34;: id})
        _update_call_participants(kwargs, users)
        return self.api_call(&#34;calls.participants.add&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def calls_participants_remove(
        self,
        *,
        id: str,  # skipcq: PYL-W0622
        users: Union[str, Sequence[Dict[str, str]]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Registers participants removed from a Call.
        https://api.slack.com/methods/calls.participants.remove
        &#34;&#34;&#34;
        kwargs.update({&#34;id&#34;: id})
        _update_call_participants(kwargs, users)
        return self.api_call(&#34;calls.participants.remove&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def calls_update(
        self,
        *,
        id: str,
        desktop_app_join_url: Optional[str] = None,
        join_url: Optional[str] = None,
        title: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:  # skipcq: PYL-W0622
        &#34;&#34;&#34;Updates information about a Call.
        https://api.slack.com/methods/calls.update
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;id&#34;: id,
                &#34;desktop_app_join_url&#34;: desktop_app_join_url,
                &#34;join_url&#34;: join_url,
                &#34;title&#34;: title,
            }
        )
        return self.api_call(&#34;calls.update&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    # --------------------------
    # Deprecated: channels.*
    # You can use conversations.* APIs instead.
    # https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api
    # --------------------------

    def channels_archive(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Archives a channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;channels.archive&#34;, json=kwargs)

    def channels_create(
        self,
        *,
        name: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Creates a channel.&#34;&#34;&#34;
        kwargs.update({&#34;name&#34;: name})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;channels.create&#34;, json=kwargs)

    def channels_history(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Fetches history of messages and events from a channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        return self.api_call(&#34;channels.history&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def channels_info(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Gets information about a channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        return self.api_call(&#34;channels.info&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def channels_invite(
        self,
        *,
        channel: str,
        user: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Invites a user to a channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;user&#34;: user})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;channels.invite&#34;, json=kwargs)

    def channels_join(
        self,
        *,
        name: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Joins a channel, creating it if needed.&#34;&#34;&#34;
        kwargs.update({&#34;name&#34;: name})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;channels.join&#34;, json=kwargs)

    def channels_kick(
        self,
        *,
        channel: str,
        user: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Removes a user from a channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;user&#34;: user})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;channels.kick&#34;, json=kwargs)

    def channels_leave(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Leaves a channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;channels.leave&#34;, json=kwargs)

    def channels_list(
        self,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lists all channels in a Slack team.&#34;&#34;&#34;
        return self.api_call(&#34;channels.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def channels_mark(
        self,
        *,
        channel: str,
        ts: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sets the read cursor in a channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;ts&#34;: ts})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;channels.mark&#34;, json=kwargs)

    def channels_rename(
        self,
        *,
        channel: str,
        name: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Renames a channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;name&#34;: name})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;channels.rename&#34;, json=kwargs)

    def channels_replies(
        self,
        *,
        channel: str,
        thread_ts: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieve a thread of messages posted to a channel&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;thread_ts&#34;: thread_ts})
        return self.api_call(&#34;channels.replies&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def channels_setPurpose(
        self,
        *,
        channel: str,
        purpose: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sets the purpose for a channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;purpose&#34;: purpose})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;channels.setPurpose&#34;, json=kwargs)

    def channels_setTopic(
        self,
        *,
        channel: str,
        topic: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sets the topic for a channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;topic&#34;: topic})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;channels.setTopic&#34;, json=kwargs)

    def channels_unarchive(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Unarchives a channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;channels.unarchive&#34;, json=kwargs)

    # --------------------------

    def chat_delete(
        self,
        *,
        channel: str,
        ts: str,
        as_user: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Deletes a message.
        https://api.slack.com/methods/chat.delete
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;ts&#34;: ts, &#34;as_user&#34;: as_user})
        return self.api_call(&#34;chat.delete&#34;, params=kwargs)

    def chat_deleteScheduledMessage(
        self,
        *,
        channel: str,
        scheduled_message_id: str,
        as_user: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Deletes a scheduled message.
        https://api.slack.com/methods/chat.deleteScheduledMessage
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;scheduled_message_id&#34;: scheduled_message_id,
                &#34;as_user&#34;: as_user,
            }
        )
        return self.api_call(&#34;chat.deleteScheduledMessage&#34;, params=kwargs)

    def chat_getPermalink(
        self,
        *,
        channel: str,
        message_ts: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieve a permalink URL for a specific extant message
        https://api.slack.com/methods/chat.getPermalink
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;message_ts&#34;: message_ts})
        return self.api_call(&#34;chat.getPermalink&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def chat_meMessage(
        self,
        *,
        channel: str,
        text: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Share a me message into a channel.
        https://api.slack.com/methods/chat.meMessage
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;text&#34;: text})
        return self.api_call(&#34;chat.meMessage&#34;, params=kwargs)

    def chat_postEphemeral(
        self,
        *,
        channel: str,
        user: str,
        text: Optional[str] = None,
        as_user: Optional[bool] = None,
        attachments: Optional[Union[str, Sequence[Union[Dict, Attachment]]]] = None,
        blocks: Optional[Union[str, Sequence[Union[Dict, Block]]]] = None,
        thread_ts: Optional[str] = None,
        icon_emoji: Optional[str] = None,
        icon_url: Optional[str] = None,
        link_names: Optional[bool] = None,
        username: Optional[str] = None,
        parse: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sends an ephemeral message to a user in a channel.
        https://api.slack.com/methods/chat.postEphemeral
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;user&#34;: user,
                &#34;text&#34;: text,
                &#34;as_user&#34;: as_user,
                &#34;attachments&#34;: attachments,
                &#34;blocks&#34;: blocks,
                &#34;thread_ts&#34;: thread_ts,
                &#34;icon_emoji&#34;: icon_emoji,
                &#34;icon_url&#34;: icon_url,
                &#34;link_names&#34;: link_names,
                &#34;username&#34;: username,
                &#34;parse&#34;: parse,
            }
        )
        _parse_web_class_objects(kwargs)
        kwargs = _remove_none_values(kwargs)
        _warn_if_text_or_attachment_fallback_is_missing(&#34;chat.postEphemeral&#34;, kwargs)
        # NOTE: intentionally using json over params for the API methods using blocks/attachments
        return self.api_call(&#34;chat.postEphemeral&#34;, json=kwargs)

    def chat_postMessage(
        self,
        *,
        channel: str,
        text: Optional[str] = None,
        as_user: Optional[bool] = None,
        attachments: Optional[Union[str, Sequence[Union[Dict, Attachment]]]] = None,
        blocks: Optional[Union[str, Sequence[Union[Dict, Block]]]] = None,
        thread_ts: Optional[str] = None,
        reply_broadcast: Optional[bool] = None,
        unfurl_links: Optional[bool] = None,
        unfurl_media: Optional[bool] = None,
        container_id: Optional[str] = None,
        icon_emoji: Optional[str] = None,
        icon_url: Optional[str] = None,
        mrkdwn: Optional[bool] = None,
        link_names: Optional[bool] = None,
        username: Optional[str] = None,
        parse: Optional[str] = None,  # none, full
        metadata: Optional[Union[Dict, Metadata]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sends a message to a channel.
        https://api.slack.com/methods/chat.postMessage
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;text&#34;: text,
                &#34;as_user&#34;: as_user,
                &#34;attachments&#34;: attachments,
                &#34;blocks&#34;: blocks,
                &#34;thread_ts&#34;: thread_ts,
                &#34;reply_broadcast&#34;: reply_broadcast,
                &#34;unfurl_links&#34;: unfurl_links,
                &#34;unfurl_media&#34;: unfurl_media,
                &#34;container_id&#34;: container_id,
                &#34;icon_emoji&#34;: icon_emoji,
                &#34;icon_url&#34;: icon_url,
                &#34;mrkdwn&#34;: mrkdwn,
                &#34;link_names&#34;: link_names,
                &#34;username&#34;: username,
                &#34;parse&#34;: parse,
                &#34;metadata&#34;: metadata,
            }
        )
        _parse_web_class_objects(kwargs)
        kwargs = _remove_none_values(kwargs)
        _warn_if_text_or_attachment_fallback_is_missing(&#34;chat.postMessage&#34;, kwargs)
        # NOTE: intentionally using json over params for the API methods using blocks/attachments
        return self.api_call(&#34;chat.postMessage&#34;, json=kwargs)

    def chat_scheduleMessage(
        self,
        *,
        channel: str,
        post_at: Union[str, int],
        text: str,
        as_user: Optional[bool] = None,
        attachments: Optional[Union[str, Sequence[Union[Dict, Attachment]]]] = None,
        blocks: Optional[Union[str, Sequence[Union[Dict, Block]]]] = None,
        thread_ts: Optional[str] = None,
        parse: Optional[str] = None,
        reply_broadcast: Optional[bool] = None,
        unfurl_links: Optional[bool] = None,
        unfurl_media: Optional[bool] = None,
        link_names: Optional[bool] = None,
        metadata: Optional[Union[Dict, Metadata]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Schedules a message.
        https://api.slack.com/methods/chat.scheduleMessage
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;post_at&#34;: post_at,
                &#34;text&#34;: text,
                &#34;as_user&#34;: as_user,
                &#34;attachments&#34;: attachments,
                &#34;blocks&#34;: blocks,
                &#34;thread_ts&#34;: thread_ts,
                &#34;reply_broadcast&#34;: reply_broadcast,
                &#34;parse&#34;: parse,
                &#34;unfurl_links&#34;: unfurl_links,
                &#34;unfurl_media&#34;: unfurl_media,
                &#34;link_names&#34;: link_names,
                &#34;metadata&#34;: metadata,
            }
        )
        _parse_web_class_objects(kwargs)
        kwargs = _remove_none_values(kwargs)
        _warn_if_text_or_attachment_fallback_is_missing(&#34;chat.scheduleMessage&#34;, kwargs)
        # NOTE: intentionally using json over params for the API methods using blocks/attachments
        return self.api_call(&#34;chat.scheduleMessage&#34;, json=kwargs)

    def chat_unfurl(
        self,
        *,
        channel: Optional[str] = None,
        ts: Optional[str] = None,
        source: Optional[str] = None,
        unfurl_id: Optional[str] = None,
        unfurls: Optional[Dict[str, Dict]] = None,  # or user_auth_*
        user_auth_blocks: Optional[Union[str, Sequence[Union[Dict, Block]]]] = None,
        user_auth_message: Optional[str] = None,
        user_auth_required: Optional[bool] = None,
        user_auth_url: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Provide custom unfurl behavior for user-posted URLs.
        https://api.slack.com/methods/chat.unfurl
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;ts&#34;: ts,
                &#34;source&#34;: source,
                &#34;unfurl_id&#34;: unfurl_id,
                &#34;unfurls&#34;: unfurls,
                &#34;user_auth_blocks&#34;: user_auth_blocks,
                &#34;user_auth_message&#34;: user_auth_message,
                &#34;user_auth_required&#34;: user_auth_required,
                &#34;user_auth_url&#34;: user_auth_url,
            }
        )
        _parse_web_class_objects(kwargs)  # for user_auth_blocks
        kwargs = _remove_none_values(kwargs)
        # NOTE: intentionally using json over params for API methods using blocks/attachments
        return self.api_call(&#34;chat.unfurl&#34;, json=kwargs)

    def chat_update(
        self,
        *,
        channel: str,
        ts: str,
        text: Optional[str] = None,
        attachments: Optional[Union[str, Sequence[Union[Dict, Attachment]]]] = None,
        blocks: Optional[Union[str, Sequence[Union[Dict, Block]]]] = None,
        as_user: Optional[bool] = None,
        file_ids: Optional[Union[str, Sequence[str]]] = None,
        link_names: Optional[bool] = None,
        parse: Optional[str] = None,  # none, full
        reply_broadcast: Optional[bool] = None,
        metadata: Optional[Union[Dict, Metadata]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Updates a message in a channel.
        https://api.slack.com/methods/chat.update
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;ts&#34;: ts,
                &#34;text&#34;: text,
                &#34;attachments&#34;: attachments,
                &#34;blocks&#34;: blocks,
                &#34;as_user&#34;: as_user,
                &#34;link_names&#34;: link_names,
                &#34;parse&#34;: parse,
                &#34;reply_broadcast&#34;: reply_broadcast,
                &#34;metadata&#34;: metadata,
            }
        )
        if isinstance(file_ids, (list, Tuple)):
            kwargs.update({&#34;file_ids&#34;: &#34;,&#34;.join(file_ids)})
        else:
            kwargs.update({&#34;file_ids&#34;: file_ids})
        _parse_web_class_objects(kwargs)
        kwargs = _remove_none_values(kwargs)
        _warn_if_text_or_attachment_fallback_is_missing(&#34;chat.update&#34;, kwargs)
        # NOTE: intentionally using json over params for API methods using blocks/attachments
        return self.api_call(&#34;chat.update&#34;, json=kwargs)

    def chat_scheduledMessages_list(
        self,
        *,
        channel: Optional[str] = None,
        cursor: Optional[str] = None,
        latest: Optional[str] = None,
        limit: Optional[int] = None,
        oldest: Optional[str] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lists all scheduled messages.
        https://api.slack.com/methods/chat.scheduledMessages.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;cursor&#34;: cursor,
                &#34;latest&#34;: latest,
                &#34;limit&#34;: limit,
                &#34;oldest&#34;: oldest,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;chat.scheduledMessages.list&#34;, params=kwargs)

    def conversations_acceptSharedInvite(
        self,
        *,
        channel_name: str,
        channel_id: Optional[str] = None,
        invite_id: Optional[str] = None,
        free_trial_accepted: Optional[bool] = None,
        is_private: Optional[bool] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Accepts an invitation to a Slack Connect channel.
        https://api.slack.com/methods/conversations.acceptSharedInvite
        &#34;&#34;&#34;
        if channel_id is None and invite_id is None:
            raise e.SlackRequestError(&#34;Either channel_id or invite_id must be provided.&#34;)
        kwargs.update(
            {
                &#34;channel_name&#34;: channel_name,
                &#34;channel_id&#34;: channel_id,
                &#34;invite_id&#34;: invite_id,
                &#34;free_trial_accepted&#34;: free_trial_accepted,
                &#34;is_private&#34;: is_private,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;conversations.acceptSharedInvite&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def conversations_approveSharedInvite(
        self,
        *,
        invite_id: str,
        target_team: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Approves an invitation to a Slack Connect channel.
        https://api.slack.com/methods/conversations.approveSharedInvite
        &#34;&#34;&#34;
        kwargs.update({&#34;invite_id&#34;: invite_id, &#34;target_team&#34;: target_team})
        return self.api_call(&#34;conversations.approveSharedInvite&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def conversations_archive(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Archives a conversation.
        https://api.slack.com/methods/conversations.archive
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        return self.api_call(&#34;conversations.archive&#34;, params=kwargs)

    def conversations_close(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Closes a direct message or multi-person direct message.
        https://api.slack.com/methods/conversations.close
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        return self.api_call(&#34;conversations.close&#34;, params=kwargs)

    def conversations_create(
        self,
        *,
        name: str,
        is_private: Optional[bool] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Initiates a public or private channel-based conversation
        https://api.slack.com/methods/conversations.create
        &#34;&#34;&#34;
        kwargs.update({&#34;name&#34;: name, &#34;is_private&#34;: is_private, &#34;team_id&#34;: team_id})
        return self.api_call(&#34;conversations.create&#34;, params=kwargs)

    def conversations_declineSharedInvite(
        self,
        *,
        invite_id: str,
        target_team: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Declines a Slack Connect channel invite.
        https://api.slack.com/methods/conversations.declineSharedInvite
        &#34;&#34;&#34;
        kwargs.update({&#34;invite_id&#34;: invite_id, &#34;target_team&#34;: target_team})
        return self.api_call(&#34;conversations.declineSharedInvite&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def conversations_history(
        self,
        *,
        channel: str,
        cursor: Optional[str] = None,
        inclusive: Optional[bool] = None,
        include_all_metadata: Optional[bool] = None,
        latest: Optional[str] = None,
        limit: Optional[int] = None,
        oldest: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Fetches a conversation&#39;s history of messages and events.
        https://api.slack.com/methods/conversations.history
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;cursor&#34;: cursor,
                &#34;inclusive&#34;: inclusive,
                &#34;include_all_metadata&#34;: include_all_metadata,
                &#34;limit&#34;: limit,
                &#34;latest&#34;: latest,
                &#34;oldest&#34;: oldest,
            }
        )
        return self.api_call(&#34;conversations.history&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def conversations_info(
        self,
        *,
        channel: str,
        include_locale: Optional[bool] = None,
        include_num_members: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieve information about a conversation.
        https://api.slack.com/methods/conversations.info
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;include_locale&#34;: include_locale,
                &#34;include_num_members&#34;: include_num_members,
            }
        )
        return self.api_call(&#34;conversations.info&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def conversations_invite(
        self,
        *,
        channel: str,
        users: Union[str, Sequence[str]],
        force: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Invites users to a channel.
        https://api.slack.com/methods/conversations.invite
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;force&#34;: force,
            }
        )
        if isinstance(users, (list, Tuple)):
            kwargs.update({&#34;users&#34;: &#34;,&#34;.join(users)})
        else:
            kwargs.update({&#34;users&#34;: users})
        return self.api_call(&#34;conversations.invite&#34;, params=kwargs)

    def conversations_inviteShared(
        self,
        *,
        channel: str,
        emails: Optional[Union[str, Sequence[str]]] = None,
        user_ids: Optional[Union[str, Sequence[str]]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sends an invitation to a Slack Connect channel.
        https://api.slack.com/methods/conversations.inviteShared
        &#34;&#34;&#34;
        if emails is None and user_ids is None:
            raise e.SlackRequestError(&#34;Either emails or user ids must be provided.&#34;)
        kwargs.update({&#34;channel&#34;: channel})
        if isinstance(emails, (list, Tuple)):
            kwargs.update({&#34;emails&#34;: &#34;,&#34;.join(emails)})
        else:
            kwargs.update({&#34;emails&#34;: emails})
        if isinstance(user_ids, (list, Tuple)):
            kwargs.update({&#34;user_ids&#34;: &#34;,&#34;.join(user_ids)})
        else:
            kwargs.update({&#34;user_ids&#34;: user_ids})
        return self.api_call(&#34;conversations.inviteShared&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def conversations_join(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Joins an existing conversation.
        https://api.slack.com/methods/conversations.join
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        return self.api_call(&#34;conversations.join&#34;, params=kwargs)

    def conversations_kick(
        self,
        *,
        channel: str,
        user: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Removes a user from a conversation.
        https://api.slack.com/methods/conversations.kick
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;user&#34;: user})
        return self.api_call(&#34;conversations.kick&#34;, params=kwargs)

    def conversations_leave(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Leaves a conversation.
        https://api.slack.com/methods/conversations.leave
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        return self.api_call(&#34;conversations.leave&#34;, params=kwargs)

    def conversations_list(
        self,
        *,
        cursor: Optional[str] = None,
        exclude_archived: Optional[bool] = None,
        limit: Optional[int] = None,
        team_id: Optional[str] = None,
        types: Optional[Union[str, Sequence[str]]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lists all channels in a Slack team.
        https://api.slack.com/methods/conversations.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;cursor&#34;: cursor,
                &#34;exclude_archived&#34;: exclude_archived,
                &#34;limit&#34;: limit,
                &#34;team_id&#34;: team_id,
            }
        )
        if isinstance(types, (list, Tuple)):
            kwargs.update({&#34;types&#34;: &#34;,&#34;.join(types)})
        else:
            kwargs.update({&#34;types&#34;: types})
        return self.api_call(&#34;conversations.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def conversations_listConnectInvites(
        self,
        *,
        count: Optional[int] = None,
        cursor: Optional[str] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List shared channel invites that have been generated
        or received but have not yet been approved by all parties.
        https://api.slack.com/methods/conversations.listConnectInvites
        &#34;&#34;&#34;
        kwargs.update({&#34;count&#34;: count, &#34;cursor&#34;: cursor, &#34;team_id&#34;: team_id})
        return self.api_call(&#34;conversations.listConnectInvites&#34;, params=kwargs)

    def conversations_mark(
        self,
        *,
        channel: str,
        ts: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sets the read cursor in a channel.
        https://api.slack.com/methods/conversations.mark
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;ts&#34;: ts})
        return self.api_call(&#34;conversations.mark&#34;, params=kwargs)

    def conversations_members(
        self,
        *,
        channel: str,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieve members of a conversation.
        https://api.slack.com/methods/conversations.members
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;cursor&#34;: cursor, &#34;limit&#34;: limit})
        return self.api_call(&#34;conversations.members&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def conversations_open(
        self,
        *,
        channel: Optional[str] = None,
        return_im: Optional[bool] = None,
        users: Optional[Union[str, Sequence[str]]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Opens or resumes a direct message or multi-person direct message.
        https://api.slack.com/methods/conversations.open
        &#34;&#34;&#34;
        if channel is None and users is None:
            raise e.SlackRequestError(&#34;Either channel or users must be provided.&#34;)
        kwargs.update({&#34;channel&#34;: channel, &#34;return_im&#34;: return_im})
        if isinstance(users, (list, Tuple)):
            kwargs.update({&#34;users&#34;: &#34;,&#34;.join(users)})
        else:
            kwargs.update({&#34;users&#34;: users})
        return self.api_call(&#34;conversations.open&#34;, params=kwargs)

    def conversations_rename(
        self,
        *,
        channel: str,
        name: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Renames a conversation.
        https://api.slack.com/methods/conversations.rename
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;name&#34;: name})
        return self.api_call(&#34;conversations.rename&#34;, params=kwargs)

    def conversations_replies(
        self,
        *,
        channel: str,
        ts: str,
        cursor: Optional[str] = None,
        inclusive: Optional[bool] = None,
        include_all_metadata: Optional[bool] = None,
        latest: Optional[str] = None,
        limit: Optional[int] = None,
        oldest: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieve a thread of messages posted to a conversation
        https://api.slack.com/methods/conversations.replies
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;ts&#34;: ts,
                &#34;cursor&#34;: cursor,
                &#34;inclusive&#34;: inclusive,
                &#34;include_all_metadata&#34;: include_all_metadata,
                &#34;limit&#34;: limit,
                &#34;latest&#34;: latest,
                &#34;oldest&#34;: oldest,
            }
        )
        return self.api_call(&#34;conversations.replies&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def conversations_setPurpose(
        self,
        *,
        channel: str,
        purpose: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sets the purpose for a conversation.
        https://api.slack.com/methods/conversations.setPurpose
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;purpose&#34;: purpose})
        return self.api_call(&#34;conversations.setPurpose&#34;, params=kwargs)

    def conversations_setTopic(
        self,
        *,
        channel: str,
        topic: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sets the topic for a conversation.
        https://api.slack.com/methods/conversations.setTopic
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;topic&#34;: topic})
        return self.api_call(&#34;conversations.setTopic&#34;, params=kwargs)

    def conversations_unarchive(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Reverses conversation archival.
        https://api.slack.com/methods/conversations.unarchive
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        return self.api_call(&#34;conversations.unarchive&#34;, params=kwargs)

    def dialog_open(
        self,
        *,
        dialog: Dict[str, Any],
        trigger_id: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Open a dialog with a user.
        https://api.slack.com/methods/dialog.open
        &#34;&#34;&#34;
        kwargs.update({&#34;dialog&#34;: dialog, &#34;trigger_id&#34;: trigger_id})
        kwargs = _remove_none_values(kwargs)
        # NOTE: As the dialog can be a dict, this API call works only with json format.
        return self.api_call(&#34;dialog.open&#34;, json=kwargs)

    def dnd_endDnd(
        self,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Ends the current user&#39;s Do Not Disturb session immediately.
        https://api.slack.com/methods/dnd.endDnd
        &#34;&#34;&#34;
        return self.api_call(&#34;dnd.endDnd&#34;, params=kwargs)

    def dnd_endSnooze(
        self,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Ends the current user&#39;s snooze mode immediately.
        https://api.slack.com/methods/dnd.endSnooze
        &#34;&#34;&#34;
        return self.api_call(&#34;dnd.endSnooze&#34;, params=kwargs)

    def dnd_info(
        self,
        *,
        team_id: Optional[str] = None,
        user: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieves a user&#39;s current Do Not Disturb status.
        https://api.slack.com/methods/dnd.info
        &#34;&#34;&#34;
        kwargs.update({&#34;team_id&#34;: team_id, &#34;user&#34;: user})
        return self.api_call(&#34;dnd.info&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def dnd_setSnooze(
        self,
        *,
        num_minutes: Union[int, str],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Turns on Do Not Disturb mode for the current user, or changes its duration.
        https://api.slack.com/methods/dnd.setSnooze
        &#34;&#34;&#34;
        kwargs.update({&#34;num_minutes&#34;: num_minutes})
        return self.api_call(&#34;dnd.setSnooze&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def dnd_teamInfo(
        self,
        users: Union[str, Sequence[str]],
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieves the Do Not Disturb status for users on a team.
        https://api.slack.com/methods/dnd.teamInfo
        &#34;&#34;&#34;
        if isinstance(users, (list, Tuple)):
            kwargs.update({&#34;users&#34;: &#34;,&#34;.join(users)})
        else:
            kwargs.update({&#34;users&#34;: users})
        kwargs.update({&#34;team_id&#34;: team_id})
        return self.api_call(&#34;dnd.teamInfo&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def emoji_list(
        self,
        include_categories: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lists custom emoji for a team.
        https://api.slack.com/methods/emoji.list
        &#34;&#34;&#34;
        kwargs.update({&#34;include_categories&#34;: include_categories})
        return self.api_call(&#34;emoji.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def files_comments_delete(
        self,
        *,
        file: str,
        id: str,
        **kwargs,  # skipcq: PYL-W0622
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Deletes an existing comment on a file.
        https://api.slack.com/methods/files.comments.delete
        &#34;&#34;&#34;
        kwargs.update({&#34;file&#34;: file, &#34;id&#34;: id})
        return self.api_call(&#34;files.comments.delete&#34;, params=kwargs)

    def files_delete(
        self,
        *,
        file: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Deletes a file.
        https://api.slack.com/methods/files.delete
        &#34;&#34;&#34;
        kwargs.update({&#34;file&#34;: file})
        return self.api_call(&#34;files.delete&#34;, params=kwargs)

    def files_info(
        self,
        *,
        file: str,
        count: Optional[int] = None,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        page: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Gets information about a team file.
        https://api.slack.com/methods/files.info
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;file&#34;: file,
                &#34;count&#34;: count,
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
                &#34;page&#34;: page,
            }
        )
        return self.api_call(&#34;files.info&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def files_list(
        self,
        *,
        channel: Optional[str] = None,
        count: Optional[int] = None,
        page: Optional[int] = None,
        show_files_hidden_by_limit: Optional[bool] = None,
        team_id: Optional[str] = None,
        ts_from: Optional[str] = None,
        ts_to: Optional[str] = None,
        types: Optional[Union[str, Sequence[str]]] = None,
        user: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lists &amp; filters team files.
        https://api.slack.com/methods/files.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;count&#34;: count,
                &#34;page&#34;: page,
                &#34;show_files_hidden_by_limit&#34;: show_files_hidden_by_limit,
                &#34;team_id&#34;: team_id,
                &#34;ts_from&#34;: ts_from,
                &#34;ts_to&#34;: ts_to,
                &#34;user&#34;: user,
            }
        )
        if isinstance(types, (list, Tuple)):
            kwargs.update({&#34;types&#34;: &#34;,&#34;.join(types)})
        else:
            kwargs.update({&#34;types&#34;: types})
        return self.api_call(&#34;files.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def files_remote_info(
        self,
        *,
        external_id: Optional[str] = None,
        file: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieve information about a remote file added to Slack.
        https://api.slack.com/methods/files.remote.info
        &#34;&#34;&#34;
        kwargs.update({&#34;external_id&#34;: external_id, &#34;file&#34;: file})
        return self.api_call(&#34;files.remote.info&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def files_remote_list(
        self,
        *,
        channel: Optional[str] = None,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        ts_from: Optional[str] = None,
        ts_to: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieve information about a remote file added to Slack.
        https://api.slack.com/methods/files.remote.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
                &#34;ts_from&#34;: ts_from,
                &#34;ts_to&#34;: ts_to,
            }
        )
        return self.api_call(&#34;files.remote.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def files_remote_add(
        self,
        *,
        external_id: str,
        external_url: str,
        title: str,
        filetype: Optional[str] = None,
        indexable_file_contents: Optional[Union[str, bytes, IOBase]] = None,
        preview_image: Optional[Union[str, bytes, IOBase]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Adds a file from a remote service.
        https://api.slack.com/methods/files.remote.add
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;external_id&#34;: external_id,
                &#34;external_url&#34;: external_url,
                &#34;title&#34;: title,
                &#34;filetype&#34;: filetype,
            }
        )
        files = None
        # preview_image (file): Preview of the document via multipart/form-data.
        if preview_image is not None or indexable_file_contents is not None:
            files = {
                &#34;preview_image&#34;: preview_image,
                &#34;indexable_file_contents&#34;: indexable_file_contents,
            }

        return self.api_call(
            # Intentionally using &#34;POST&#34; method over &#34;GET&#34; here
            &#34;files.remote.add&#34;,
            http_verb=&#34;POST&#34;,
            data=kwargs,
            files=files,
        )

    def files_remote_update(
        self,
        *,
        external_id: Optional[str] = None,
        external_url: Optional[str] = None,
        file: Optional[str] = None,
        title: Optional[str] = None,
        filetype: Optional[str] = None,
        indexable_file_contents: Optional[str] = None,
        preview_image: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Updates an existing remote file.
        https://api.slack.com/methods/files.remote.update
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;external_id&#34;: external_id,
                &#34;external_url&#34;: external_url,
                &#34;file&#34;: file,
                &#34;title&#34;: title,
                &#34;filetype&#34;: filetype,
            }
        )
        files = None
        # preview_image (file): Preview of the document via multipart/form-data.
        if preview_image is not None or indexable_file_contents is not None:
            files = {
                &#34;preview_image&#34;: preview_image,
                &#34;indexable_file_contents&#34;: indexable_file_contents,
            }

        return self.api_call(
            # Intentionally using &#34;POST&#34; method over &#34;GET&#34; here
            &#34;files.remote.update&#34;,
            http_verb=&#34;POST&#34;,
            data=kwargs,
            files=files,
        )

    def files_remote_remove(
        self,
        *,
        external_id: Optional[str] = None,
        file: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Remove a remote file.
        https://api.slack.com/methods/files.remote.remove
        &#34;&#34;&#34;
        kwargs.update({&#34;external_id&#34;: external_id, &#34;file&#34;: file})
        return self.api_call(&#34;files.remote.remove&#34;, http_verb=&#34;POST&#34;, params=kwargs)

    def files_remote_share(
        self,
        *,
        channels: Union[str, Sequence[str]],
        external_id: Optional[str] = None,
        file: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Share a remote file into a channel.
        https://api.slack.com/methods/files.remote.share
        &#34;&#34;&#34;
        if external_id is None and file is None:
            raise e.SlackRequestError(&#34;Either external_id or file must be provided.&#34;)
        if isinstance(channels, (list, Tuple)):
            kwargs.update({&#34;channels&#34;: &#34;,&#34;.join(channels)})
        else:
            kwargs.update({&#34;channels&#34;: channels})
        kwargs.update({&#34;external_id&#34;: external_id, &#34;file&#34;: file})
        return self.api_call(&#34;files.remote.share&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def files_revokePublicURL(
        self,
        *,
        file: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Revokes public/external sharing access for a file
        https://api.slack.com/methods/files.revokePublicURL
        &#34;&#34;&#34;
        kwargs.update({&#34;file&#34;: file})
        return self.api_call(&#34;files.revokePublicURL&#34;, params=kwargs)

    def files_sharedPublicURL(
        self,
        *,
        file: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Enables a file for public/external sharing.
        https://api.slack.com/methods/files.sharedPublicURL
        &#34;&#34;&#34;
        kwargs.update({&#34;file&#34;: file})
        return self.api_call(&#34;files.sharedPublicURL&#34;, params=kwargs)

    def files_upload(
        self,
        *,
        file: Optional[Union[str, bytes, IOBase]] = None,
        content: Optional[Union[str, bytes]] = None,
        filename: Optional[str] = None,
        filetype: Optional[str] = None,
        initial_comment: Optional[str] = None,
        thread_ts: Optional[str] = None,
        title: Optional[str] = None,
        channels: Optional[Union[str, Sequence[str]]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Uploads or creates a file.
        https://api.slack.com/methods/files.upload
        &#34;&#34;&#34;
        _print_files_upload_v2_suggestion()

        if file is None and content is None:
            raise e.SlackRequestError(&#34;The file or content argument must be specified.&#34;)
        if file is not None and content is not None:
            raise e.SlackRequestError(&#34;You cannot specify both the file and the content argument.&#34;)

        if isinstance(channels, (list, Tuple)):
            kwargs.update({&#34;channels&#34;: &#34;,&#34;.join(channels)})
        else:
            kwargs.update({&#34;channels&#34;: channels})
        kwargs.update(
            {
                &#34;filename&#34;: filename,
                &#34;filetype&#34;: filetype,
                &#34;initial_comment&#34;: initial_comment,
                &#34;thread_ts&#34;: thread_ts,
                &#34;title&#34;: title,
            }
        )
        if file:
            if kwargs.get(&#34;filename&#34;) is None and isinstance(file, str):
                # use the local filename if filename is missing
                if kwargs.get(&#34;filename&#34;) is None:
                    kwargs[&#34;filename&#34;] = file.split(os.path.sep)[-1]
            return self.api_call(&#34;files.upload&#34;, files={&#34;file&#34;: file}, data=kwargs)
        else:
            kwargs[&#34;content&#34;] = content
            return self.api_call(&#34;files.upload&#34;, data=kwargs)

    def files_upload_v2(
        self,
        *,
        # for sending a single file
        filename: Optional[str] = None,  # you can skip this only when sending along with content parameter
        file: Optional[Union[str, bytes, IOBase]] = None,
        content: Optional[Union[str, bytes]] = None,
        title: Optional[str] = None,
        alt_txt: Optional[str] = None,
        snippet_type: Optional[str] = None,
        # To upload multiple files at a time
        file_uploads: Optional[List[Dict[str, Any]]] = None,
        channel: Optional[str] = None,
        initial_comment: Optional[str] = None,
        thread_ts: Optional[str] = None,
        request_file_info: bool = True,  # since v3.23, this flag is no longer necessary
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;This wrapper method provides an easy way to upload files using the following endpoints:

        - step1: https://api.slack.com/methods/files.getUploadURLExternal

        - step2: &#34;https://files.slack.com/upload/v1/...&#34; URLs returned from files.getUploadURLExternal API

        - step3: https://api.slack.com/methods/files.completeUploadExternal
            and https://api.slack.com/methods/files.info

        &#34;&#34;&#34;
        if file is None and content is None and file_uploads is None:
            raise e.SlackRequestError(&#34;Any of file, content, and file_uploads must be specified.&#34;)
        if file is not None and content is not None:
            raise e.SlackRequestError(&#34;You cannot specify both the file and the content argument.&#34;)

        # deprecated arguments:
        channels, filetype = kwargs.get(&#34;channels&#34;), kwargs.get(&#34;filetype&#34;)

        if channels is not None:
            warnings.warn(
                &#34;Although the channels parameter is still supported for smooth migration from legacy files.upload, &#34;
                &#34;we recommend using the new channel parameter with a single str value instead for more clarity.&#34;
            )
            if (isinstance(channels, (list, Tuple)) and len(channels) &gt; 1) or (
                isinstance(channels, str) and len(channels.split(&#34;,&#34;)) &gt; 1
            ):
                raise e.SlackRequestError(
                    &#34;Sharing files with multiple channels is no longer supported in v2. &#34;
                    &#34;Share files in each channel separately instead.&#34;
                )
        if filetype is not None:
            warnings.warn(&#34;The filetype parameter is no longer supported. Please remove it from the arguments.&#34;)

        # step1: files.getUploadURLExternal per file
        files: List[Dict[str, Any]] = []
        if file_uploads is not None:
            for f in file_uploads:
                files.append(_to_v2_file_upload_item(f))
        else:
            f = _to_v2_file_upload_item(
                {
                    &#34;filename&#34;: filename,
                    &#34;file&#34;: file,
                    &#34;content&#34;: content,
                    &#34;title&#34;: title,
                    &#34;alt_txt&#34;: alt_txt,
                    &#34;snippet_type&#34;: snippet_type,
                }
            )
            files.append(f)

        for f in files:
            url_response = self.files_getUploadURLExternal(
                filename=f.get(&#34;filename&#34;),
                length=f.get(&#34;length&#34;),
                alt_txt=f.get(&#34;alt_txt&#34;),
                snippet_type=f.get(&#34;snippet_type&#34;),
                token=kwargs.get(&#34;token&#34;),
            )
            _validate_for_legacy_client(url_response)
            f[&#34;file_id&#34;] = url_response.get(&#34;file_id&#34;)  # type: ignore
            f[&#34;upload_url&#34;] = url_response.get(&#34;upload_url&#34;)  # type: ignore

        # step2: &#34;https://files.slack.com/upload/v1/...&#34; per file
        for f in files:
            upload_result = _upload_file_via_v2_url(
                url=f[&#34;upload_url&#34;],
                data=f[&#34;data&#34;],
                logger=self._logger,
                timeout=self.timeout,
                proxy=self.proxy,
                ssl=self.ssl,
            )
            if upload_result.get(&#34;status&#34;) != 200:
                status = upload_result.get(&#34;status&#34;)
                body = upload_result.get(&#34;body&#34;)
                message = (
                    &#34;Failed to upload a file &#34;
                    f&#34;(status: {status}, body: {body}, filename: {f.get(&#39;filename&#39;)}, title: {f.get(&#39;title&#39;)})&#34;
                )
                raise e.SlackRequestError(message)

        # step3: files.completeUploadExternal with all the sets of (file_id + title)
        channel_to_share = channel
        if channels is not None:
            if isinstance(channels, str):
                channel_to_share = channels.split(&#34;,&#34;)[0]
            else:
                channel_to_share = channels[0]
        completion = self.files_completeUploadExternal(
            files=[{&#34;id&#34;: f[&#34;file_id&#34;], &#34;title&#34;: f[&#34;title&#34;]} for f in files],
            channel_id=channel_to_share,
            initial_comment=initial_comment,
            thread_ts=thread_ts,
            **kwargs,
        )
        if len(completion.get(&#34;files&#34;)) == 1:  # type: ignore
            completion.data[&#34;file&#34;] = completion.get(&#34;files&#34;)[0]  # type: ignore
        return completion

    def files_getUploadURLExternal(
        self,
        *,
        filename: str,
        length: int,
        alt_txt: Optional[str] = None,
        snippet_type: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Gets a URL for an edge external upload.
        https://api.slack.com/methods/files.getUploadURLExternal
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;filename&#34;: filename,
                &#34;length&#34;: length,
                &#34;alt_txt&#34;: alt_txt,
                &#34;snippet_type&#34;: snippet_type,
            }
        )
        return self.api_call(&#34;files.getUploadURLExternal&#34;, params=kwargs)

    def files_completeUploadExternal(
        self,
        *,
        files: List[Dict[str, str]],
        channel_id: Optional[str] = None,
        initial_comment: Optional[str] = None,
        thread_ts: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Finishes an upload started with files.getUploadURLExternal.
        https://api.slack.com/methods/files.completeUploadExternal
        &#34;&#34;&#34;
        _files = [{k: v for k, v in f.items() if v is not None} for f in files]
        kwargs.update(
            {
                &#34;files&#34;: json.dumps(_files),
                &#34;channel_id&#34;: channel_id,
                &#34;initial_comment&#34;: initial_comment,
                &#34;thread_ts&#34;: thread_ts,
            }
        )
        return self.api_call(&#34;files.completeUploadExternal&#34;, params=kwargs)

    def functions_completeSuccess(
        self,
        *,
        function_execution_id: str,
        outputs: Dict[str, Any],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Signal the successful completion of a function
        https://api.slack.com/methods/functions.completeSuccess
        &#34;&#34;&#34;
        kwargs.update({&#34;function_execution_id&#34;: function_execution_id, &#34;outputs&#34;: json.dumps(outputs)})
        return self.api_call(&#34;functions.completeSuccess&#34;, params=kwargs)

    def functions_completeError(
        self,
        *,
        function_execution_id: str,
        error: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Signal the failure to execute a function
        https://api.slack.com/methods/functions.completeError
        &#34;&#34;&#34;
        kwargs.update({&#34;function_execution_id&#34;: function_execution_id, &#34;error&#34;: error})
        return self.api_call(&#34;functions.completeError&#34;, params=kwargs)

    # --------------------------
    # Deprecated: groups.*
    # You can use conversations.* APIs instead.
    # https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api
    # --------------------------

    def groups_archive(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Archives a private channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;groups.archive&#34;, json=kwargs)

    def groups_create(
        self,
        *,
        name: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Creates a private channel.&#34;&#34;&#34;
        kwargs.update({&#34;name&#34;: name})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;groups.create&#34;, json=kwargs)

    def groups_createChild(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Clones and archives a private channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        return self.api_call(&#34;groups.createChild&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def groups_history(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Fetches history of messages and events from a private channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        return self.api_call(&#34;groups.history&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def groups_info(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Gets information about a private channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        return self.api_call(&#34;groups.info&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def groups_invite(
        self,
        *,
        channel: str,
        user: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Invites a user to a private channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;user&#34;: user})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;groups.invite&#34;, json=kwargs)

    def groups_kick(
        self,
        *,
        channel: str,
        user: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Removes a user from a private channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;user&#34;: user})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;groups.kick&#34;, json=kwargs)

    def groups_leave(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Leaves a private channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;groups.leave&#34;, json=kwargs)

    def groups_list(
        self,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lists private channels that the calling user has access to.&#34;&#34;&#34;
        return self.api_call(&#34;groups.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def groups_mark(
        self,
        *,
        channel: str,
        ts: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sets the read cursor in a private channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;ts&#34;: ts})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;groups.mark&#34;, json=kwargs)

    def groups_open(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Opens a private channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;groups.open&#34;, json=kwargs)

    def groups_rename(
        self,
        *,
        channel: str,
        name: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Renames a private channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;name&#34;: name})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;groups.rename&#34;, json=kwargs)

    def groups_replies(
        self,
        *,
        channel: str,
        thread_ts: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieve a thread of messages posted to a private channel&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;thread_ts&#34;: thread_ts})
        return self.api_call(&#34;groups.replies&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def groups_setPurpose(
        self,
        *,
        channel: str,
        purpose: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sets the purpose for a private channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;purpose&#34;: purpose})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;groups.setPurpose&#34;, json=kwargs)

    def groups_setTopic(
        self,
        *,
        channel: str,
        topic: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sets the topic for a private channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;topic&#34;: topic})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;groups.setTopic&#34;, json=kwargs)

    def groups_unarchive(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Unarchives a private channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;groups.unarchive&#34;, json=kwargs)

    # --------------------------
    # Deprecated: im.*
    # You can use conversations.* APIs instead.
    # https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api
    # --------------------------

    def im_close(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Close a direct message channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;im.close&#34;, json=kwargs)

    def im_history(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Fetches history of messages and events from direct message channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        return self.api_call(&#34;im.history&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def im_list(
        self,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lists direct message channels for the calling user.&#34;&#34;&#34;
        return self.api_call(&#34;im.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def im_mark(
        self,
        *,
        channel: str,
        ts: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sets the read cursor in a direct message channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;ts&#34;: ts})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;im.mark&#34;, json=kwargs)

    def im_open(
        self,
        *,
        user: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Opens a direct message channel.&#34;&#34;&#34;
        kwargs.update({&#34;user&#34;: user})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;im.open&#34;, json=kwargs)

    def im_replies(
        self,
        *,
        channel: str,
        thread_ts: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieve a thread of messages posted to a direct message conversation&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;thread_ts&#34;: thread_ts})
        return self.api_call(&#34;im.replies&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    # --------------------------

    def migration_exchange(
        self,
        *,
        users: Union[str, Sequence[str]],
        team_id: Optional[str] = None,
        to_old: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;For Enterprise Grid workspaces, map local user IDs to global user IDs
        https://api.slack.com/methods/migration.exchange
        &#34;&#34;&#34;
        if isinstance(users, (list, Tuple)):
            kwargs.update({&#34;users&#34;: &#34;,&#34;.join(users)})
        else:
            kwargs.update({&#34;users&#34;: users})
        kwargs.update({&#34;team_id&#34;: team_id, &#34;to_old&#34;: to_old})
        return self.api_call(&#34;migration.exchange&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    # --------------------------
    # Deprecated: mpim.*
    # You can use conversations.* APIs instead.
    # https://api.slack.com/changelog/2020-01-deprecating-antecedents-to-the-conversations-api
    # --------------------------

    def mpim_close(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Closes a multiparty direct message channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;mpim.close&#34;, json=kwargs)

    def mpim_history(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Fetches history of messages and events from a multiparty direct message.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        return self.api_call(&#34;mpim.history&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def mpim_list(
        self,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lists multiparty direct message channels for the calling user.&#34;&#34;&#34;
        return self.api_call(&#34;mpim.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def mpim_mark(
        self,
        *,
        channel: str,
        ts: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Sets the read cursor in a multiparty direct message channel.&#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;ts&#34;: ts})
        kwargs = _remove_none_values(kwargs)
        return self.api_call(&#34;mpim.mark&#34;, json=kwargs)

    def mpim_open(
        self,
        *,
        users: Union[str, Sequence[str]],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;This method opens a multiparty direct message.&#34;&#34;&#34;
        if isinstance(users, (list, Tuple)):
            kwargs.update({&#34;users&#34;: &#34;,&#34;.join(users)})
        else:
            kwargs.update({&#34;users&#34;: users})
        return self.api_call(&#34;mpim.open&#34;, params=kwargs)

    def mpim_replies(
        self,
        *,
        channel: str,
        thread_ts: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieve a thread of messages posted to a direct message conversation from a
        multiparty direct message.
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;thread_ts&#34;: thread_ts})
        return self.api_call(&#34;mpim.replies&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    # --------------------------

    def oauth_v2_access(
        self,
        *,
        client_id: str,
        client_secret: str,
        # This field is required when processing the OAuth redirect URL requests
        # while it&#39;s absent for token rotation
        code: Optional[str] = None,
        redirect_uri: Optional[str] = None,
        # This field is required for token rotation
        grant_type: Optional[str] = None,
        # This field is required for token rotation
        refresh_token: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Exchanges a temporary OAuth verifier code for an access token.
        https://api.slack.com/methods/oauth.v2.access
        &#34;&#34;&#34;
        if redirect_uri is not None:
            kwargs.update({&#34;redirect_uri&#34;: redirect_uri})
        if code is not None:
            kwargs.update({&#34;code&#34;: code})
        if grant_type is not None:
            kwargs.update({&#34;grant_type&#34;: grant_type})
        if refresh_token is not None:
            kwargs.update({&#34;refresh_token&#34;: refresh_token})
        return self.api_call(
            &#34;oauth.v2.access&#34;,
            data=kwargs,
            auth={&#34;client_id&#34;: client_id, &#34;client_secret&#34;: client_secret},
        )

    def oauth_access(
        self,
        *,
        client_id: str,
        client_secret: str,
        code: str,
        redirect_uri: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Exchanges a temporary OAuth verifier code for an access token.
        https://api.slack.com/methods/oauth.access
        &#34;&#34;&#34;
        if redirect_uri is not None:
            kwargs.update({&#34;redirect_uri&#34;: redirect_uri})
        kwargs.update({&#34;code&#34;: code})
        return self.api_call(
            &#34;oauth.access&#34;,
            data=kwargs,
            auth={&#34;client_id&#34;: client_id, &#34;client_secret&#34;: client_secret},
        )

    def oauth_v2_exchange(
        self,
        *,
        token: str,
        client_id: str,
        client_secret: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Exchanges a legacy access token for a new expiring access token and refresh token
        https://api.slack.com/methods/oauth.v2.exchange
        &#34;&#34;&#34;
        kwargs.update({&#34;client_id&#34;: client_id, &#34;client_secret&#34;: client_secret, &#34;token&#34;: token})
        return self.api_call(&#34;oauth.v2.exchange&#34;, params=kwargs)

    def openid_connect_token(
        self,
        client_id: str,
        client_secret: str,
        code: Optional[str] = None,
        redirect_uri: Optional[str] = None,
        grant_type: Optional[str] = None,
        refresh_token: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Exchanges a temporary OAuth verifier code for an access token for Sign in with Slack.
        https://api.slack.com/methods/openid.connect.token
        &#34;&#34;&#34;
        if redirect_uri is not None:
            kwargs.update({&#34;redirect_uri&#34;: redirect_uri})
        if code is not None:
            kwargs.update({&#34;code&#34;: code})
        if grant_type is not None:
            kwargs.update({&#34;grant_type&#34;: grant_type})
        if refresh_token is not None:
            kwargs.update({&#34;refresh_token&#34;: refresh_token})
        return self.api_call(
            &#34;openid.connect.token&#34;,
            data=kwargs,
            auth={&#34;client_id&#34;: client_id, &#34;client_secret&#34;: client_secret},
        )

    def openid_connect_userInfo(
        self,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Get the identity of a user who has authorized Sign in with Slack.
        https://api.slack.com/methods/openid.connect.userInfo
        &#34;&#34;&#34;
        return self.api_call(&#34;openid.connect.userInfo&#34;, params=kwargs)

    def pins_add(
        self,
        *,
        channel: str,
        timestamp: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Pins an item to a channel.
        https://api.slack.com/methods/pins.add
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;timestamp&#34;: timestamp})
        return self.api_call(&#34;pins.add&#34;, params=kwargs)

    def pins_list(
        self,
        *,
        channel: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lists items pinned to a channel.
        https://api.slack.com/methods/pins.list
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel})
        return self.api_call(&#34;pins.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def pins_remove(
        self,
        *,
        channel: str,
        timestamp: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Un-pins an item from a channel.
        https://api.slack.com/methods/pins.remove
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;timestamp&#34;: timestamp})
        return self.api_call(&#34;pins.remove&#34;, params=kwargs)

    def reactions_add(
        self,
        *,
        channel: str,
        name: str,
        timestamp: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Adds a reaction to an item.
        https://api.slack.com/methods/reactions.add
        &#34;&#34;&#34;
        kwargs.update({&#34;channel&#34;: channel, &#34;name&#34;: name, &#34;timestamp&#34;: timestamp})
        return self.api_call(&#34;reactions.add&#34;, params=kwargs)

    def reactions_get(
        self,
        *,
        channel: Optional[str] = None,
        file: Optional[str] = None,
        file_comment: Optional[str] = None,
        full: Optional[bool] = None,
        timestamp: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Gets reactions for an item.
        https://api.slack.com/methods/reactions.get
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;file&#34;: file,
                &#34;file_comment&#34;: file_comment,
                &#34;full&#34;: full,
                &#34;timestamp&#34;: timestamp,
            }
        )
        return self.api_call(&#34;reactions.get&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def reactions_list(
        self,
        *,
        count: Optional[int] = None,
        cursor: Optional[str] = None,
        full: Optional[bool] = None,
        limit: Optional[int] = None,
        page: Optional[int] = None,
        team_id: Optional[str] = None,
        user: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lists reactions made by a user.
        https://api.slack.com/methods/reactions.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;count&#34;: count,
                &#34;cursor&#34;: cursor,
                &#34;full&#34;: full,
                &#34;limit&#34;: limit,
                &#34;page&#34;: page,
                &#34;team_id&#34;: team_id,
                &#34;user&#34;: user,
            }
        )
        return self.api_call(&#34;reactions.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def reactions_remove(
        self,
        *,
        name: str,
        channel: Optional[str] = None,
        file: Optional[str] = None,
        file_comment: Optional[str] = None,
        timestamp: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Removes a reaction from an item.
        https://api.slack.com/methods/reactions.remove
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;name&#34;: name,
                &#34;channel&#34;: channel,
                &#34;file&#34;: file,
                &#34;file_comment&#34;: file_comment,
                &#34;timestamp&#34;: timestamp,
            }
        )
        return self.api_call(&#34;reactions.remove&#34;, params=kwargs)

    def reminders_add(
        self,
        *,
        text: str,
        time: str,
        team_id: Optional[str] = None,
        user: Optional[str] = None,
        recurrence: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Creates a reminder.
        https://api.slack.com/methods/reminders.add
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;text&#34;: text,
                &#34;time&#34;: time,
                &#34;team_id&#34;: team_id,
                &#34;user&#34;: user,
                &#34;recurrence&#34;: recurrence,
            }
        )
        return self.api_call(&#34;reminders.add&#34;, params=kwargs)

    def reminders_complete(
        self,
        *,
        reminder: str,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Marks a reminder as complete.
        https://api.slack.com/methods/reminders.complete
        &#34;&#34;&#34;
        kwargs.update({&#34;reminder&#34;: reminder, &#34;team_id&#34;: team_id})
        return self.api_call(&#34;reminders.complete&#34;, params=kwargs)

    def reminders_delete(
        self,
        *,
        reminder: str,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Deletes a reminder.
        https://api.slack.com/methods/reminders.delete
        &#34;&#34;&#34;
        kwargs.update({&#34;reminder&#34;: reminder, &#34;team_id&#34;: team_id})
        return self.api_call(&#34;reminders.delete&#34;, params=kwargs)

    def reminders_info(
        self,
        *,
        reminder: str,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Gets information about a reminder.
        https://api.slack.com/methods/reminders.info
        &#34;&#34;&#34;
        kwargs.update({&#34;reminder&#34;: reminder, &#34;team_id&#34;: team_id})
        return self.api_call(&#34;reminders.info&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def reminders_list(
        self,
        *,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lists all reminders created by or for a given user.
        https://api.slack.com/methods/reminders.list
        &#34;&#34;&#34;
        kwargs.update({&#34;team_id&#34;: team_id})
        return self.api_call(&#34;reminders.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def rtm_connect(
        self,
        *,
        batch_presence_aware: Optional[bool] = None,
        presence_sub: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Starts a Real Time Messaging session.
        https://api.slack.com/methods/rtm.connect
        &#34;&#34;&#34;
        kwargs.update({&#34;batch_presence_aware&#34;: batch_presence_aware, &#34;presence_sub&#34;: presence_sub})
        return self.api_call(&#34;rtm.connect&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def rtm_start(
        self,
        *,
        batch_presence_aware: Optional[bool] = None,
        include_locale: Optional[bool] = None,
        mpim_aware: Optional[bool] = None,
        no_latest: Optional[bool] = None,
        no_unreads: Optional[bool] = None,
        presence_sub: Optional[bool] = None,
        simple_latest: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Starts a Real Time Messaging session.
        https://api.slack.com/methods/rtm.start
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;batch_presence_aware&#34;: batch_presence_aware,
                &#34;include_locale&#34;: include_locale,
                &#34;mpim_aware&#34;: mpim_aware,
                &#34;no_latest&#34;: no_latest,
                &#34;no_unreads&#34;: no_unreads,
                &#34;presence_sub&#34;: presence_sub,
                &#34;simple_latest&#34;: simple_latest,
            }
        )
        return self.api_call(&#34;rtm.start&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def search_all(
        self,
        *,
        query: str,
        count: Optional[int] = None,
        highlight: Optional[bool] = None,
        page: Optional[int] = None,
        sort: Optional[str] = None,
        sort_dir: Optional[str] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Searches for messages and files matching a query.
        https://api.slack.com/methods/search.all
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;query&#34;: query,
                &#34;count&#34;: count,
                &#34;highlight&#34;: highlight,
                &#34;page&#34;: page,
                &#34;sort&#34;: sort,
                &#34;sort_dir&#34;: sort_dir,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;search.all&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def search_files(
        self,
        *,
        query: str,
        count: Optional[int] = None,
        highlight: Optional[bool] = None,
        page: Optional[int] = None,
        sort: Optional[str] = None,
        sort_dir: Optional[str] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Searches for files matching a query.
        https://api.slack.com/methods/search.files
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;query&#34;: query,
                &#34;count&#34;: count,
                &#34;highlight&#34;: highlight,
                &#34;page&#34;: page,
                &#34;sort&#34;: sort,
                &#34;sort_dir&#34;: sort_dir,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;search.files&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def search_messages(
        self,
        *,
        query: str,
        count: Optional[int] = None,
        cursor: Optional[str] = None,
        highlight: Optional[bool] = None,
        page: Optional[int] = None,
        sort: Optional[str] = None,
        sort_dir: Optional[str] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Searches for messages matching a query.
        https://api.slack.com/methods/search.messages
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;query&#34;: query,
                &#34;count&#34;: count,
                &#34;cursor&#34;: cursor,
                &#34;highlight&#34;: highlight,
                &#34;page&#34;: page,
                &#34;sort&#34;: sort,
                &#34;sort_dir&#34;: sort_dir,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;search.messages&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def stars_add(
        self,
        *,
        channel: Optional[str] = None,
        file: Optional[str] = None,
        file_comment: Optional[str] = None,
        timestamp: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Adds a star to an item.
        https://api.slack.com/methods/stars.add
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;file&#34;: file,
                &#34;file_comment&#34;: file_comment,
                &#34;timestamp&#34;: timestamp,
            }
        )
        return self.api_call(&#34;stars.add&#34;, params=kwargs)

    def stars_list(
        self,
        *,
        count: Optional[int] = None,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        page: Optional[int] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lists stars for a user.
        https://api.slack.com/methods/stars.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;count&#34;: count,
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
                &#34;page&#34;: page,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;stars.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def stars_remove(
        self,
        *,
        channel: Optional[str] = None,
        file: Optional[str] = None,
        file_comment: Optional[str] = None,
        timestamp: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Removes a star from an item.
        https://api.slack.com/methods/stars.remove
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;channel&#34;: channel,
                &#34;file&#34;: file,
                &#34;file_comment&#34;: file_comment,
                &#34;timestamp&#34;: timestamp,
            }
        )
        return self.api_call(&#34;stars.remove&#34;, params=kwargs)

    def team_accessLogs(
        self,
        *,
        before: Optional[Union[int, str]] = None,
        count: Optional[Union[int, str]] = None,
        page: Optional[Union[int, str]] = None,
        team_id: Optional[str] = None,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Gets the access logs for the current team.
        https://api.slack.com/methods/team.accessLogs
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;before&#34;: before,
                &#34;count&#34;: count,
                &#34;page&#34;: page,
                &#34;team_id&#34;: team_id,
                &#34;cursor&#34;: cursor,
                &#34;limit&#34;: limit,
            }
        )
        return self.api_call(&#34;team.accessLogs&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def team_billableInfo(
        self,
        *,
        team_id: Optional[str] = None,
        user: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Gets billable users information for the current team.
        https://api.slack.com/methods/team.billableInfo
        &#34;&#34;&#34;
        kwargs.update({&#34;team_id&#34;: team_id, &#34;user&#34;: user})
        return self.api_call(&#34;team.billableInfo&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def team_billing_info(
        self,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Reads a workspace&#39;s billing plan information.
        https://api.slack.com/methods/team.billing.info
        &#34;&#34;&#34;
        return self.api_call(&#34;team.billing.info&#34;, params=kwargs)

    def team_info(
        self,
        *,
        team: Optional[str] = None,
        domain: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Gets information about the current team.
        https://api.slack.com/methods/team.info
        &#34;&#34;&#34;
        kwargs.update({&#34;team&#34;: team, &#34;domain&#34;: domain})
        return self.api_call(&#34;team.info&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def team_integrationLogs(
        self,
        *,
        app_id: Optional[str] = None,
        change_type: Optional[str] = None,
        count: Optional[Union[int, str]] = None,
        page: Optional[Union[int, str]] = None,
        service_id: Optional[str] = None,
        team_id: Optional[str] = None,
        user: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Gets the integration logs for the current team.
        https://api.slack.com/methods/team.integrationLogs
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;app_id&#34;: app_id,
                &#34;change_type&#34;: change_type,
                &#34;count&#34;: count,
                &#34;page&#34;: page,
                &#34;service_id&#34;: service_id,
                &#34;team_id&#34;: team_id,
                &#34;user&#34;: user,
            }
        )
        return self.api_call(&#34;team.integrationLogs&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def team_profile_get(
        self,
        *,
        visibility: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieve a team&#39;s profile.
        https://api.slack.com/methods/team.profile.get
        &#34;&#34;&#34;
        kwargs.update({&#34;visibility&#34;: visibility})
        return self.api_call(&#34;team.profile.get&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def team_preferences_list(
        self,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieve a list of a workspace&#39;s team preferences.
        https://api.slack.com/methods/team.preferences.list
        &#34;&#34;&#34;
        return self.api_call(&#34;team.preferences.list&#34;, params=kwargs)

    def usergroups_create(
        self,
        *,
        name: str,
        channels: Optional[Union[str, Sequence[str]]] = None,
        description: Optional[str] = None,
        handle: Optional[str] = None,
        include_count: Optional[bool] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Create a User Group
        https://api.slack.com/methods/usergroups.create
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;name&#34;: name,
                &#34;description&#34;: description,
                &#34;handle&#34;: handle,
                &#34;include_count&#34;: include_count,
                &#34;team_id&#34;: team_id,
            }
        )
        if isinstance(channels, (list, Tuple)):
            kwargs.update({&#34;channels&#34;: &#34;,&#34;.join(channels)})
        else:
            kwargs.update({&#34;channels&#34;: channels})
        return self.api_call(&#34;usergroups.create&#34;, params=kwargs)

    def usergroups_disable(
        self,
        *,
        usergroup: str,
        include_count: Optional[bool] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Disable an existing User Group
        https://api.slack.com/methods/usergroups.disable
        &#34;&#34;&#34;
        kwargs.update({&#34;usergroup&#34;: usergroup, &#34;include_count&#34;: include_count, &#34;team_id&#34;: team_id})
        return self.api_call(&#34;usergroups.disable&#34;, params=kwargs)

    def usergroups_enable(
        self,
        *,
        usergroup: str,
        include_count: Optional[bool] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Enable a User Group
        https://api.slack.com/methods/usergroups.enable
        &#34;&#34;&#34;
        kwargs.update({&#34;usergroup&#34;: usergroup, &#34;include_count&#34;: include_count, &#34;team_id&#34;: team_id})
        return self.api_call(&#34;usergroups.enable&#34;, params=kwargs)

    def usergroups_list(
        self,
        *,
        include_count: Optional[bool] = None,
        include_disabled: Optional[bool] = None,
        include_users: Optional[bool] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List all User Groups for a team
        https://api.slack.com/methods/usergroups.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;include_count&#34;: include_count,
                &#34;include_disabled&#34;: include_disabled,
                &#34;include_users&#34;: include_users,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;usergroups.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def usergroups_update(
        self,
        *,
        usergroup: str,
        channels: Optional[Union[str, Sequence[str]]] = None,
        description: Optional[str] = None,
        handle: Optional[str] = None,
        include_count: Optional[bool] = None,
        name: Optional[str] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Update an existing User Group
        https://api.slack.com/methods/usergroups.update
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;usergroup&#34;: usergroup,
                &#34;description&#34;: description,
                &#34;handle&#34;: handle,
                &#34;include_count&#34;: include_count,
                &#34;name&#34;: name,
                &#34;team_id&#34;: team_id,
            }
        )
        if isinstance(channels, (list, Tuple)):
            kwargs.update({&#34;channels&#34;: &#34;,&#34;.join(channels)})
        else:
            kwargs.update({&#34;channels&#34;: channels})
        return self.api_call(&#34;usergroups.update&#34;, params=kwargs)

    def usergroups_users_list(
        self,
        *,
        usergroup: str,
        include_disabled: Optional[bool] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List all users in a User Group
        https://api.slack.com/methods/usergroups.users.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;usergroup&#34;: usergroup,
                &#34;include_disabled&#34;: include_disabled,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;usergroups.users.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def usergroups_users_update(
        self,
        *,
        usergroup: str,
        users: Union[str, Sequence[str]],
        include_count: Optional[bool] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Update the list of users for a User Group
        https://api.slack.com/methods/usergroups.users.update
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;usergroup&#34;: usergroup,
                &#34;include_count&#34;: include_count,
                &#34;team_id&#34;: team_id,
            }
        )
        if isinstance(users, (list, Tuple)):
            kwargs.update({&#34;users&#34;: &#34;,&#34;.join(users)})
        else:
            kwargs.update({&#34;users&#34;: users})
        return self.api_call(&#34;usergroups.users.update&#34;, params=kwargs)

    def users_conversations(
        self,
        *,
        cursor: Optional[str] = None,
        exclude_archived: Optional[bool] = None,
        limit: Optional[int] = None,
        team_id: Optional[str] = None,
        types: Optional[Union[str, Sequence[str]]] = None,
        user: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;List conversations the calling user may access.
        https://api.slack.com/methods/users.conversations
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;cursor&#34;: cursor,
                &#34;exclude_archived&#34;: exclude_archived,
                &#34;limit&#34;: limit,
                &#34;team_id&#34;: team_id,
                &#34;user&#34;: user,
            }
        )
        if isinstance(types, (list, Tuple)):
            kwargs.update({&#34;types&#34;: &#34;,&#34;.join(types)})
        else:
            kwargs.update({&#34;types&#34;: types})
        return self.api_call(&#34;users.conversations&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def users_deletePhoto(
        self,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Delete the user profile photo
        https://api.slack.com/methods/users.deletePhoto
        &#34;&#34;&#34;
        return self.api_call(&#34;users.deletePhoto&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def users_getPresence(
        self,
        *,
        user: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Gets user presence information.
        https://api.slack.com/methods/users.getPresence
        &#34;&#34;&#34;
        kwargs.update({&#34;user&#34;: user})
        return self.api_call(&#34;users.getPresence&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def users_identity(
        self,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Get a user&#39;s identity.
        https://api.slack.com/methods/users.identity
        &#34;&#34;&#34;
        return self.api_call(&#34;users.identity&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def users_info(
        self,
        *,
        user: str,
        include_locale: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Gets information about a user.
        https://api.slack.com/methods/users.info
        &#34;&#34;&#34;
        kwargs.update({&#34;user&#34;: user, &#34;include_locale&#34;: include_locale})
        return self.api_call(&#34;users.info&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def users_list(
        self,
        *,
        cursor: Optional[str] = None,
        include_locale: Optional[bool] = None,
        limit: Optional[int] = None,
        team_id: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Lists all users in a Slack team.
        https://api.slack.com/methods/users.list
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;cursor&#34;: cursor,
                &#34;include_locale&#34;: include_locale,
                &#34;limit&#34;: limit,
                &#34;team_id&#34;: team_id,
            }
        )
        return self.api_call(&#34;users.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def users_lookupByEmail(
        self,
        *,
        email: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Find a user with an email address.
        https://api.slack.com/methods/users.lookupByEmail
        &#34;&#34;&#34;
        kwargs.update({&#34;email&#34;: email})
        return self.api_call(&#34;users.lookupByEmail&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def users_setPhoto(
        self,
        *,
        image: Union[str, IOBase],
        crop_w: Optional[Union[int, str]] = None,
        crop_x: Optional[Union[int, str]] = None,
        crop_y: Optional[Union[int, str]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Set the user profile photo
        https://api.slack.com/methods/users.setPhoto
        &#34;&#34;&#34;
        kwargs.update({&#34;crop_w&#34;: crop_w, &#34;crop_x&#34;: crop_x, &#34;crop_y&#34;: crop_y})
        return self.api_call(&#34;users.setPhoto&#34;, files={&#34;image&#34;: image}, data=kwargs)

    def users_setPresence(
        self,
        *,
        presence: str,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Manually sets user presence.
        https://api.slack.com/methods/users.setPresence
        &#34;&#34;&#34;
        kwargs.update({&#34;presence&#34;: presence})
        return self.api_call(&#34;users.setPresence&#34;, params=kwargs)

    def users_profile_get(
        self,
        *,
        user: Optional[str] = None,
        include_labels: Optional[bool] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Retrieves a user&#39;s profile information.
        https://api.slack.com/methods/users.profile.get
        &#34;&#34;&#34;
        kwargs.update({&#34;user&#34;: user, &#34;include_labels&#34;: include_labels})
        return self.api_call(&#34;users.profile.get&#34;, http_verb=&#34;GET&#34;, params=kwargs)

    def users_profile_set(
        self,
        *,
        name: Optional[str] = None,
        value: Optional[str] = None,
        user: Optional[str] = None,
        profile: Optional[Dict] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Set the profile information for a user.
        https://api.slack.com/methods/users.profile.set
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;name&#34;: name,
                &#34;profile&#34;: profile,
                &#34;user&#34;: user,
                &#34;value&#34;: value,
            }
        )
        kwargs = _remove_none_values(kwargs)
        # NOTE: Intentionally using json for the &#34;profile&#34; parameter
        return self.api_call(&#34;users.profile.set&#34;, json=kwargs)

    def views_open(
        self,
        *,
        trigger_id: str,
        view: Union[dict, View],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Open a view for a user.
        https://api.slack.com/methods/views.open
        See https://api.slack.com/block-kit/surfaces/modals for details.
        &#34;&#34;&#34;
        kwargs.update({&#34;trigger_id&#34;: trigger_id})
        if isinstance(view, View):
            kwargs.update({&#34;view&#34;: view.to_dict()})
        else:
            kwargs.update({&#34;view&#34;: view})
        kwargs = _remove_none_values(kwargs)
        # NOTE: Intentionally using json for the &#34;view&#34; parameter
        return self.api_call(&#34;views.open&#34;, json=kwargs)

    def views_push(
        self,
        *,
        trigger_id: str,
        view: Union[dict, View],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Push a view onto the stack of a root view.
        Push a new view onto the existing view stack by passing a view
        payload and a valid trigger_id generated from an interaction
        within the existing modal.
        Read the modals documentation (https://api.slack.com/block-kit/surfaces/modals)
        to learn more about the lifecycle and intricacies of views.
        https://api.slack.com/methods/views.push
        &#34;&#34;&#34;
        kwargs.update({&#34;trigger_id&#34;: trigger_id})
        if isinstance(view, View):
            kwargs.update({&#34;view&#34;: view.to_dict()})
        else:
            kwargs.update({&#34;view&#34;: view})
        kwargs = _remove_none_values(kwargs)
        # NOTE: Intentionally using json for the &#34;view&#34; parameter
        return self.api_call(&#34;views.push&#34;, json=kwargs)

    def views_update(
        self,
        *,
        view: Union[dict, View],
        external_id: Optional[str] = None,
        view_id: Optional[str] = None,
        hash: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Update an existing view.
        Update a view by passing a new view definition along with the
        view_id returned in views.open or the external_id.
        See the modals documentation (https://api.slack.com/block-kit/surfaces/modals#updating_views)
        to learn more about updating views and avoiding race conditions with the hash argument.
        https://api.slack.com/methods/views.update
        &#34;&#34;&#34;
        if isinstance(view, View):
            kwargs.update({&#34;view&#34;: view.to_dict()})
        else:
            kwargs.update({&#34;view&#34;: view})
        if external_id:
            kwargs.update({&#34;external_id&#34;: external_id})
        elif view_id:
            kwargs.update({&#34;view_id&#34;: view_id})
        else:
            raise e.SlackRequestError(&#34;Either view_id or external_id is required.&#34;)
        kwargs.update({&#34;hash&#34;: hash})
        kwargs = _remove_none_values(kwargs)
        # NOTE: Intentionally using json for the &#34;view&#34; parameter
        return self.api_call(&#34;views.update&#34;, json=kwargs)

    def views_publish(
        self,
        *,
        user_id: str,
        view: Union[dict, View],
        hash: Optional[str] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Publish a static view for a User.
        Create or update the view that comprises an
        app&#39;s Home tab (https://api.slack.com/surfaces/tabs)
        https://api.slack.com/methods/views.publish
        &#34;&#34;&#34;
        kwargs.update({&#34;user_id&#34;: user_id, &#34;hash&#34;: hash})
        if isinstance(view, View):
            kwargs.update({&#34;view&#34;: view.to_dict()})
        else:
            kwargs.update({&#34;view&#34;: view})
        kwargs = _remove_none_values(kwargs)
        # NOTE: Intentionally using json for the &#34;view&#34; parameter
        return self.api_call(&#34;views.publish&#34;, json=kwargs)

    def workflows_stepCompleted(
        self,
        *,
        workflow_step_execute_id: str,
        outputs: Optional[dict] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Indicate a successful outcome of a workflow step&#39;s execution.
        https://api.slack.com/methods/workflows.stepCompleted
        &#34;&#34;&#34;
        kwargs.update({&#34;workflow_step_execute_id&#34;: workflow_step_execute_id})
        if outputs is not None:
            kwargs.update({&#34;outputs&#34;: outputs})
        kwargs = _remove_none_values(kwargs)
        # NOTE: Intentionally using json for the &#34;outputs&#34; parameter
        return self.api_call(&#34;workflows.stepCompleted&#34;, json=kwargs)

    def workflows_stepFailed(
        self,
        *,
        workflow_step_execute_id: str,
        error: Dict[str, str],
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Indicate an unsuccessful outcome of a workflow step&#39;s execution.
        https://api.slack.com/methods/workflows.stepFailed
        &#34;&#34;&#34;
        kwargs.update(
            {
                &#34;workflow_step_execute_id&#34;: workflow_step_execute_id,
                &#34;error&#34;: error,
            }
        )
        kwargs = _remove_none_values(kwargs)
        # NOTE: Intentionally using json for the &#34;error&#34; parameter
        return self.api_call(&#34;workflows.stepFailed&#34;, json=kwargs)

    def workflows_updateStep(
        self,
        *,
        workflow_step_edit_id: str,
        inputs: Optional[Dict[str, Any]] = None,
        outputs: Optional[List[Dict[str, str]]] = None,
        **kwargs,
    ) -&gt; Union[Future, SlackResponse]:
        &#34;&#34;&#34;Update the configuration for a workflow extension step.
        https://api.slack.com/methods/workflows.updateStep
        &#34;&#34;&#34;
        kwargs.update({&#34;workflow_step_edit_id&#34;: workflow_step_edit_id})
        if inputs is not None:
            kwargs.update({&#34;inputs&#34;: inputs})
        if outputs is not None:
            kwargs.update({&#34;outputs&#34;: outputs})
        kwargs = _remove_none_values(kwargs)
        # NOTE: Intentionally using json for the &#34;inputs&#34; / &#34;outputs&#34; parameters
        return self.api_call(&#34;workflows.updateStep&#34;, json=kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="slack_sdk.web.legacy_base_client.LegacyBaseClient" href="legacy_base_client.html#slack_sdk.web.legacy_base_client.LegacyBaseClient">LegacyBaseClient</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_analytics_getFile"><code class="name flex">
<span>def <span class="ident">admin_analytics_getFile</span></span>(<span>self, *, type: str, date: Optional[str] = None, metadata_only: Optional[bool] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve analytics data for a given date, presented as a compressed JSON file
<a href="https://api.slack.com/methods/admin.analytics.getFile">https://api.slack.com/methods/admin.analytics.getFile</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_analytics_getFile(
    self,
    *,
    type: str,
    date: Optional[str] = None,
    metadata_only: Optional[bool] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Retrieve analytics data for a given date, presented as a compressed JSON file
    https://api.slack.com/methods/admin.analytics.getFile
    &#34;&#34;&#34;
    kwargs.update({&#34;type&#34;: type})
    if date is not None:
        kwargs.update({&#34;date&#34;: date})
    if metadata_only is not None:
        kwargs.update({&#34;metadata_only&#34;: metadata_only})
    return self.api_call(&#34;admin.analytics.getFile&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_activities_list"><code class="name flex">
<span>def <span class="ident">admin_apps_activities_list</span></span>(<span>self, *, app_id: Optional[str] = None, component_id: Optional[str] = None, component_type: Optional[str] = None, log_event_type: Optional[str] = None, max_date_created: Optional[int] = None, min_date_created: Optional[int] = None, min_log_level: Optional[str] = None, sort_direction: Optional[str] = None, source: Optional[str] = None, team_id: Optional[str] = None, trace_id: Optional[str] = None, cursor: Optional[str] = None, limit: Optional[int] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get logs for a specified team/org
<a href="https://api.slack.com/methods/admin.apps.activities.list">https://api.slack.com/methods/admin.apps.activities.list</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_apps_activities_list(
    self,
    *,
    app_id: Optional[str] = None,
    component_id: Optional[str] = None,
    component_type: Optional[str] = None,
    log_event_type: Optional[str] = None,
    max_date_created: Optional[int] = None,
    min_date_created: Optional[int] = None,
    min_log_level: Optional[str] = None,
    sort_direction: Optional[str] = None,
    source: Optional[str] = None,
    team_id: Optional[str] = None,
    trace_id: Optional[str] = None,
    cursor: Optional[str] = None,
    limit: Optional[int] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Get logs for a specified team/org
    https://api.slack.com/methods/admin.apps.activities.list
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;app_id&#34;: app_id,
            &#34;component_id&#34;: component_id,
            &#34;component_type&#34;: component_type,
            &#34;log_event_type&#34;: log_event_type,
            &#34;max_date_created&#34;: max_date_created,
            &#34;min_date_created&#34;: min_date_created,
            &#34;min_log_level&#34;: min_log_level,
            &#34;sort_direction&#34;: sort_direction,
            &#34;source&#34;: source,
            &#34;team_id&#34;: team_id,
            &#34;trace_id&#34;: trace_id,
            &#34;cursor&#34;: cursor,
            &#34;limit&#34;: limit,
        }
    )
    return self.api_call(&#34;admin.apps.activities.list&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_approve"><code class="name flex">
<span>def <span class="ident">admin_apps_approve</span></span>(<span>self, *, app_id: Optional[str] = None, request_id: Optional[str] = None, enterprise_id: Optional[str] = None, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Approve an app for installation on a workspace.
Either app_id or request_id is required.
These IDs can be obtained either directly via the app_requested event,
or by the admin.apps.requests.list method.
<a href="https://api.slack.com/methods/admin.apps.approve">https://api.slack.com/methods/admin.apps.approve</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_apps_approve(
    self,
    *,
    app_id: Optional[str] = None,
    request_id: Optional[str] = None,
    enterprise_id: Optional[str] = None,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Approve an app for installation on a workspace.
    Either app_id or request_id is required.
    These IDs can be obtained either directly via the app_requested event,
    or by the admin.apps.requests.list method.
    https://api.slack.com/methods/admin.apps.approve
    &#34;&#34;&#34;
    if app_id:
        kwargs.update({&#34;app_id&#34;: app_id})
    elif request_id:
        kwargs.update({&#34;request_id&#34;: request_id})
    else:
        raise e.SlackRequestError(&#34;The app_id or request_id argument must be specified.&#34;)

    kwargs.update(
        {
            &#34;enterprise_id&#34;: enterprise_id,
            &#34;team_id&#34;: team_id,
        }
    )
    return self.api_call(&#34;admin.apps.approve&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_approved_list"><code class="name flex">
<span>def <span class="ident">admin_apps_approved_list</span></span>(<span>self, *, cursor: Optional[str] = None, limit: Optional[int] = None, enterprise_id: Optional[str] = None, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>List approved apps for an org or workspace.
<a href="https://api.slack.com/methods/admin.apps.approved.list">https://api.slack.com/methods/admin.apps.approved.list</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_apps_approved_list(
    self,
    *,
    cursor: Optional[str] = None,
    limit: Optional[int] = None,
    enterprise_id: Optional[str] = None,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;List approved apps for an org or workspace.
    https://api.slack.com/methods/admin.apps.approved.list
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;cursor&#34;: cursor,
            &#34;limit&#34;: limit,
            &#34;enterprise_id&#34;: enterprise_id,
            &#34;team_id&#34;: team_id,
        }
    )
    return self.api_call(&#34;admin.apps.approved.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_clearResolution"><code class="name flex">
<span>def <span class="ident">admin_apps_clearResolution</span></span>(<span>self, *, app_id: str, enterprise_id: Optional[str] = None, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Clear an app resolution
<a href="https://api.slack.com/methods/admin.apps.clearResolution">https://api.slack.com/methods/admin.apps.clearResolution</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_apps_clearResolution(
    self,
    *,
    app_id: str,
    enterprise_id: Optional[str] = None,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Clear an app resolution
    https://api.slack.com/methods/admin.apps.clearResolution
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;app_id&#34;: app_id,
            &#34;enterprise_id&#34;: enterprise_id,
            &#34;team_id&#34;: team_id,
        }
    )
    return self.api_call(&#34;admin.apps.clearResolution&#34;, http_verb=&#34;POST&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_config_lookup"><code class="name flex">
<span>def <span class="ident">admin_apps_config_lookup</span></span>(<span>self, *, app_ids: Union[str, Sequence[str]], **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Look up the app config for connectors by their IDs
<a href="https://api.slack.com/methods/admin.apps.config.lookup">https://api.slack.com/methods/admin.apps.config.lookup</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_apps_config_lookup(
    self,
    *,
    app_ids: Union[str, Sequence[str]],
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Look up the app config for connectors by their IDs
    https://api.slack.com/methods/admin.apps.config.lookup
    &#34;&#34;&#34;
    if isinstance(app_ids, (list, Tuple)):
        kwargs.update({&#34;app_ids&#34;: &#34;,&#34;.join(app_ids)})
    else:
        kwargs.update({&#34;app_ids&#34;: app_ids})
    return self.api_call(&#34;admin.apps.config.lookup&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_config_set"><code class="name flex">
<span>def <span class="ident">admin_apps_config_set</span></span>(<span>self, *, app_id: str, domain_restrictions: Optional[Dict[str, Any]] = None, workflow_auth_strategy: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Set the app config for a connector
<a href="https://api.slack.com/methods/admin.apps.config.set">https://api.slack.com/methods/admin.apps.config.set</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_apps_config_set(
    self,
    *,
    app_id: str,
    domain_restrictions: Optional[Dict[str, Any]] = None,
    workflow_auth_strategy: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Set the app config for a connector
    https://api.slack.com/methods/admin.apps.config.set
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;app_id&#34;: app_id,
            &#34;workflow_auth_strategy&#34;: workflow_auth_strategy,
        }
    )
    if domain_restrictions is not None:
        kwargs.update({&#34;domain_restrictions&#34;: json.dumps(domain_restrictions)})
    return self.api_call(&#34;admin.apps.config.set&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_requests_cancel"><code class="name flex">
<span>def <span class="ident">admin_apps_requests_cancel</span></span>(<span>self, *, request_id: str, enterprise_id: Optional[str] = None, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>List app requests for a team/workspace.
<a href="https://api.slack.com/methods/admin.apps.requests.cancel">https://api.slack.com/methods/admin.apps.requests.cancel</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_apps_requests_cancel(
    self,
    *,
    request_id: str,
    enterprise_id: Optional[str] = None,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;List app requests for a team/workspace.
    https://api.slack.com/methods/admin.apps.requests.cancel
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;request_id&#34;: request_id,
            &#34;enterprise_id&#34;: enterprise_id,
            &#34;team_id&#34;: team_id,
        }
    )
    return self.api_call(&#34;admin.apps.requests.cancel&#34;, http_verb=&#34;POST&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_requests_list"><code class="name flex">
<span>def <span class="ident">admin_apps_requests_list</span></span>(<span>self, *, cursor: Optional[str] = None, limit: Optional[int] = None, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>List app requests for a team/workspace.
<a href="https://api.slack.com/methods/admin.apps.requests.list">https://api.slack.com/methods/admin.apps.requests.list</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_apps_requests_list(
    self,
    *,
    cursor: Optional[str] = None,
    limit: Optional[int] = None,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;List app requests for a team/workspace.
    https://api.slack.com/methods/admin.apps.requests.list
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;cursor&#34;: cursor,
            &#34;limit&#34;: limit,
            &#34;team_id&#34;: team_id,
        }
    )
    return self.api_call(&#34;admin.apps.requests.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_restrict"><code class="name flex">
<span>def <span class="ident">admin_apps_restrict</span></span>(<span>self, *, app_id: Optional[str] = None, request_id: Optional[str] = None, enterprise_id: Optional[str] = None, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Restrict an app for installation on a workspace.
Exactly one of the team_id or enterprise_id arguments is required, not both.
Either app_id or request_id is required. These IDs can be obtained either directly
via the app_requested event, or by the admin.apps.requests.list method.
<a href="https://api.slack.com/methods/admin.apps.restrict">https://api.slack.com/methods/admin.apps.restrict</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_apps_restrict(
    self,
    *,
    app_id: Optional[str] = None,
    request_id: Optional[str] = None,
    enterprise_id: Optional[str] = None,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Restrict an app for installation on a workspace.
    Exactly one of the team_id or enterprise_id arguments is required, not both.
    Either app_id or request_id is required. These IDs can be obtained either directly
    via the app_requested event, or by the admin.apps.requests.list method.
    https://api.slack.com/methods/admin.apps.restrict
    &#34;&#34;&#34;
    if app_id:
        kwargs.update({&#34;app_id&#34;: app_id})
    elif request_id:
        kwargs.update({&#34;request_id&#34;: request_id})
    else:
        raise e.SlackRequestError(&#34;The app_id or request_id argument must be specified.&#34;)

    kwargs.update(
        {
            &#34;enterprise_id&#34;: enterprise_id,
            &#34;team_id&#34;: team_id,
        }
    )
    return self.api_call(&#34;admin.apps.restrict&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_restricted_list"><code class="name flex">
<span>def <span class="ident">admin_apps_restricted_list</span></span>(<span>self, *, cursor: Optional[str] = None, limit: Optional[int] = None, enterprise_id: Optional[str] = None, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>List restricted apps for an org or workspace.
<a href="https://api.slack.com/methods/admin.apps.restricted.list">https://api.slack.com/methods/admin.apps.restricted.list</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_apps_restricted_list(
    self,
    *,
    cursor: Optional[str] = None,
    limit: Optional[int] = None,
    enterprise_id: Optional[str] = None,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;List restricted apps for an org or workspace.
    https://api.slack.com/methods/admin.apps.restricted.list
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;cursor&#34;: cursor,
            &#34;limit&#34;: limit,
            &#34;enterprise_id&#34;: enterprise_id,
            &#34;team_id&#34;: team_id,
        }
    )
    return self.api_call(&#34;admin.apps.restricted.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_uninstall"><code class="name flex">
<span>def <span class="ident">admin_apps_uninstall</span></span>(<span>self, *, app_id: str, enterprise_id: Optional[str] = None, team_ids: Union[str, Sequence[str], ForwardRef(None)] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Uninstall an app from one or many workspaces, or an entire enterprise organization.
With an org-level token, enterprise_id or team_ids is required.
<a href="https://api.slack.com/methods/admin.apps.uninstall">https://api.slack.com/methods/admin.apps.uninstall</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_apps_uninstall(
    self,
    *,
    app_id: str,
    enterprise_id: Optional[str] = None,
    team_ids: Optional[Union[str, Sequence[str]]] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Uninstall an app from one or many workspaces, or an entire enterprise organization.
    With an org-level token, enterprise_id or team_ids is required.
    https://api.slack.com/methods/admin.apps.uninstall
    &#34;&#34;&#34;
    kwargs.update({&#34;app_id&#34;: app_id})
    if enterprise_id is not None:
        kwargs.update({&#34;enterprise_id&#34;: enterprise_id})
    if team_ids is not None:
        if isinstance(team_ids, (list, Tuple)):
            kwargs.update({&#34;team_ids&#34;: &#34;,&#34;.join(team_ids)})
        else:
            kwargs.update({&#34;team_ids&#34;: team_ids})
    return self.api_call(&#34;admin.apps.uninstall&#34;, http_verb=&#34;POST&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_auth_policy_assignEntities"><code class="name flex">
<span>def <span class="ident">admin_auth_policy_assignEntities</span></span>(<span>self, *, entity_ids: Union[str, Sequence[str]], policy_name: str, entity_type: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Assign entities to a particular authentication policy.
<a href="https://api.slack.com/methods/admin.auth.policy.assignEntities">https://api.slack.com/methods/admin.auth.policy.assignEntities</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_auth_policy_assignEntities(
    self,
    *,
    entity_ids: Union[str, Sequence[str]],
    policy_name: str,
    entity_type: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Assign entities to a particular authentication policy.
    https://api.slack.com/methods/admin.auth.policy.assignEntities
    &#34;&#34;&#34;
    if isinstance(entity_ids, (list, Tuple)):
        kwargs.update({&#34;entity_ids&#34;: &#34;,&#34;.join(entity_ids)})
    else:
        kwargs.update({&#34;entity_ids&#34;: entity_ids})
    kwargs.update({&#34;policy_name&#34;: policy_name})
    kwargs.update({&#34;entity_type&#34;: entity_type})
    return self.api_call(&#34;admin.auth.policy.assignEntities&#34;, http_verb=&#34;POST&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_auth_policy_getEntities"><code class="name flex">
<span>def <span class="ident">admin_auth_policy_getEntities</span></span>(<span>self, *, policy_name: str, cursor: Optional[str] = None, entity_type: Optional[str] = None, limit: Optional[int] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch all the entities assigned to a particular authentication policy by name.
<a href="https://api.slack.com/methods/admin.auth.policy.getEntities">https://api.slack.com/methods/admin.auth.policy.getEntities</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_auth_policy_getEntities(
    self,
    *,
    policy_name: str,
    cursor: Optional[str] = None,
    entity_type: Optional[str] = None,
    limit: Optional[int] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Fetch all the entities assigned to a particular authentication policy by name.
    https://api.slack.com/methods/admin.auth.policy.getEntities
    &#34;&#34;&#34;
    kwargs.update({&#34;policy_name&#34;: policy_name})
    if cursor is not None:
        kwargs.update({&#34;cursor&#34;: cursor})
    if entity_type is not None:
        kwargs.update({&#34;entity_type&#34;: entity_type})
    if limit is not None:
        kwargs.update({&#34;limit&#34;: limit})
    return self.api_call(&#34;admin.auth.policy.getEntities&#34;, http_verb=&#34;POST&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_auth_policy_removeEntities"><code class="name flex">
<span>def <span class="ident">admin_auth_policy_removeEntities</span></span>(<span>self, *, entity_ids: Union[str, Sequence[str]], policy_name: str, entity_type: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Remove specified entities from a specified authentication policy.
<a href="https://api.slack.com/methods/admin.auth.policy.removeEntities">https://api.slack.com/methods/admin.auth.policy.removeEntities</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_auth_policy_removeEntities(
    self,
    *,
    entity_ids: Union[str, Sequence[str]],
    policy_name: str,
    entity_type: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Remove specified entities from a specified authentication policy.
    https://api.slack.com/methods/admin.auth.policy.removeEntities
    &#34;&#34;&#34;
    if isinstance(entity_ids, (list, Tuple)):
        kwargs.update({&#34;entity_ids&#34;: &#34;,&#34;.join(entity_ids)})
    else:
        kwargs.update({&#34;entity_ids&#34;: entity_ids})
    kwargs.update({&#34;policy_name&#34;: policy_name})
    kwargs.update({&#34;entity_type&#34;: entity_type})
    return self.api_call(&#34;admin.auth.policy.removeEntities&#34;, http_verb=&#34;POST&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_barriers_create"><code class="name flex">
<span>def <span class="ident">admin_barriers_create</span></span>(<span>self, *, barriered_from_usergroup_ids: Union[str, Sequence[str]], primary_usergroup_id: str, restricted_subjects: Union[str, Sequence[str]], **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Create an Information Barrier
<a href="https://api.slack.com/methods/admin.barriers.create">https://api.slack.com/methods/admin.barriers.create</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_barriers_create(
    self,
    *,
    barriered_from_usergroup_ids: Union[str, Sequence[str]],
    primary_usergroup_id: str,
    restricted_subjects: Union[str, Sequence[str]],
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Create an Information Barrier
    https://api.slack.com/methods/admin.barriers.create
    &#34;&#34;&#34;
    kwargs.update({&#34;primary_usergroup_id&#34;: primary_usergroup_id})
    if isinstance(barriered_from_usergroup_ids, (list, Tuple)):
        kwargs.update({&#34;barriered_from_usergroup_ids&#34;: &#34;,&#34;.join(barriered_from_usergroup_ids)})
    else:
        kwargs.update({&#34;barriered_from_usergroup_ids&#34;: barriered_from_usergroup_ids})
    if isinstance(restricted_subjects, (list, Tuple)):
        kwargs.update({&#34;restricted_subjects&#34;: &#34;,&#34;.join(restricted_subjects)})
    else:
        kwargs.update({&#34;restricted_subjects&#34;: restricted_subjects})
    return self.api_call(&#34;admin.barriers.create&#34;, http_verb=&#34;POST&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_barriers_delete"><code class="name flex">
<span>def <span class="ident">admin_barriers_delete</span></span>(<span>self, *, barrier_id: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Delete an existing Information Barrier
<a href="https://api.slack.com/methods/admin.barriers.delete">https://api.slack.com/methods/admin.barriers.delete</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_barriers_delete(
    self,
    *,
    barrier_id: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Delete an existing Information Barrier
    https://api.slack.com/methods/admin.barriers.delete
    &#34;&#34;&#34;
    kwargs.update({&#34;barrier_id&#34;: barrier_id})
    return self.api_call(&#34;admin.barriers.delete&#34;, http_verb=&#34;POST&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_barriers_list"><code class="name flex">
<span>def <span class="ident">admin_barriers_list</span></span>(<span>self, *, cursor: Optional[str] = None, limit: Optional[int] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get all Information Barriers for your organization
<a href="https://api.slack.com/methods/admin.barriers.list">https://api.slack.com/methods/admin.barriers.list</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_barriers_list(
    self,
    *,
    cursor: Optional[str] = None,
    limit: Optional[int] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Get all Information Barriers for your organization
    https://api.slack.com/methods/admin.barriers.list&#34;&#34;&#34;
    kwargs.update(
        {
            &#34;cursor&#34;: cursor,
            &#34;limit&#34;: limit,
        }
    )
    return self.api_call(&#34;admin.barriers.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_barriers_update"><code class="name flex">
<span>def <span class="ident">admin_barriers_update</span></span>(<span>self, *, barrier_id: str, barriered_from_usergroup_ids: Union[str, Sequence[str]], primary_usergroup_id: str, restricted_subjects: Union[str, Sequence[str]], **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Update an existing Information Barrier
<a href="https://api.slack.com/methods/admin.barriers.update">https://api.slack.com/methods/admin.barriers.update</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_barriers_update(
    self,
    *,
    barrier_id: str,
    barriered_from_usergroup_ids: Union[str, Sequence[str]],
    primary_usergroup_id: str,
    restricted_subjects: Union[str, Sequence[str]],
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Update an existing Information Barrier
    https://api.slack.com/methods/admin.barriers.update
    &#34;&#34;&#34;
    kwargs.update({&#34;barrier_id&#34;: barrier_id, &#34;primary_usergroup_id&#34;: primary_usergroup_id})
    if isinstance(barriered_from_usergroup_ids, (list, Tuple)):
        kwargs.update({&#34;barriered_from_usergroup_ids&#34;: &#34;,&#34;.join(barriered_from_usergroup_ids)})
    else:
        kwargs.update({&#34;barriered_from_usergroup_ids&#34;: barriered_from_usergroup_ids})
    if isinstance(restricted_subjects, (list, Tuple)):
        kwargs.update({&#34;restricted_subjects&#34;: &#34;,&#34;.join(restricted_subjects)})
    else:
        kwargs.update({&#34;restricted_subjects&#34;: restricted_subjects})
    return self.api_call(&#34;admin.barriers.update&#34;, http_verb=&#34;POST&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_archive"><code class="name flex">
<span>def <span class="ident">admin_conversations_archive</span></span>(<span>self, *, channel_id: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Archive a public or private channel.
<a href="https://api.slack.com/methods/admin.conversations.archive">https://api.slack.com/methods/admin.conversations.archive</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_conversations_archive(
    self,
    *,
    channel_id: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Archive a public or private channel.
    https://api.slack.com/methods/admin.conversations.archive
    &#34;&#34;&#34;
    kwargs.update({&#34;channel_id&#34;: channel_id})
    return self.api_call(&#34;admin.conversations.archive&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_bulkArchive"><code class="name flex">
<span>def <span class="ident">admin_conversations_bulkArchive</span></span>(<span>self, *, channel_ids: Union[str, Sequence[str]], **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Archive public or private channels in bulk.
<a href="https://api.slack.com/methods/admin.conversations.bulkArchive">https://api.slack.com/methods/admin.conversations.bulkArchive</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_conversations_bulkArchive(
    self,
    *,
    channel_ids: Union[Sequence[str], str],
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Archive public or private channels in bulk.
    https://api.slack.com/methods/admin.conversations.bulkArchive
    &#34;&#34;&#34;
    kwargs.update({&#34;channel_ids&#34;: &#34;,&#34;.join(channel_ids) if isinstance(channel_ids, (list, tuple)) else channel_ids})
    return self.api_call(&#34;admin.conversations.bulkArchive&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_bulkDelete"><code class="name flex">
<span>def <span class="ident">admin_conversations_bulkDelete</span></span>(<span>self, *, channel_ids: Union[str, Sequence[str]], **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Delete public or private channels in bulk.
<a href="https://slack.com/api/admin.conversations.bulkDelete">https://slack.com/api/admin.conversations.bulkDelete</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_conversations_bulkDelete(
    self,
    *,
    channel_ids: Union[Sequence[str], str],
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Delete public or private channels in bulk.
    https://slack.com/api/admin.conversations.bulkDelete
    &#34;&#34;&#34;
    kwargs.update({&#34;channel_ids&#34;: &#34;,&#34;.join(channel_ids) if isinstance(channel_ids, (list, tuple)) else channel_ids})
    return self.api_call(&#34;admin.conversations.bulkDelete&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_bulkMove"><code class="name flex">
<span>def <span class="ident">admin_conversations_bulkMove</span></span>(<span>self, *, channel_ids: Union[str, Sequence[str]], target_team_id: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Move public or private channels in bulk.
<a href="https://api.slack.com/methods/admin.conversations.bulkMove">https://api.slack.com/methods/admin.conversations.bulkMove</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_conversations_bulkMove(
    self,
    *,
    channel_ids: Union[Sequence[str], str],
    target_team_id: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Move public or private channels in bulk.
    https://api.slack.com/methods/admin.conversations.bulkMove
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;target_team_id&#34;: target_team_id,
            &#34;channel_ids&#34;: &#34;,&#34;.join(channel_ids) if isinstance(channel_ids, (list, tuple)) else channel_ids,
        }
    )
    return self.api_call(&#34;admin.conversations.bulkMove&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_convertToPrivate"><code class="name flex">
<span>def <span class="ident">admin_conversations_convertToPrivate</span></span>(<span>self, *, channel_id: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a public channel to a private channel.
<a href="https://api.slack.com/methods/admin.conversations.convertToPrivate">https://api.slack.com/methods/admin.conversations.convertToPrivate</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_conversations_convertToPrivate(
    self,
    *,
    channel_id: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Convert a public channel to a private channel.
    https://api.slack.com/methods/admin.conversations.convertToPrivate
    &#34;&#34;&#34;
    kwargs.update({&#34;channel_id&#34;: channel_id})
    return self.api_call(&#34;admin.conversations.convertToPrivate&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_convertToPublic"><code class="name flex">
<span>def <span class="ident">admin_conversations_convertToPublic</span></span>(<span>self, *, channel_id: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a privte channel to a public channel.
<a href="https://api.slack.com/methods/admin.conversations.convertToPublic">https://api.slack.com/methods/admin.conversations.convertToPublic</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_conversations_convertToPublic(
    self,
    *,
    channel_id: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Convert a privte channel to a public channel.
    https://api.slack.com/methods/admin.conversations.convertToPublic
    &#34;&#34;&#34;
    kwargs.update({&#34;channel_id&#34;: channel_id})
    return self.api_call(&#34;admin.conversations.convertToPublic&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_create"><code class="name flex">
<span>def <span class="ident">admin_conversations_create</span></span>(<span>self, *, is_private: bool, name: str, description: Optional[str] = None, org_wide: Optional[bool] = None, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Create a public or private channel-based conversation.
<a href="https://api.slack.com/methods/admin.conversations.create">https://api.slack.com/methods/admin.conversations.create</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_conversations_create(
    self,
    *,
    is_private: bool,
    name: str,
    description: Optional[str] = None,
    org_wide: Optional[bool] = None,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Create a public or private channel-based conversation.
    https://api.slack.com/methods/admin.conversations.create
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;is_private&#34;: is_private,
            &#34;name&#34;: name,
            &#34;description&#34;: description,
            &#34;org_wide&#34;: org_wide,
            &#34;team_id&#34;: team_id,
        }
    )
    return self.api_call(&#34;admin.conversations.create&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_delete"><code class="name flex">
<span>def <span class="ident">admin_conversations_delete</span></span>(<span>self, *, channel_id: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a public or private channel.
<a href="https://api.slack.com/methods/admin.conversations.delete">https://api.slack.com/methods/admin.conversations.delete</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_conversations_delete(
    self,
    *,
    channel_id: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Delete a public or private channel.
    https://api.slack.com/methods/admin.conversations.delete
    &#34;&#34;&#34;
    kwargs.update({&#34;channel_id&#34;: channel_id})
    return self.api_call(&#34;admin.conversations.delete&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_disconnectShared"><code class="name flex">
<span>def <span class="ident">admin_conversations_disconnectShared</span></span>(<span>self, *, channel_id: str, leaving_team_ids: Union[str, Sequence[str], ForwardRef(None)] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnect a connected channel from one or more workspaces.
<a href="https://api.slack.com/methods/admin.conversations.disconnectShared">https://api.slack.com/methods/admin.conversations.disconnectShared</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_conversations_disconnectShared(
    self,
    *,
    channel_id: str,
    leaving_team_ids: Optional[Union[str, Sequence[str]]] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Disconnect a connected channel from one or more workspaces.
    https://api.slack.com/methods/admin.conversations.disconnectShared
    &#34;&#34;&#34;
    kwargs.update({&#34;channel_id&#34;: channel_id})
    if isinstance(leaving_team_ids, (list, Tuple)):
        kwargs.update({&#34;leaving_team_ids&#34;: &#34;,&#34;.join(leaving_team_ids)})
    else:
        kwargs.update({&#34;leaving_team_ids&#34;: leaving_team_ids})
    return self.api_call(&#34;admin.conversations.disconnectShared&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_ekm_listOriginalConnectedChannelInfo"><code class="name flex">
<span>def <span class="ident">admin_conversations_ekm_listOriginalConnectedChannelInfo</span></span>(<span>self, *, channel_ids: Union[str, Sequence[str], ForwardRef(None)] = None, cursor: Optional[str] = None, limit: Optional[int] = None, team_ids: Union[str, Sequence[str], ForwardRef(None)] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>List all disconnected channels—i.e.,
channels that were once connected to other workspaces and then disconnected—and
the corresponding original channel IDs for key revocation with EKM.
<a href="https://api.slack.com/methods/admin.conversations.ekm.listOriginalConnectedChannelInfo">https://api.slack.com/methods/admin.conversations.ekm.listOriginalConnectedChannelInfo</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_conversations_ekm_listOriginalConnectedChannelInfo(
    self,
    *,
    channel_ids: Optional[Union[str, Sequence[str]]] = None,
    cursor: Optional[str] = None,
    limit: Optional[int] = None,
    team_ids: Optional[Union[str, Sequence[str]]] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;List all disconnected channels—i.e.,
    channels that were once connected to other workspaces and then disconnected—and
    the corresponding original channel IDs for key revocation with EKM.
    https://api.slack.com/methods/admin.conversations.ekm.listOriginalConnectedChannelInfo
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;cursor&#34;: cursor,
            &#34;limit&#34;: limit,
        }
    )
    if isinstance(channel_ids, (list, Tuple)):
        kwargs.update({&#34;channel_ids&#34;: &#34;,&#34;.join(channel_ids)})
    else:
        kwargs.update({&#34;channel_ids&#34;: channel_ids})
    if isinstance(team_ids, (list, Tuple)):
        kwargs.update({&#34;team_ids&#34;: &#34;,&#34;.join(team_ids)})
    else:
        kwargs.update({&#34;team_ids&#34;: team_ids})
    return self.api_call(&#34;admin.conversations.ekm.listOriginalConnectedChannelInfo&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_getConversationPrefs"><code class="name flex">
<span>def <span class="ident">admin_conversations_getConversationPrefs</span></span>(<span>self, *, channel_id: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get conversation preferences for a public or private channel.
<a href="https://api.slack.com/methods/admin.conversations.getConversationPrefs">https://api.slack.com/methods/admin.conversations.getConversationPrefs</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_conversations_getConversationPrefs(
    self,
    *,
    channel_id: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Get conversation preferences for a public or private channel.
    https://api.slack.com/methods/admin.conversations.getConversationPrefs
    &#34;&#34;&#34;
    kwargs.update({&#34;channel_id&#34;: channel_id})
    return self.api_call(&#34;admin.conversations.getConversationPrefs&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_getCustomRetention"><code class="name flex">
<span>def <span class="ident">admin_conversations_getCustomRetention</span></span>(<span>self, *, channel_id: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get a channel's retention policy
<a href="https://api.slack.com/methods/admin.conversations.getCustomRetention">https://api.slack.com/methods/admin.conversations.getCustomRetention</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_conversations_getCustomRetention(
    self,
    *,
    channel_id: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Get a channel&#39;s retention policy
    https://api.slack.com/methods/admin.conversations.getCustomRetention
    &#34;&#34;&#34;
    kwargs.update({&#34;channel_id&#34;: channel_id})
    return self.api_call(&#34;admin.conversations.getCustomRetention&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_getTeams"><code class="name flex">
<span>def <span class="ident">admin_conversations_getTeams</span></span>(<span>self, *, channel_id: str, cursor: Optional[str] = None, limit: Optional[int] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Set the workspaces in an Enterprise grid org that connect to a channel.
<a href="https://api.slack.com/methods/admin.conversations.getTeams">https://api.slack.com/methods/admin.conversations.getTeams</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_conversations_getTeams(
    self,
    *,
    channel_id: str,
    cursor: Optional[str] = None,
    limit: Optional[int] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Set the workspaces in an Enterprise grid org that connect to a channel.
    https://api.slack.com/methods/admin.conversations.getTeams
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;channel_id&#34;: channel_id,
            &#34;cursor&#34;: cursor,
            &#34;limit&#34;: limit,
        }
    )
    return self.api_call(&#34;admin.conversations.getTeams&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_invite"><code class="name flex">
<span>def <span class="ident">admin_conversations_invite</span></span>(<span>self, *, channel_id: str, user_ids: Union[str, Sequence[str]], **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Invite a user to a public or private channel.
<a href="https://api.slack.com/methods/admin.conversations.invite">https://api.slack.com/methods/admin.conversations.invite</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_conversations_invite(
    self,
    *,
    channel_id: str,
    user_ids: Union[str, Sequence[str]],
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Invite a user to a public or private channel.
    https://api.slack.com/methods/admin.conversations.invite
    &#34;&#34;&#34;
    kwargs.update({&#34;channel_id&#34;: channel_id})
    if isinstance(user_ids, (list, Tuple)):
        kwargs.update({&#34;user_ids&#34;: &#34;,&#34;.join(user_ids)})
    else:
        kwargs.update({&#34;user_ids&#34;: user_ids})
    # NOTE: the endpoint is unable to handle Content-Type: application/json as of Sep 3, 2020.
    return self.api_call(&#34;admin.conversations.invite&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_lookup"><code class="name flex">
<span>def <span class="ident">admin_conversations_lookup</span></span>(<span>self, *, last_message_activity_before: int, team_ids: Union[str, Sequence[str]], cursor: Optional[str] = None, limit: Optional[int] = None, max_member_count: Optional[int] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns channels on the given team using the filters.
<a href="https://api.slack.com/methods/admin.conversations.lookup">https://api.slack.com/methods/admin.conversations.lookup</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_conversations_lookup(
    self,
    *,
    last_message_activity_before: int,
    team_ids: Union[str, Sequence[str]],
    cursor: Optional[str] = None,
    limit: Optional[int] = None,
    max_member_count: Optional[int] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Returns channels on the given team using the filters.
    https://api.slack.com/methods/admin.conversations.lookup
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;last_message_activity_before&#34;: last_message_activity_before,
            &#34;cursor&#34;: cursor,
            &#34;limit&#34;: limit,
            &#34;max_member_count&#34;: max_member_count,
        }
    )
    if isinstance(team_ids, (list, Tuple)):
        kwargs.update({&#34;team_ids&#34;: &#34;,&#34;.join(team_ids)})
    else:
        kwargs.update({&#34;team_ids&#34;: team_ids})
    return self.api_call(&#34;admin.conversations.lookup&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_removeCustomRetention"><code class="name flex">
<span>def <span class="ident">admin_conversations_removeCustomRetention</span></span>(<span>self, *, channel_id: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a channel's retention policy
<a href="https://api.slack.com/methods/admin.conversations.removeCustomRetention">https://api.slack.com/methods/admin.conversations.removeCustomRetention</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_conversations_removeCustomRetention(
    self,
    *,
    channel_id: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Remove a channel&#39;s retention policy
    https://api.slack.com/methods/admin.conversations.removeCustomRetention
    &#34;&#34;&#34;
    kwargs.update({&#34;channel_id&#34;: channel_id})
    return self.api_call(&#34;admin.conversations.removeCustomRetention&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_rename"><code class="name flex">
<span>def <span class="ident">admin_conversations_rename</span></span>(<span>self, *, channel_id: str, name: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Rename a public or private channel.
<a href="https://api.slack.com/methods/admin.conversations.rename">https://api.slack.com/methods/admin.conversations.rename</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_conversations_rename(
    self,
    *,
    channel_id: str,
    name: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Rename a public or private channel.
    https://api.slack.com/methods/admin.conversations.rename
    &#34;&#34;&#34;
    kwargs.update({&#34;channel_id&#34;: channel_id, &#34;name&#34;: name})
    return self.api_call(&#34;admin.conversations.rename&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_restrictAccess_addGroup"><code class="name flex">
<span>def <span class="ident">admin_conversations_restrictAccess_addGroup</span></span>(<span>self, *, channel_id: str, group_id: str, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Add an allowlist of IDP groups for accessing a channel.
<a href="https://api.slack.com/methods/admin.conversations.restrictAccess.addGroup">https://api.slack.com/methods/admin.conversations.restrictAccess.addGroup</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_conversations_restrictAccess_addGroup(
    self,
    *,
    channel_id: str,
    group_id: str,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Add an allowlist of IDP groups for accessing a channel.
    https://api.slack.com/methods/admin.conversations.restrictAccess.addGroup
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;channel_id&#34;: channel_id,
            &#34;group_id&#34;: group_id,
            &#34;team_id&#34;: team_id,
        }
    )
    return self.api_call(
        &#34;admin.conversations.restrictAccess.addGroup&#34;,
        http_verb=&#34;GET&#34;,
        params=kwargs,
    )</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_restrictAccess_listGroups"><code class="name flex">
<span>def <span class="ident">admin_conversations_restrictAccess_listGroups</span></span>(<span>self, *, channel_id: str, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>List all IDP Groups linked to a channel.
<a href="https://api.slack.com/methods/admin.conversations.restrictAccess.listGroups">https://api.slack.com/methods/admin.conversations.restrictAccess.listGroups</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_conversations_restrictAccess_listGroups(
    self,
    *,
    channel_id: str,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;List all IDP Groups linked to a channel.
    https://api.slack.com/methods/admin.conversations.restrictAccess.listGroups
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;channel_id&#34;: channel_id,
            &#34;team_id&#34;: team_id,
        }
    )
    return self.api_call(
        &#34;admin.conversations.restrictAccess.listGroups&#34;,
        http_verb=&#34;GET&#34;,
        params=kwargs,
    )</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_restrictAccess_removeGroup"><code class="name flex">
<span>def <span class="ident">admin_conversations_restrictAccess_removeGroup</span></span>(<span>self, *, channel_id: str, group_id: str, team_id: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a linked IDP group linked from a private channel.
<a href="https://api.slack.com/methods/admin.conversations.restrictAccess.removeGroup">https://api.slack.com/methods/admin.conversations.restrictAccess.removeGroup</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_conversations_restrictAccess_removeGroup(
    self,
    *,
    channel_id: str,
    group_id: str,
    team_id: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Remove a linked IDP group linked from a private channel.
    https://api.slack.com/methods/admin.conversations.restrictAccess.removeGroup
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;channel_id&#34;: channel_id,
            &#34;group_id&#34;: group_id,
            &#34;team_id&#34;: team_id,
        }
    )
    return self.api_call(
        &#34;admin.conversations.restrictAccess.removeGroup&#34;,
        http_verb=&#34;GET&#34;,
        params=kwargs,
    )</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_search"><code class="name flex">
<span>def <span class="ident">admin_conversations_search</span></span>(<span>self, *, cursor: Optional[str] = None, limit: Optional[int] = None, query: Optional[str] = None, search_channel_types: Union[str, Sequence[str], ForwardRef(None)] = None, sort: Optional[str] = None, sort_dir: Optional[str] = None, team_ids: Union[str, Sequence[str], ForwardRef(None)] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Search for public or private channels in an Enterprise organization.
<a href="https://api.slack.com/methods/admin.conversations.search">https://api.slack.com/methods/admin.conversations.search</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_conversations_search(
    self,
    *,
    cursor: Optional[str] = None,
    limit: Optional[int] = None,
    query: Optional[str] = None,
    search_channel_types: Optional[Union[str, Sequence[str]]] = None,
    sort: Optional[str] = None,
    sort_dir: Optional[str] = None,
    team_ids: Optional[Union[str, Sequence[str]]] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Search for public or private channels in an Enterprise organization.
    https://api.slack.com/methods/admin.conversations.search
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;cursor&#34;: cursor,
            &#34;limit&#34;: limit,
            &#34;query&#34;: query,
            &#34;sort&#34;: sort,
            &#34;sort_dir&#34;: sort_dir,
        }
    )

    if isinstance(search_channel_types, (list, Tuple)):
        kwargs.update({&#34;search_channel_types&#34;: &#34;,&#34;.join(search_channel_types)})
    else:
        kwargs.update({&#34;search_channel_types&#34;: search_channel_types})

    if isinstance(team_ids, (list, Tuple)):
        kwargs.update({&#34;team_ids&#34;: &#34;,&#34;.join(team_ids)})
    else:
        kwargs.update({&#34;team_ids&#34;: team_ids})

    return self.api_call(&#34;admin.conversations.search&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_setConversationPrefs"><code class="name flex">
<span>def <span class="ident">admin_conversations_setConversationPrefs</span></span>(<span>self, *, channel_id: str, prefs: Union[str, Dict[str, str]], **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Set the posting permissions for a public or private channel.
<a href="https://api.slack.com/methods/admin.conversations.setConversationPrefs">https://api.slack.com/methods/admin.conversations.setConversationPrefs</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_conversations_setConversationPrefs(
    self,
    *,
    channel_id: str,
    prefs: Union[str, Dict[str, str]],
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Set the posting permissions for a public or private channel.
    https://api.slack.com/methods/admin.conversations.setConversationPrefs
    &#34;&#34;&#34;
    kwargs.update({&#34;channel_id&#34;: channel_id})
    if isinstance(prefs, dict):
        kwargs.update({&#34;prefs&#34;: json.dumps(prefs)})
    else:
        kwargs.update({&#34;prefs&#34;: prefs})
    return self.api_call(&#34;admin.conversations.setConversationPrefs&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_setCustomRetention"><code class="name flex">
<span>def <span class="ident">admin_conversations_setCustomRetention</span></span>(<span>self, *, channel_id: str, duration_days: int, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Set a channel's retention policy
<a href="https://api.slack.com/methods/admin.conversations.setCustomRetention">https://api.slack.com/methods/admin.conversations.setCustomRetention</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_conversations_setCustomRetention(
    self,
    *,
    channel_id: str,
    duration_days: int,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Set a channel&#39;s retention policy
    https://api.slack.com/methods/admin.conversations.setCustomRetention
    &#34;&#34;&#34;
    kwargs.update({&#34;channel_id&#34;: channel_id, &#34;duration_days&#34;: duration_days})
    return self.api_call(&#34;admin.conversations.setCustomRetention&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_setTeams"><code class="name flex">
<span>def <span class="ident">admin_conversations_setTeams</span></span>(<span>self, *, channel_id: str, org_channel: Optional[bool] = None, target_team_ids: Union[str, Sequence[str], ForwardRef(None)] = None, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Set the workspaces in an Enterprise grid org that connect to a public or private channel.
<a href="https://api.slack.com/methods/admin.conversations.setTeams">https://api.slack.com/methods/admin.conversations.setTeams</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_conversations_setTeams(
    self,
    *,
    channel_id: str,
    org_channel: Optional[bool] = None,
    target_team_ids: Optional[Union[str, Sequence[str]]] = None,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Set the workspaces in an Enterprise grid org that connect to a public or private channel.
    https://api.slack.com/methods/admin.conversations.setTeams
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;channel_id&#34;: channel_id,
            &#34;org_channel&#34;: org_channel,
            &#34;team_id&#34;: team_id,
        }
    )
    if isinstance(target_team_ids, (list, Tuple)):
        kwargs.update({&#34;target_team_ids&#34;: &#34;,&#34;.join(target_team_ids)})
    else:
        kwargs.update({&#34;target_team_ids&#34;: target_team_ids})
    return self.api_call(&#34;admin.conversations.setTeams&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_unarchive"><code class="name flex">
<span>def <span class="ident">admin_conversations_unarchive</span></span>(<span>self, *, channel_id: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Unarchive a public or private channel.
<a href="https://api.slack.com/methods/admin.conversations.archive">https://api.slack.com/methods/admin.conversations.archive</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_conversations_unarchive(
    self,
    *,
    channel_id: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Unarchive a public or private channel.
    https://api.slack.com/methods/admin.conversations.archive
    &#34;&#34;&#34;
    kwargs.update({&#34;channel_id&#34;: channel_id})
    return self.api_call(&#34;admin.conversations.unarchive&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_emoji_add"><code class="name flex">
<span>def <span class="ident">admin_emoji_add</span></span>(<span>self, *, name: str, url: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Add an emoji.
<a href="https://api.slack.com/methods/admin.emoji.add">https://api.slack.com/methods/admin.emoji.add</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_emoji_add(
    self,
    *,
    name: str,
    url: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Add an emoji.
    https://api.slack.com/methods/admin.emoji.add
    &#34;&#34;&#34;
    kwargs.update({&#34;name&#34;: name, &#34;url&#34;: url})
    return self.api_call(&#34;admin.emoji.add&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_emoji_addAlias"><code class="name flex">
<span>def <span class="ident">admin_emoji_addAlias</span></span>(<span>self, *, alias_for: str, name: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Add an emoji alias.
<a href="https://api.slack.com/methods/admin.emoji.addAlias">https://api.slack.com/methods/admin.emoji.addAlias</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_emoji_addAlias(
    self,
    *,
    alias_for: str,
    name: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Add an emoji alias.
    https://api.slack.com/methods/admin.emoji.addAlias
    &#34;&#34;&#34;
    kwargs.update({&#34;alias_for&#34;: alias_for, &#34;name&#34;: name})
    return self.api_call(&#34;admin.emoji.addAlias&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_emoji_list"><code class="name flex">
<span>def <span class="ident">admin_emoji_list</span></span>(<span>self, *, cursor: Optional[str] = None, limit: Optional[int] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>List emoji for an Enterprise Grid organization.
<a href="https://api.slack.com/methods/admin.emoji.list">https://api.slack.com/methods/admin.emoji.list</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_emoji_list(
    self,
    *,
    cursor: Optional[str] = None,
    limit: Optional[int] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;List emoji for an Enterprise Grid organization.
    https://api.slack.com/methods/admin.emoji.list
    &#34;&#34;&#34;
    kwargs.update({&#34;cursor&#34;: cursor, &#34;limit&#34;: limit})
    return self.api_call(&#34;admin.emoji.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_emoji_remove"><code class="name flex">
<span>def <span class="ident">admin_emoji_remove</span></span>(<span>self, *, name: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Remove an emoji across an Enterprise Grid organization.
<a href="https://api.slack.com/methods/admin.emoji.remove">https://api.slack.com/methods/admin.emoji.remove</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_emoji_remove(
    self,
    *,
    name: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Remove an emoji across an Enterprise Grid organization.
    https://api.slack.com/methods/admin.emoji.remove
    &#34;&#34;&#34;
    kwargs.update({&#34;name&#34;: name})
    return self.api_call(&#34;admin.emoji.remove&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_emoji_rename"><code class="name flex">
<span>def <span class="ident">admin_emoji_rename</span></span>(<span>self, *, name: str, new_name: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Rename an emoji.
<a href="https://api.slack.com/methods/admin.emoji.rename">https://api.slack.com/methods/admin.emoji.rename</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_emoji_rename(
    self,
    *,
    name: str,
    new_name: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Rename an emoji.
    https://api.slack.com/methods/admin.emoji.rename
    &#34;&#34;&#34;
    kwargs.update({&#34;name&#34;: name, &#34;new_name&#34;: new_name})
    return self.api_call(&#34;admin.emoji.rename&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_functions_list"><code class="name flex">
<span>def <span class="ident">admin_functions_list</span></span>(<span>self, *, app_ids: Union[str, Sequence[str]], team_id: Optional[str] = None, cursor: Optional[str] = None, limit: Optional[int] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Look up functions by a set of apps
<a href="https://api.slack.com/methods/admin.functions.list">https://api.slack.com/methods/admin.functions.list</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_functions_list(
    self,
    *,
    app_ids: Union[str, Sequence[str]],
    team_id: Optional[str] = None,
    cursor: Optional[str] = None,
    limit: Optional[int] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Look up functions by a set of apps
    https://api.slack.com/methods/admin.functions.list
    &#34;&#34;&#34;
    if isinstance(app_ids, (list, Tuple)):
        kwargs.update({&#34;app_ids&#34;: &#34;,&#34;.join(app_ids)})
    else:
        kwargs.update({&#34;app_ids&#34;: app_ids})
    kwargs.update(
        {
            &#34;team_id&#34;: team_id,
            &#34;cursor&#34;: cursor,
            &#34;limit&#34;: limit,
        }
    )
    return self.api_call(&#34;admin.functions.list&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_functions_permissions_lookup"><code class="name flex">
<span>def <span class="ident">admin_functions_permissions_lookup</span></span>(<span>self, *, function_ids: Union[str, Sequence[str]], **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Lookup the visibility of multiple Slack functions
and include the users if it is limited to particular named entities.
<a href="https://api.slack.com/methods/admin.functions.permissions.lookup">https://api.slack.com/methods/admin.functions.permissions.lookup</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_functions_permissions_lookup(
    self,
    *,
    function_ids: Union[str, Sequence[str]],
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Lookup the visibility of multiple Slack functions
    and include the users if it is limited to particular named entities.
    https://api.slack.com/methods/admin.functions.permissions.lookup
    &#34;&#34;&#34;
    if isinstance(function_ids, (list, Tuple)):
        kwargs.update({&#34;function_ids&#34;: &#34;,&#34;.join(function_ids)})
    else:
        kwargs.update({&#34;function_ids&#34;: function_ids})
    return self.api_call(&#34;admin.functions.permissions.lookup&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_functions_permissions_set"><code class="name flex">
<span>def <span class="ident">admin_functions_permissions_set</span></span>(<span>self, *, function_id: str, visibility: str, user_ids: Union[str, Sequence[str], ForwardRef(None)] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Set the visibility of a Slack function
and define the users or workspaces if it is set to named_entities
<a href="https://api.slack.com/methods/admin.functions.permissions.set">https://api.slack.com/methods/admin.functions.permissions.set</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_functions_permissions_set(
    self,
    *,
    function_id: str,
    visibility: str,
    user_ids: Optional[Union[str, Sequence[str]]] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Set the visibility of a Slack function
    and define the users or workspaces if it is set to named_entities
    https://api.slack.com/methods/admin.functions.permissions.set
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;function_id&#34;: function_id,
            &#34;visibility&#34;: visibility,
        }
    )
    if user_ids is not None:
        if isinstance(user_ids, (list, Tuple)):
            kwargs.update({&#34;user_ids&#34;: &#34;,&#34;.join(user_ids)})
        else:
            kwargs.update({&#34;user_ids&#34;: user_ids})
    return self.api_call(&#34;admin.functions.permissions.set&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_inviteRequests_approve"><code class="name flex">
<span>def <span class="ident">admin_inviteRequests_approve</span></span>(<span>self, *, invite_request_id: str, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Approve a workspace invite request.
<a href="https://api.slack.com/methods/admin.inviteRequests.approve">https://api.slack.com/methods/admin.inviteRequests.approve</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_inviteRequests_approve(
    self,
    *,
    invite_request_id: str,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Approve a workspace invite request.
    https://api.slack.com/methods/admin.inviteRequests.approve
    &#34;&#34;&#34;
    kwargs.update({&#34;invite_request_id&#34;: invite_request_id, &#34;team_id&#34;: team_id})
    return self.api_call(&#34;admin.inviteRequests.approve&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_inviteRequests_approved_list"><code class="name flex">
<span>def <span class="ident">admin_inviteRequests_approved_list</span></span>(<span>self, *, cursor: Optional[str] = None, limit: Optional[int] = None, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>List all approved workspace invite requests.
<a href="https://api.slack.com/methods/admin.inviteRequests.approved.list">https://api.slack.com/methods/admin.inviteRequests.approved.list</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_inviteRequests_approved_list(
    self,
    *,
    cursor: Optional[str] = None,
    limit: Optional[int] = None,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;List all approved workspace invite requests.
    https://api.slack.com/methods/admin.inviteRequests.approved.list
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;cursor&#34;: cursor,
            &#34;limit&#34;: limit,
            &#34;team_id&#34;: team_id,
        }
    )
    return self.api_call(&#34;admin.inviteRequests.approved.list&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_inviteRequests_denied_list"><code class="name flex">
<span>def <span class="ident">admin_inviteRequests_denied_list</span></span>(<span>self, *, cursor: Optional[str] = None, limit: Optional[int] = None, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>List all denied workspace invite requests.
<a href="https://api.slack.com/methods/admin.inviteRequests.denied.list">https://api.slack.com/methods/admin.inviteRequests.denied.list</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_inviteRequests_denied_list(
    self,
    *,
    cursor: Optional[str] = None,
    limit: Optional[int] = None,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;List all denied workspace invite requests.
    https://api.slack.com/methods/admin.inviteRequests.denied.list
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;cursor&#34;: cursor,
            &#34;limit&#34;: limit,
            &#34;team_id&#34;: team_id,
        }
    )
    return self.api_call(&#34;admin.inviteRequests.denied.list&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_inviteRequests_deny"><code class="name flex">
<span>def <span class="ident">admin_inviteRequests_deny</span></span>(<span>self, *, invite_request_id: str, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Deny a workspace invite request.
<a href="https://api.slack.com/methods/admin.inviteRequests.deny">https://api.slack.com/methods/admin.inviteRequests.deny</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_inviteRequests_deny(
    self,
    *,
    invite_request_id: str,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Deny a workspace invite request.
    https://api.slack.com/methods/admin.inviteRequests.deny
    &#34;&#34;&#34;
    kwargs.update({&#34;invite_request_id&#34;: invite_request_id, &#34;team_id&#34;: team_id})
    return self.api_call(&#34;admin.inviteRequests.deny&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_inviteRequests_list"><code class="name flex">
<span>def <span class="ident">admin_inviteRequests_list</span></span>(<span>self, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>List all pending workspace invite requests.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_inviteRequests_list(
    self,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;List all pending workspace invite requests.&#34;&#34;&#34;
    return self.api_call(&#34;admin.inviteRequests.list&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_roles_addAssignments"><code class="name flex">
<span>def <span class="ident">admin_roles_addAssignments</span></span>(<span>self, *, role_id: str, entity_ids: Union[str, Sequence[str]], user_ids: Union[str, Sequence[str]], **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Adds members to the specified role with the specified scopes
<a href="https://api.slack.com/methods/admin.roles.addAssignments">https://api.slack.com/methods/admin.roles.addAssignments</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_roles_addAssignments(
    self,
    *,
    role_id: str,
    entity_ids: Union[str, Sequence[str]],
    user_ids: Union[str, Sequence[str]],
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Adds members to the specified role with the specified scopes
    https://api.slack.com/methods/admin.roles.addAssignments
    &#34;&#34;&#34;
    kwargs.update({&#34;role_id&#34;: role_id})
    if isinstance(entity_ids, (list, Tuple)):
        kwargs.update({&#34;entity_ids&#34;: &#34;,&#34;.join(entity_ids)})
    else:
        kwargs.update({&#34;entity_ids&#34;: entity_ids})
    if isinstance(user_ids, (list, Tuple)):
        kwargs.update({&#34;user_ids&#34;: &#34;,&#34;.join(user_ids)})
    else:
        kwargs.update({&#34;user_ids&#34;: user_ids})
    return self.api_call(&#34;admin.roles.addAssignments&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_roles_listAssignments"><code class="name flex">
<span>def <span class="ident">admin_roles_listAssignments</span></span>(<span>self, *, role_ids: Union[str, Sequence[str], ForwardRef(None)] = None, entity_ids: Union[str, Sequence[str], ForwardRef(None)] = None, cursor: Optional[str] = None, limit: Union[str, int, ForwardRef(None)] = None, sort_dir: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Lists assignments for all roles across entities.
Options to scope results by any combination of roles or entities
<a href="https://api.slack.com/methods/admin.roles.listAssignments">https://api.slack.com/methods/admin.roles.listAssignments</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_roles_listAssignments(
    self,
    *,
    role_ids: Optional[Union[str, Sequence[str]]] = None,
    entity_ids: Optional[Union[str, Sequence[str]]] = None,
    cursor: Optional[str] = None,
    limit: Optional[Union[str, int]] = None,
    sort_dir: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Lists assignments for all roles across entities.
        Options to scope results by any combination of roles or entities
    https://api.slack.com/methods/admin.roles.listAssignments
    &#34;&#34;&#34;
    kwargs.update({&#34;cursor&#34;: cursor, &#34;limit&#34;: limit, &#34;sort_dir&#34;: sort_dir})
    if isinstance(entity_ids, (list, Tuple)):
        kwargs.update({&#34;entity_ids&#34;: &#34;,&#34;.join(entity_ids)})
    else:
        kwargs.update({&#34;entity_ids&#34;: entity_ids})
    if isinstance(role_ids, (list, Tuple)):
        kwargs.update({&#34;role_ids&#34;: &#34;,&#34;.join(role_ids)})
    else:
        kwargs.update({&#34;role_ids&#34;: role_ids})
    return self.api_call(&#34;admin.roles.listAssignments&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_roles_removeAssignments"><code class="name flex">
<span>def <span class="ident">admin_roles_removeAssignments</span></span>(<span>self, *, role_id: str, entity_ids: Union[str, Sequence[str]], user_ids: Union[str, Sequence[str]], **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Removes a set of users from a role for the given scopes and entities
<a href="https://api.slack.com/methods/admin.roles.removeAssignments">https://api.slack.com/methods/admin.roles.removeAssignments</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_roles_removeAssignments(
    self,
    *,
    role_id: str,
    entity_ids: Union[str, Sequence[str]],
    user_ids: Union[str, Sequence[str]],
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Removes a set of users from a role for the given scopes and entities
    https://api.slack.com/methods/admin.roles.removeAssignments
    &#34;&#34;&#34;
    kwargs.update({&#34;role_id&#34;: role_id})
    if isinstance(entity_ids, (list, Tuple)):
        kwargs.update({&#34;entity_ids&#34;: &#34;,&#34;.join(entity_ids)})
    else:
        kwargs.update({&#34;entity_ids&#34;: entity_ids})
    if isinstance(user_ids, (list, Tuple)):
        kwargs.update({&#34;user_ids&#34;: &#34;,&#34;.join(user_ids)})
    else:
        kwargs.update({&#34;user_ids&#34;: user_ids})
    return self.api_call(&#34;admin.roles.removeAssignments&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_teams_admins_list"><code class="name flex">
<span>def <span class="ident">admin_teams_admins_list</span></span>(<span>self, *, team_id: str, cursor: Optional[str] = None, limit: Optional[int] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>List all of the admins on a given workspace.
<a href="https://api.slack.com/methods/admin.inviteRequests.list">https://api.slack.com/methods/admin.inviteRequests.list</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_teams_admins_list(
    self,
    *,
    team_id: str,
    cursor: Optional[str] = None,
    limit: Optional[int] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;List all of the admins on a given workspace.
    https://api.slack.com/methods/admin.inviteRequests.list
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;cursor&#34;: cursor,
            &#34;limit&#34;: limit,
            &#34;team_id&#34;: team_id,
        }
    )
    return self.api_call(&#34;admin.teams.admins.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_teams_create"><code class="name flex">
<span>def <span class="ident">admin_teams_create</span></span>(<span>self, *, team_domain: str, team_name: str, team_description: Optional[str] = None, team_discoverability: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Create an Enterprise team.
<a href="https://api.slack.com/methods/admin.teams.create">https://api.slack.com/methods/admin.teams.create</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_teams_create(
    self,
    *,
    team_domain: str,
    team_name: str,
    team_description: Optional[str] = None,
    team_discoverability: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Create an Enterprise team.
    https://api.slack.com/methods/admin.teams.create
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;team_domain&#34;: team_domain,
            &#34;team_name&#34;: team_name,
            &#34;team_description&#34;: team_description,
            &#34;team_discoverability&#34;: team_discoverability,
        }
    )
    return self.api_call(&#34;admin.teams.create&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_teams_list"><code class="name flex">
<span>def <span class="ident">admin_teams_list</span></span>(<span>self, *, cursor: Optional[str] = None, limit: Optional[int] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>List all teams on an Enterprise organization.
<a href="https://api.slack.com/methods/admin.teams.list">https://api.slack.com/methods/admin.teams.list</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_teams_list(
    self,
    *,
    cursor: Optional[str] = None,
    limit: Optional[int] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;List all teams on an Enterprise organization.
    https://api.slack.com/methods/admin.teams.list
    &#34;&#34;&#34;
    kwargs.update({&#34;cursor&#34;: cursor, &#34;limit&#34;: limit})
    return self.api_call(&#34;admin.teams.list&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_teams_owners_list"><code class="name flex">
<span>def <span class="ident">admin_teams_owners_list</span></span>(<span>self, *, team_id: str, cursor: Optional[str] = None, limit: Optional[int] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>List all of the admins on a given workspace.
<a href="https://api.slack.com/methods/admin.teams.owners.list">https://api.slack.com/methods/admin.teams.owners.list</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_teams_owners_list(
    self,
    *,
    team_id: str,
    cursor: Optional[str] = None,
    limit: Optional[int] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;List all of the admins on a given workspace.
    https://api.slack.com/methods/admin.teams.owners.list
    &#34;&#34;&#34;
    kwargs.update({&#34;team_id&#34;: team_id, &#34;cursor&#34;: cursor, &#34;limit&#34;: limit})
    return self.api_call(&#34;admin.teams.owners.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_teams_settings_info"><code class="name flex">
<span>def <span class="ident">admin_teams_settings_info</span></span>(<span>self, *, team_id: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch information about settings in a workspace
<a href="https://api.slack.com/methods/admin.teams.settings.info">https://api.slack.com/methods/admin.teams.settings.info</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_teams_settings_info(
    self,
    *,
    team_id: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Fetch information about settings in a workspace
    https://api.slack.com/methods/admin.teams.settings.info
    &#34;&#34;&#34;
    kwargs.update({&#34;team_id&#34;: team_id})
    return self.api_call(&#34;admin.teams.settings.info&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_teams_settings_setDefaultChannels"><code class="name flex">
<span>def <span class="ident">admin_teams_settings_setDefaultChannels</span></span>(<span>self, *, team_id: str, channel_ids: Union[str, Sequence[str]], **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Set the default channels of a workspace.
<a href="https://api.slack.com/methods/admin.teams.settings.setDefaultChannels">https://api.slack.com/methods/admin.teams.settings.setDefaultChannels</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_teams_settings_setDefaultChannels(
    self,
    *,
    team_id: str,
    channel_ids: Union[str, Sequence[str]],
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Set the default channels of a workspace.
    https://api.slack.com/methods/admin.teams.settings.setDefaultChannels
    &#34;&#34;&#34;
    kwargs.update({&#34;team_id&#34;: team_id})
    if isinstance(channel_ids, (list, Tuple)):
        kwargs.update({&#34;channel_ids&#34;: &#34;,&#34;.join(channel_ids)})
    else:
        kwargs.update({&#34;channel_ids&#34;: channel_ids})
    return self.api_call(&#34;admin.teams.settings.setDefaultChannels&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_teams_settings_setDescription"><code class="name flex">
<span>def <span class="ident">admin_teams_settings_setDescription</span></span>(<span>self, *, team_id: str, description: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Set the description of a given workspace.
<a href="https://api.slack.com/methods/admin.teams.settings.setDescription">https://api.slack.com/methods/admin.teams.settings.setDescription</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_teams_settings_setDescription(
    self,
    *,
    team_id: str,
    description: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Set the description of a given workspace.
    https://api.slack.com/methods/admin.teams.settings.setDescription
    &#34;&#34;&#34;
    kwargs.update({&#34;team_id&#34;: team_id, &#34;description&#34;: description})
    return self.api_call(&#34;admin.teams.settings.setDescription&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_teams_settings_setDiscoverability"><code class="name flex">
<span>def <span class="ident">admin_teams_settings_setDiscoverability</span></span>(<span>self, *, team_id: str, discoverability: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the icon of a workspace.
<a href="https://api.slack.com/methods/admin.teams.settings.setDiscoverability">https://api.slack.com/methods/admin.teams.settings.setDiscoverability</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_teams_settings_setDiscoverability(
    self,
    *,
    team_id: str,
    discoverability: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Sets the icon of a workspace.
    https://api.slack.com/methods/admin.teams.settings.setDiscoverability
    &#34;&#34;&#34;
    kwargs.update({&#34;team_id&#34;: team_id, &#34;discoverability&#34;: discoverability})
    return self.api_call(&#34;admin.teams.settings.setDiscoverability&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_teams_settings_setIcon"><code class="name flex">
<span>def <span class="ident">admin_teams_settings_setIcon</span></span>(<span>self, *, team_id: str, image_url: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the icon of a workspace.
<a href="https://api.slack.com/methods/admin.teams.settings.setIcon">https://api.slack.com/methods/admin.teams.settings.setIcon</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_teams_settings_setIcon(
    self,
    *,
    team_id: str,
    image_url: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Sets the icon of a workspace.
    https://api.slack.com/methods/admin.teams.settings.setIcon
    &#34;&#34;&#34;
    kwargs.update({&#34;team_id&#34;: team_id, &#34;image_url&#34;: image_url})
    return self.api_call(&#34;admin.teams.settings.setIcon&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_teams_settings_setName"><code class="name flex">
<span>def <span class="ident">admin_teams_settings_setName</span></span>(<span>self, *, team_id: str, name: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the icon of a workspace.
<a href="https://api.slack.com/methods/admin.teams.settings.setName">https://api.slack.com/methods/admin.teams.settings.setName</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_teams_settings_setName(
    self,
    *,
    team_id: str,
    name: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Sets the icon of a workspace.
    https://api.slack.com/methods/admin.teams.settings.setName
    &#34;&#34;&#34;
    kwargs.update({&#34;team_id&#34;: team_id, &#34;name&#34;: name})
    return self.api_call(&#34;admin.teams.settings.setName&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_usergroups_addChannels"><code class="name flex">
<span>def <span class="ident">admin_usergroups_addChannels</span></span>(<span>self, *, channel_ids: Union[str, Sequence[str]], usergroup_id: str, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Add one or more default channels to an IDP group.
<a href="https://api.slack.com/methods/admin.usergroups.addChannels">https://api.slack.com/methods/admin.usergroups.addChannels</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_usergroups_addChannels(
    self,
    *,
    channel_ids: Union[str, Sequence[str]],
    usergroup_id: str,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Add one or more default channels to an IDP group.
    https://api.slack.com/methods/admin.usergroups.addChannels
    &#34;&#34;&#34;
    kwargs.update({&#34;team_id&#34;: team_id, &#34;usergroup_id&#34;: usergroup_id})
    if isinstance(channel_ids, (list, Tuple)):
        kwargs.update({&#34;channel_ids&#34;: &#34;,&#34;.join(channel_ids)})
    else:
        kwargs.update({&#34;channel_ids&#34;: channel_ids})
    return self.api_call(&#34;admin.usergroups.addChannels&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_usergroups_addTeams"><code class="name flex">
<span>def <span class="ident">admin_usergroups_addTeams</span></span>(<span>self, *, usergroup_id: str, team_ids: Union[str, Sequence[str]], auto_provision: Optional[bool] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Associate one or more default workspaces with an organization-wide IDP group.
<a href="https://api.slack.com/methods/admin.usergroups.addTeams">https://api.slack.com/methods/admin.usergroups.addTeams</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_usergroups_addTeams(
    self,
    *,
    usergroup_id: str,
    team_ids: Union[str, Sequence[str]],
    auto_provision: Optional[bool] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Associate one or more default workspaces with an organization-wide IDP group.
    https://api.slack.com/methods/admin.usergroups.addTeams
    &#34;&#34;&#34;
    kwargs.update({&#34;usergroup_id&#34;: usergroup_id, &#34;auto_provision&#34;: auto_provision})
    if isinstance(team_ids, (list, Tuple)):
        kwargs.update({&#34;team_ids&#34;: &#34;,&#34;.join(team_ids)})
    else:
        kwargs.update({&#34;team_ids&#34;: team_ids})
    return self.api_call(&#34;admin.usergroups.addTeams&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_usergroups_listChannels"><code class="name flex">
<span>def <span class="ident">admin_usergroups_listChannels</span></span>(<span>self, *, usergroup_id: str, include_num_members: Optional[bool] = None, team_id: Optional[bool] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Add one or more default channels to an IDP group.
<a href="https://api.slack.com/methods/admin.usergroups.listChannels">https://api.slack.com/methods/admin.usergroups.listChannels</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_usergroups_listChannels(
    self,
    *,
    usergroup_id: str,
    include_num_members: Optional[bool] = None,
    team_id: Optional[bool] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Add one or more default channels to an IDP group.
    https://api.slack.com/methods/admin.usergroups.listChannels
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;usergroup_id&#34;: usergroup_id,
            &#34;include_num_members&#34;: include_num_members,
            &#34;team_id&#34;: team_id,
        }
    )
    return self.api_call(&#34;admin.usergroups.listChannels&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_usergroups_removeChannels"><code class="name flex">
<span>def <span class="ident">admin_usergroups_removeChannels</span></span>(<span>self, *, usergroup_id: str, channel_ids: Union[str, Sequence[str]], **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Add one or more default channels to an IDP group.
<a href="https://api.slack.com/methods/admin.usergroups.removeChannels">https://api.slack.com/methods/admin.usergroups.removeChannels</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_usergroups_removeChannels(
    self,
    *,
    usergroup_id: str,
    channel_ids: Union[str, Sequence[str]],
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Add one or more default channels to an IDP group.
    https://api.slack.com/methods/admin.usergroups.removeChannels
    &#34;&#34;&#34;
    kwargs.update({&#34;usergroup_id&#34;: usergroup_id})
    if isinstance(channel_ids, (list, Tuple)):
        kwargs.update({&#34;channel_ids&#34;: &#34;,&#34;.join(channel_ids)})
    else:
        kwargs.update({&#34;channel_ids&#34;: channel_ids})
    return self.api_call(&#34;admin.usergroups.removeChannels&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_assign"><code class="name flex">
<span>def <span class="ident">admin_users_assign</span></span>(<span>self, *, team_id: str, user_id: str, channel_ids: Union[str, Sequence[str], ForwardRef(None)] = None, is_restricted: Optional[bool] = None, is_ultra_restricted: Optional[bool] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Add an Enterprise user to a workspace.
<a href="https://api.slack.com/methods/admin.users.assign">https://api.slack.com/methods/admin.users.assign</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_users_assign(
    self,
    *,
    team_id: str,
    user_id: str,
    channel_ids: Optional[Union[str, Sequence[str]]] = None,
    is_restricted: Optional[bool] = None,
    is_ultra_restricted: Optional[bool] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Add an Enterprise user to a workspace.
    https://api.slack.com/methods/admin.users.assign
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;team_id&#34;: team_id,
            &#34;user_id&#34;: user_id,
            &#34;is_restricted&#34;: is_restricted,
            &#34;is_ultra_restricted&#34;: is_ultra_restricted,
        }
    )
    if isinstance(channel_ids, (list, Tuple)):
        kwargs.update({&#34;channel_ids&#34;: &#34;,&#34;.join(channel_ids)})
    else:
        kwargs.update({&#34;channel_ids&#34;: channel_ids})
    return self.api_call(&#34;admin.users.assign&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_invite"><code class="name flex">
<span>def <span class="ident">admin_users_invite</span></span>(<span>self, *, team_id: str, email: str, channel_ids: Union[str, Sequence[str]], custom_message: Optional[str] = None, email_password_policy_enabled: Optional[bool] = None, guest_expiration_ts: Union[str, float, ForwardRef(None)] = None, is_restricted: Optional[bool] = None, is_ultra_restricted: Optional[bool] = None, real_name: Optional[str] = None, resend: Optional[bool] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Invite a user to a workspace.
<a href="https://api.slack.com/methods/admin.users.invite">https://api.slack.com/methods/admin.users.invite</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_users_invite(
    self,
    *,
    team_id: str,
    email: str,
    channel_ids: Union[str, Sequence[str]],
    custom_message: Optional[str] = None,
    email_password_policy_enabled: Optional[bool] = None,
    guest_expiration_ts: Optional[Union[str, float]] = None,
    is_restricted: Optional[bool] = None,
    is_ultra_restricted: Optional[bool] = None,
    real_name: Optional[str] = None,
    resend: Optional[bool] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Invite a user to a workspace.
    https://api.slack.com/methods/admin.users.invite
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;team_id&#34;: team_id,
            &#34;email&#34;: email,
            &#34;custom_message&#34;: custom_message,
            &#34;email_password_policy_enabled&#34;: email_password_policy_enabled,
            &#34;guest_expiration_ts&#34;: str(guest_expiration_ts) if guest_expiration_ts is not None else None,
            &#34;is_restricted&#34;: is_restricted,
            &#34;is_ultra_restricted&#34;: is_ultra_restricted,
            &#34;real_name&#34;: real_name,
            &#34;resend&#34;: resend,
        }
    )
    if isinstance(channel_ids, (list, Tuple)):
        kwargs.update({&#34;channel_ids&#34;: &#34;,&#34;.join(channel_ids)})
    else:
        kwargs.update({&#34;channel_ids&#34;: channel_ids})
    return self.api_call(&#34;admin.users.invite&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_list"><code class="name flex">
<span>def <span class="ident">admin_users_list</span></span>(<span>self, *, team_id: str, include_deactivated_user_workspaces: Optional[bool] = None, is_active: Optional[bool] = None, cursor: Optional[str] = None, limit: Optional[int] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>List users on a workspace
<a href="https://api.slack.com/methods/admin.users.list">https://api.slack.com/methods/admin.users.list</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_users_list(
    self,
    *,
    team_id: str,
    include_deactivated_user_workspaces: Optional[bool] = None,
    is_active: Optional[bool] = None,
    cursor: Optional[str] = None,
    limit: Optional[int] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;List users on a workspace
    https://api.slack.com/methods/admin.users.list
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;team_id&#34;: team_id,
            &#34;include_deactivated_user_workspaces&#34;: include_deactivated_user_workspaces,
            &#34;is_active&#34;: is_active,
            &#34;cursor&#34;: cursor,
            &#34;limit&#34;: limit,
        }
    )
    return self.api_call(&#34;admin.users.list&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_remove"><code class="name flex">
<span>def <span class="ident">admin_users_remove</span></span>(<span>self, *, team_id: str, user_id: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a user from a workspace.
<a href="https://api.slack.com/methods/admin.users.remove">https://api.slack.com/methods/admin.users.remove</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_users_remove(
    self,
    *,
    team_id: str,
    user_id: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Remove a user from a workspace.
    https://api.slack.com/methods/admin.users.remove
    &#34;&#34;&#34;
    kwargs.update({&#34;team_id&#34;: team_id, &#34;user_id&#34;: user_id})
    return self.api_call(&#34;admin.users.remove&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_session_clearSettings"><code class="name flex">
<span>def <span class="ident">admin_users_session_clearSettings</span></span>(<span>self, *, user_ids: Union[str, Sequence[str]], **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Clear user-specific session settings—the session duration
and what happens when the client closes—for a list of users.
<a href="https://api.slack.com/methods/admin.users.session.clearSettings">https://api.slack.com/methods/admin.users.session.clearSettings</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_users_session_clearSettings(
    self,
    *,
    user_ids: Union[str, Sequence[str]],
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Clear user-specific session settings—the session duration
    and what happens when the client closes—for a list of users.
    https://api.slack.com/methods/admin.users.session.clearSettings
    &#34;&#34;&#34;
    if isinstance(user_ids, (list, Tuple)):
        kwargs.update({&#34;user_ids&#34;: &#34;,&#34;.join(user_ids)})
    else:
        kwargs.update({&#34;user_ids&#34;: user_ids})
    return self.api_call(&#34;admin.users.session.clearSettings&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_session_getSettings"><code class="name flex">
<span>def <span class="ident">admin_users_session_getSettings</span></span>(<span>self, *, user_ids: Union[str, Sequence[str]], **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get user-specific session settings—the session duration
and what happens when the client closes—given a list of users.
<a href="https://api.slack.com/methods/admin.users.session.getSettings">https://api.slack.com/methods/admin.users.session.getSettings</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_users_session_getSettings(
    self,
    *,
    user_ids: Union[str, Sequence[str]],
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Get user-specific session settings—the session duration
    and what happens when the client closes—given a list of users.
    https://api.slack.com/methods/admin.users.session.getSettings
    &#34;&#34;&#34;
    if isinstance(user_ids, (list, Tuple)):
        kwargs.update({&#34;user_ids&#34;: &#34;,&#34;.join(user_ids)})
    else:
        kwargs.update({&#34;user_ids&#34;: user_ids})
    return self.api_call(&#34;admin.users.session.getSettings&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_session_invalidate"><code class="name flex">
<span>def <span class="ident">admin_users_session_invalidate</span></span>(<span>self, *, session_id: str, team_id: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Invalidate a single session for a user by session_id.
<a href="https://api.slack.com/methods/admin.users.session.invalidate">https://api.slack.com/methods/admin.users.session.invalidate</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_users_session_invalidate(
    self,
    *,
    session_id: str,
    team_id: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Invalidate a single session for a user by session_id.
    https://api.slack.com/methods/admin.users.session.invalidate
    &#34;&#34;&#34;
    kwargs.update({&#34;session_id&#34;: session_id, &#34;team_id&#34;: team_id})
    return self.api_call(&#34;admin.users.session.invalidate&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_session_list"><code class="name flex">
<span>def <span class="ident">admin_users_session_list</span></span>(<span>self, *, cursor: Optional[str] = None, limit: Optional[int] = None, team_id: Optional[str] = None, user_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Lists all active user sessions for an organization
<a href="https://api.slack.com/methods/admin.users.session.list">https://api.slack.com/methods/admin.users.session.list</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_users_session_list(
    self,
    *,
    cursor: Optional[str] = None,
    limit: Optional[int] = None,
    team_id: Optional[str] = None,
    user_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Lists all active user sessions for an organization
    https://api.slack.com/methods/admin.users.session.list
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;cursor&#34;: cursor,
            &#34;limit&#34;: limit,
            &#34;team_id&#34;: team_id,
            &#34;user_id&#34;: user_id,
        }
    )
    return self.api_call(&#34;admin.users.session.list&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_session_reset"><code class="name flex">
<span>def <span class="ident">admin_users_session_reset</span></span>(<span>self, *, user_id: str, mobile_only: Optional[bool] = None, web_only: Optional[bool] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Wipes all valid sessions on all devices for a given user.
<a href="https://api.slack.com/methods/admin.users.session.reset">https://api.slack.com/methods/admin.users.session.reset</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_users_session_reset(
    self,
    *,
    user_id: str,
    mobile_only: Optional[bool] = None,
    web_only: Optional[bool] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Wipes all valid sessions on all devices for a given user.
    https://api.slack.com/methods/admin.users.session.reset
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;user_id&#34;: user_id,
            &#34;mobile_only&#34;: mobile_only,
            &#34;web_only&#34;: web_only,
        }
    )
    return self.api_call(&#34;admin.users.session.reset&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_session_resetBulk"><code class="name flex">
<span>def <span class="ident">admin_users_session_resetBulk</span></span>(<span>self, *, user_ids: Union[str, Sequence[str]], mobile_only: Optional[bool] = None, web_only: Optional[bool] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Enqueues an asynchronous job to wipe all valid sessions on all devices for a given list of users
<a href="https://api.slack.com/methods/admin.users.session.resetBulk">https://api.slack.com/methods/admin.users.session.resetBulk</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_users_session_resetBulk(
    self,
    *,
    user_ids: Union[str, Sequence[str]],
    mobile_only: Optional[bool] = None,
    web_only: Optional[bool] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Enqueues an asynchronous job to wipe all valid sessions on all devices for a given list of users
    https://api.slack.com/methods/admin.users.session.resetBulk
    &#34;&#34;&#34;
    if isinstance(user_ids, (list, Tuple)):
        kwargs.update({&#34;user_ids&#34;: &#34;,&#34;.join(user_ids)})
    else:
        kwargs.update({&#34;user_ids&#34;: user_ids})
    kwargs.update(
        {
            &#34;mobile_only&#34;: mobile_only,
            &#34;web_only&#34;: web_only,
        }
    )
    return self.api_call(&#34;admin.users.session.resetBulk&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_session_setSettings"><code class="name flex">
<span>def <span class="ident">admin_users_session_setSettings</span></span>(<span>self, *, user_ids: Union[str, Sequence[str]], desktop_app_browser_quit: Optional[bool] = None, duration: Optional[int] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Configure the user-level session settings—the session duration
and what happens when the client closes—for one or more users.
<a href="https://api.slack.com/methods/admin.users.session.setSettings">https://api.slack.com/methods/admin.users.session.setSettings</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_users_session_setSettings(
    self,
    *,
    user_ids: Union[str, Sequence[str]],
    desktop_app_browser_quit: Optional[bool] = None,
    duration: Optional[int] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Configure the user-level session settings—the session duration
    and what happens when the client closes—for one or more users.
    https://api.slack.com/methods/admin.users.session.setSettings
    &#34;&#34;&#34;
    if isinstance(user_ids, (list, Tuple)):
        kwargs.update({&#34;user_ids&#34;: &#34;,&#34;.join(user_ids)})
    else:
        kwargs.update({&#34;user_ids&#34;: user_ids})
    kwargs.update(
        {
            &#34;desktop_app_browser_quit&#34;: desktop_app_browser_quit,
            &#34;duration&#34;: duration,
        }
    )
    return self.api_call(&#34;admin.users.session.setSettings&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_setAdmin"><code class="name flex">
<span>def <span class="ident">admin_users_setAdmin</span></span>(<span>self, *, team_id: str, user_id: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Set an existing guest, regular user, or owner to be an admin user.
<a href="https://api.slack.com/methods/admin.users.setAdmin">https://api.slack.com/methods/admin.users.setAdmin</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_users_setAdmin(
    self,
    *,
    team_id: str,
    user_id: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Set an existing guest, regular user, or owner to be an admin user.
    https://api.slack.com/methods/admin.users.setAdmin
    &#34;&#34;&#34;
    kwargs.update({&#34;team_id&#34;: team_id, &#34;user_id&#34;: user_id})
    return self.api_call(&#34;admin.users.setAdmin&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_setExpiration"><code class="name flex">
<span>def <span class="ident">admin_users_setExpiration</span></span>(<span>self, *, expiration_ts: int, user_id: str, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Set an expiration for a guest user.
<a href="https://api.slack.com/methods/admin.users.setExpiration">https://api.slack.com/methods/admin.users.setExpiration</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_users_setExpiration(
    self,
    *,
    expiration_ts: int,
    user_id: str,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Set an expiration for a guest user.
    https://api.slack.com/methods/admin.users.setExpiration
    &#34;&#34;&#34;
    kwargs.update({&#34;expiration_ts&#34;: expiration_ts, &#34;team_id&#34;: team_id, &#34;user_id&#34;: user_id})
    return self.api_call(&#34;admin.users.setExpiration&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_setOwner"><code class="name flex">
<span>def <span class="ident">admin_users_setOwner</span></span>(<span>self, *, team_id: str, user_id: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Set an existing guest, regular user, or admin user to be a workspace owner.
<a href="https://api.slack.com/methods/admin.users.setOwner">https://api.slack.com/methods/admin.users.setOwner</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_users_setOwner(
    self,
    *,
    team_id: str,
    user_id: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Set an existing guest, regular user, or admin user to be a workspace owner.
    https://api.slack.com/methods/admin.users.setOwner
    &#34;&#34;&#34;
    kwargs.update({&#34;team_id&#34;: team_id, &#34;user_id&#34;: user_id})
    return self.api_call(&#34;admin.users.setOwner&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_setRegular"><code class="name flex">
<span>def <span class="ident">admin_users_setRegular</span></span>(<span>self, *, team_id: str, user_id: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Set an existing guest user, admin user, or owner to be a regular user.
<a href="https://api.slack.com/methods/admin.users.setRegular">https://api.slack.com/methods/admin.users.setRegular</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_users_setRegular(
    self,
    *,
    team_id: str,
    user_id: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Set an existing guest user, admin user, or owner to be a regular user.
    https://api.slack.com/methods/admin.users.setRegular
    &#34;&#34;&#34;
    kwargs.update({&#34;team_id&#34;: team_id, &#34;user_id&#34;: user_id})
    return self.api_call(&#34;admin.users.setRegular&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_unsupportedVersions_export"><code class="name flex">
<span>def <span class="ident">admin_users_unsupportedVersions_export</span></span>(<span>self, *, date_end_of_support: Union[str, int, ForwardRef(None)] = None, date_sessions_started: Union[str, int, ForwardRef(None)] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Ask Slackbot to send you an export listing all workspace members using unsupported software,
presented as a zipped CSV file.
<a href="https://api.slack.com/methods/admin.users.unsupportedVersions.export">https://api.slack.com/methods/admin.users.unsupportedVersions.export</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_users_unsupportedVersions_export(
    self,
    *,
    date_end_of_support: Optional[Union[str, int]] = None,
    date_sessions_started: Optional[Union[str, int]] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Ask Slackbot to send you an export listing all workspace members using unsupported software,
    presented as a zipped CSV file.
    https://api.slack.com/methods/admin.users.unsupportedVersions.export
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;date_end_of_support&#34;: date_end_of_support,
            &#34;date_sessions_started&#34;: date_sessions_started,
        }
    )
    return self.api_call(&#34;admin.users.unsupportedVersions.export&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_workflows_collaborators_add"><code class="name flex">
<span>def <span class="ident">admin_workflows_collaborators_add</span></span>(<span>self, *, collaborator_ids: Union[str, Sequence[str]], workflow_ids: Union[str, Sequence[str]], **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Add collaborators to workflows within the team or enterprise
<a href="https://api.slack.com/methods/admin.workflows.collaborators.add">https://api.slack.com/methods/admin.workflows.collaborators.add</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_workflows_collaborators_add(
    self,
    *,
    collaborator_ids: Union[str, Sequence[str]],
    workflow_ids: Union[str, Sequence[str]],
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Add collaborators to workflows within the team or enterprise
    https://api.slack.com/methods/admin.workflows.collaborators.add
    &#34;&#34;&#34;
    if isinstance(collaborator_ids, (list, Tuple)):
        kwargs.update({&#34;collaborator_ids&#34;: &#34;,&#34;.join(collaborator_ids)})
    else:
        kwargs.update({&#34;collaborator_ids&#34;: collaborator_ids})
    if isinstance(workflow_ids, (list, Tuple)):
        kwargs.update({&#34;workflow_ids&#34;: &#34;,&#34;.join(workflow_ids)})
    else:
        kwargs.update({&#34;workflow_ids&#34;: workflow_ids})
    return self.api_call(&#34;admin.workflows.collaborators.add&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_workflows_collaborators_remove"><code class="name flex">
<span>def <span class="ident">admin_workflows_collaborators_remove</span></span>(<span>self, *, collaborator_ids: Union[str, Sequence[str]], workflow_ids: Union[str, Sequence[str]], **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Remove collaborators from workflows within the team or enterprise
<a href="https://api.slack.com/methods/admin.workflows.collaborators.remove">https://api.slack.com/methods/admin.workflows.collaborators.remove</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_workflows_collaborators_remove(
    self,
    *,
    collaborator_ids: Union[str, Sequence[str]],
    workflow_ids: Union[str, Sequence[str]],
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Remove collaborators from workflows within the team or enterprise
    https://api.slack.com/methods/admin.workflows.collaborators.remove
    &#34;&#34;&#34;
    if isinstance(collaborator_ids, (list, Tuple)):
        kwargs.update({&#34;collaborator_ids&#34;: &#34;,&#34;.join(collaborator_ids)})
    else:
        kwargs.update({&#34;collaborator_ids&#34;: collaborator_ids})
    if isinstance(workflow_ids, (list, Tuple)):
        kwargs.update({&#34;workflow_ids&#34;: &#34;,&#34;.join(workflow_ids)})
    else:
        kwargs.update({&#34;workflow_ids&#34;: workflow_ids})
    return self.api_call(&#34;admin.workflows.collaborators.remove&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_workflows_permissions_lookup"><code class="name flex">
<span>def <span class="ident">admin_workflows_permissions_lookup</span></span>(<span>self, *, workflow_ids: Union[str, Sequence[str]], max_workflow_triggers: Optional[int] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Look up the permissions for a set of workflows
<a href="https://api.slack.com/methods/admin.workflows.permissions.lookup">https://api.slack.com/methods/admin.workflows.permissions.lookup</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_workflows_permissions_lookup(
    self,
    *,
    workflow_ids: Union[str, Sequence[str]],
    max_workflow_triggers: Optional[int] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Look up the permissions for a set of workflows
    https://api.slack.com/methods/admin.workflows.permissions.lookup
    &#34;&#34;&#34;
    if isinstance(workflow_ids, (list, Tuple)):
        kwargs.update({&#34;workflow_ids&#34;: &#34;,&#34;.join(workflow_ids)})
    else:
        kwargs.update({&#34;workflow_ids&#34;: workflow_ids})
    kwargs.update(
        {
            &#34;max_workflow_triggers&#34;: max_workflow_triggers,
        }
    )
    return self.api_call(&#34;admin.workflows.permissions.lookup&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_workflows_search"><code class="name flex">
<span>def <span class="ident">admin_workflows_search</span></span>(<span>self, *, app_id: Optional[str] = None, collaborator_ids: Union[str, Sequence[str], ForwardRef(None)] = None, cursor: Optional[str] = None, limit: Optional[int] = None, no_collaborators: Optional[bool] = None, num_trigger_ids: Optional[int] = None, query: Optional[str] = None, sort: Optional[str] = None, sort_dir: Optional[str] = None, source: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Search workflows within the team or enterprise
<a href="https://api.slack.com/methods/admin.workflows.search">https://api.slack.com/methods/admin.workflows.search</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_workflows_search(
    self,
    *,
    app_id: Optional[str] = None,
    collaborator_ids: Optional[Union[str, Sequence[str]]] = None,
    cursor: Optional[str] = None,
    limit: Optional[int] = None,
    no_collaborators: Optional[bool] = None,
    num_trigger_ids: Optional[int] = None,
    query: Optional[str] = None,
    sort: Optional[str] = None,
    sort_dir: Optional[str] = None,
    source: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Search workflows within the team or enterprise
    https://api.slack.com/methods/admin.workflows.search
    &#34;&#34;&#34;
    if collaborator_ids is not None:
        if isinstance(collaborator_ids, (list, Tuple)):
            kwargs.update({&#34;collaborator_ids&#34;: &#34;,&#34;.join(collaborator_ids)})
        else:
            kwargs.update({&#34;collaborator_ids&#34;: collaborator_ids})
    kwargs.update(
        {
            &#34;app_id&#34;: app_id,
            &#34;cursor&#34;: cursor,
            &#34;limit&#34;: limit,
            &#34;no_collaborators&#34;: no_collaborators,
            &#34;num_trigger_ids&#34;: num_trigger_ids,
            &#34;query&#34;: query,
            &#34;sort&#34;: sort,
            &#34;sort_dir&#34;: sort_dir,
            &#34;source&#34;: source,
        }
    )
    return self.api_call(&#34;admin.workflows.search&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.admin_workflows_unpublish"><code class="name flex">
<span>def <span class="ident">admin_workflows_unpublish</span></span>(<span>self, *, workflow_ids: Union[str, Sequence[str]], **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Unpublish workflows within the team or enterprise
<a href="https://api.slack.com/methods/admin.workflows.unpublish">https://api.slack.com/methods/admin.workflows.unpublish</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def admin_workflows_unpublish(
    self,
    *,
    workflow_ids: Union[str, Sequence[str]],
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Unpublish workflows within the team or enterprise
    https://api.slack.com/methods/admin.workflows.unpublish
    &#34;&#34;&#34;
    if isinstance(workflow_ids, (list, Tuple)):
        kwargs.update({&#34;workflow_ids&#34;: &#34;,&#34;.join(workflow_ids)})
    else:
        kwargs.update({&#34;workflow_ids&#34;: workflow_ids})
    return self.api_call(&#34;admin.workflows.unpublish&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.api_test"><code class="name flex">
<span>def <span class="ident">api_test</span></span>(<span>self, *, error: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Checks API calling code.
<a href="https://api.slack.com/methods/api.test">https://api.slack.com/methods/api.test</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def api_test(
    self,
    *,
    error: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Checks API calling code.
    https://api.slack.com/methods/api.test
    &#34;&#34;&#34;
    kwargs.update({&#34;error&#34;: error})
    return self.api_call(&#34;api.test&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.apps_connections_open"><code class="name flex">
<span>def <span class="ident">apps_connections_open</span></span>(<span>self, *, app_token: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a temporary Socket Mode WebSocket URL that your app can connect to
in order to receive events and interactive payloads
<a href="https://api.slack.com/methods/apps.connections.open">https://api.slack.com/methods/apps.connections.open</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apps_connections_open(
    self,
    *,
    app_token: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Generate a temporary Socket Mode WebSocket URL that your app can connect to
    in order to receive events and interactive payloads
    https://api.slack.com/methods/apps.connections.open
    &#34;&#34;&#34;
    kwargs.update({&#34;token&#34;: app_token})
    return self.api_call(&#34;apps.connections.open&#34;, http_verb=&#34;POST&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.apps_event_authorizations_list"><code class="name flex">
<span>def <span class="ident">apps_event_authorizations_list</span></span>(<span>self, *, event_context: str, cursor: Optional[str] = None, limit: Optional[int] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get a list of authorizations for the given event context.
Each authorization represents an app installation that the event is visible to.
<a href="https://api.slack.com/methods/apps.event.authorizations.list">https://api.slack.com/methods/apps.event.authorizations.list</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apps_event_authorizations_list(
    self,
    *,
    event_context: str,
    cursor: Optional[str] = None,
    limit: Optional[int] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Get a list of authorizations for the given event context.
    Each authorization represents an app installation that the event is visible to.
    https://api.slack.com/methods/apps.event.authorizations.list
    &#34;&#34;&#34;
    kwargs.update({&#34;event_context&#34;: event_context, &#34;cursor&#34;: cursor, &#34;limit&#34;: limit})
    return self.api_call(&#34;apps.event.authorizations.list&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.apps_manifest_create"><code class="name flex">
<span>def <span class="ident">apps_manifest_create</span></span>(<span>self, *, manifest: Union[str, Dict[str, Any]], **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Create an app from an app manifest
<a href="https://api.slack.com/methods/apps.manifest.create">https://api.slack.com/methods/apps.manifest.create</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apps_manifest_create(
    self,
    *,
    manifest: Union[str, Dict[str, Any]],
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Create an app from an app manifest
    https://api.slack.com/methods/apps.manifest.create
    &#34;&#34;&#34;
    if isinstance(manifest, str):
        kwargs.update({&#34;manifest&#34;: manifest})
    else:
        kwargs.update({&#34;manifest&#34;: json.dumps(manifest)})
    return self.api_call(&#34;apps.manifest.create&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.apps_manifest_delete"><code class="name flex">
<span>def <span class="ident">apps_manifest_delete</span></span>(<span>self, *, app_id: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Permanently deletes an app created through app manifests
<a href="https://api.slack.com/methods/apps.manifest.delete">https://api.slack.com/methods/apps.manifest.delete</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apps_manifest_delete(
    self,
    *,
    app_id: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Permanently deletes an app created through app manifests
    https://api.slack.com/methods/apps.manifest.delete
    &#34;&#34;&#34;
    kwargs.update({&#34;app_id&#34;: app_id})
    return self.api_call(&#34;apps.manifest.delete&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.apps_manifest_export"><code class="name flex">
<span>def <span class="ident">apps_manifest_export</span></span>(<span>self, *, app_id: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Export an app manifest from an existing app
<a href="https://api.slack.com/methods/apps.manifest.export">https://api.slack.com/methods/apps.manifest.export</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apps_manifest_export(
    self,
    *,
    app_id: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Export an app manifest from an existing app
    https://api.slack.com/methods/apps.manifest.export
    &#34;&#34;&#34;
    kwargs.update({&#34;app_id&#34;: app_id})
    return self.api_call(&#34;apps.manifest.export&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.apps_manifest_update"><code class="name flex">
<span>def <span class="ident">apps_manifest_update</span></span>(<span>self, *, app_id: str, manifest: Union[str, Dict[str, Any]], **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Update an app from an app manifest
<a href="https://api.slack.com/methods/apps.manifest.update">https://api.slack.com/methods/apps.manifest.update</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apps_manifest_update(
    self,
    *,
    app_id: str,
    manifest: Union[str, Dict[str, Any]],
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Update an app from an app manifest
    https://api.slack.com/methods/apps.manifest.update
    &#34;&#34;&#34;
    if isinstance(manifest, str):
        kwargs.update({&#34;manifest&#34;: manifest})
    else:
        kwargs.update({&#34;manifest&#34;: json.dumps(manifest)})
    kwargs.update({&#34;app_id&#34;: app_id})
    return self.api_call(&#34;apps.manifest.update&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.apps_manifest_validate"><code class="name flex">
<span>def <span class="ident">apps_manifest_validate</span></span>(<span>self, *, manifest: Union[str, Dict[str, Any]], app_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Validate an app manifest
<a href="https://api.slack.com/methods/apps.manifest.validate">https://api.slack.com/methods/apps.manifest.validate</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apps_manifest_validate(
    self,
    *,
    manifest: Union[str, Dict[str, Any]],
    app_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Validate an app manifest
    https://api.slack.com/methods/apps.manifest.validate
    &#34;&#34;&#34;
    if isinstance(manifest, str):
        kwargs.update({&#34;manifest&#34;: manifest})
    else:
        kwargs.update({&#34;manifest&#34;: json.dumps(manifest)})
    kwargs.update({&#34;app_id&#34;: app_id})
    return self.api_call(&#34;apps.manifest.validate&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.apps_uninstall"><code class="name flex">
<span>def <span class="ident">apps_uninstall</span></span>(<span>self, *, client_id: str, client_secret: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Uninstalls your app from a workspace.
<a href="https://api.slack.com/methods/apps.uninstall">https://api.slack.com/methods/apps.uninstall</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apps_uninstall(
    self,
    *,
    client_id: str,
    client_secret: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Uninstalls your app from a workspace.
    https://api.slack.com/methods/apps.uninstall
    &#34;&#34;&#34;
    kwargs.update({&#34;client_id&#34;: client_id, &#34;client_secret&#34;: client_secret})
    return self.api_call(&#34;apps.uninstall&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.auth_revoke"><code class="name flex">
<span>def <span class="ident">auth_revoke</span></span>(<span>self, *, test: Optional[bool] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Revokes a token.
<a href="https://api.slack.com/methods/auth.revoke">https://api.slack.com/methods/auth.revoke</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def auth_revoke(
    self,
    *,
    test: Optional[bool] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Revokes a token.
    https://api.slack.com/methods/auth.revoke
    &#34;&#34;&#34;
    kwargs.update({&#34;test&#34;: test})
    return self.api_call(&#34;auth.revoke&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.auth_teams_list"><code class="name flex">
<span>def <span class="ident">auth_teams_list</span></span>(<span>self, cursor: Optional[str] = None, limit: Optional[int] = None, include_icon: Optional[bool] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>List the workspaces a token can access.
<a href="https://api.slack.com/methods/auth.teams.list">https://api.slack.com/methods/auth.teams.list</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def auth_teams_list(
    self,
    cursor: Optional[str] = None,
    limit: Optional[int] = None,
    include_icon: Optional[bool] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;List the workspaces a token can access.
    https://api.slack.com/methods/auth.teams.list
    &#34;&#34;&#34;
    kwargs.update({&#34;cursor&#34;: cursor, &#34;limit&#34;: limit, &#34;include_icon&#34;: include_icon})
    return self.api_call(&#34;auth.teams.list&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.auth_test"><code class="name flex">
<span>def <span class="ident">auth_test</span></span>(<span>self, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Checks authentication &amp; identity.
<a href="https://api.slack.com/methods/auth.test">https://api.slack.com/methods/auth.test</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def auth_test(
    self,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Checks authentication &amp; identity.
    https://api.slack.com/methods/auth.test
    &#34;&#34;&#34;
    return self.api_call(&#34;auth.test&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.bookmarks_add"><code class="name flex">
<span>def <span class="ident">bookmarks_add</span></span>(<span>self, *, channel_id: str, title: str, type: str, emoji: Optional[str] = None, entity_id: Optional[str] = None, link: Optional[str] = None, parent_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Add bookmark to a channel.
<a href="https://api.slack.com/methods/bookmarks.add">https://api.slack.com/methods/bookmarks.add</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bookmarks_add(
    self,
    *,
    channel_id: str,
    title: str,
    type: str,
    emoji: Optional[str] = None,
    entity_id: Optional[str] = None,
    link: Optional[str] = None,  # include when type is &#39;link&#39;
    parent_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Add bookmark to a channel.
    https://api.slack.com/methods/bookmarks.add
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;channel_id&#34;: channel_id,
            &#34;title&#34;: title,
            &#34;type&#34;: type,
            &#34;emoji&#34;: emoji,
            &#34;entity_id&#34;: entity_id,
            &#34;link&#34;: link,
            &#34;parent_id&#34;: parent_id,
        }
    )
    return self.api_call(&#34;bookmarks.add&#34;, http_verb=&#34;POST&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.bookmarks_edit"><code class="name flex">
<span>def <span class="ident">bookmarks_edit</span></span>(<span>self, *, bookmark_id: str, channel_id: str, emoji: Optional[str] = None, link: Optional[str] = None, title: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Edit bookmark.
<a href="https://api.slack.com/methods/bookmarks.edit">https://api.slack.com/methods/bookmarks.edit</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bookmarks_edit(
    self,
    *,
    bookmark_id: str,
    channel_id: str,
    emoji: Optional[str] = None,
    link: Optional[str] = None,
    title: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Edit bookmark.
    https://api.slack.com/methods/bookmarks.edit
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;bookmark_id&#34;: bookmark_id,
            &#34;channel_id&#34;: channel_id,
            &#34;emoji&#34;: emoji,
            &#34;link&#34;: link,
            &#34;title&#34;: title,
        }
    )
    return self.api_call(&#34;bookmarks.edit&#34;, http_verb=&#34;POST&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.bookmarks_list"><code class="name flex">
<span>def <span class="ident">bookmarks_list</span></span>(<span>self, *, channel_id: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>List bookmark for the channel.
<a href="https://api.slack.com/methods/bookmarks.list">https://api.slack.com/methods/bookmarks.list</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bookmarks_list(
    self,
    *,
    channel_id: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;List bookmark for the channel.
    https://api.slack.com/methods/bookmarks.list
    &#34;&#34;&#34;
    kwargs.update({&#34;channel_id&#34;: channel_id})
    return self.api_call(&#34;bookmarks.list&#34;, http_verb=&#34;POST&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.bookmarks_remove"><code class="name flex">
<span>def <span class="ident">bookmarks_remove</span></span>(<span>self, *, bookmark_id: str, channel_id: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Remove bookmark from the channel.
<a href="https://api.slack.com/methods/bookmarks.remove">https://api.slack.com/methods/bookmarks.remove</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bookmarks_remove(
    self,
    *,
    bookmark_id: str,
    channel_id: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Remove bookmark from the channel.
    https://api.slack.com/methods/bookmarks.remove
    &#34;&#34;&#34;
    kwargs.update({&#34;bookmark_id&#34;: bookmark_id, &#34;channel_id&#34;: channel_id})
    return self.api_call(&#34;bookmarks.remove&#34;, http_verb=&#34;POST&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.bots_info"><code class="name flex">
<span>def <span class="ident">bots_info</span></span>(<span>self, *, bot: Optional[str] = None, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets information about a bot user.
<a href="https://api.slack.com/methods/bots.info">https://api.slack.com/methods/bots.info</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bots_info(
    self,
    *,
    bot: Optional[str] = None,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Gets information about a bot user.
    https://api.slack.com/methods/bots.info
    &#34;&#34;&#34;
    kwargs.update({&#34;bot&#34;: bot, &#34;team_id&#34;: team_id})
    return self.api_call(&#34;bots.info&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.calls_add"><code class="name flex">
<span>def <span class="ident">calls_add</span></span>(<span>self, *, external_unique_id: str, join_url: str, created_by: Optional[str] = None, date_start: Optional[int] = None, desktop_app_join_url: Optional[str] = None, external_display_id: Optional[str] = None, title: Optional[str] = None, users: Union[str, Sequence[Dict[str, str]], ForwardRef(None)] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Registers a new Call.
<a href="https://api.slack.com/methods/calls.add">https://api.slack.com/methods/calls.add</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calls_add(
    self,
    *,
    external_unique_id: str,
    join_url: str,
    created_by: Optional[str] = None,
    date_start: Optional[int] = None,
    desktop_app_join_url: Optional[str] = None,
    external_display_id: Optional[str] = None,
    title: Optional[str] = None,
    users: Optional[Union[str, Sequence[Dict[str, str]]]] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Registers a new Call.
    https://api.slack.com/methods/calls.add
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;external_unique_id&#34;: external_unique_id,
            &#34;join_url&#34;: join_url,
            &#34;created_by&#34;: created_by,
            &#34;date_start&#34;: date_start,
            &#34;desktop_app_join_url&#34;: desktop_app_join_url,
            &#34;external_display_id&#34;: external_display_id,
            &#34;title&#34;: title,
        }
    )
    _update_call_participants(  # skipcq: PTC-W0039
        kwargs,
        users if users is not None else kwargs.get(&#34;users&#34;),  # skipcq: PTC-W0039
    )  # skipcq: PTC-W0039
    return self.api_call(&#34;calls.add&#34;, http_verb=&#34;POST&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.calls_end"><code class="name flex">
<span>def <span class="ident">calls_end</span></span>(<span>self, *, id: str, duration: Optional[int] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Ends a Call.
<a href="https://api.slack.com/methods/calls.end">https://api.slack.com/methods/calls.end</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calls_end(
    self,
    *,
    id: str,
    duration: Optional[int] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:  # skipcq: PYL-W0622
    &#34;&#34;&#34;Ends a Call.
    https://api.slack.com/methods/calls.end
    &#34;&#34;&#34;
    kwargs.update({&#34;id&#34;: id, &#34;duration&#34;: duration})
    return self.api_call(&#34;calls.end&#34;, http_verb=&#34;POST&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.calls_info"><code class="name flex">
<span>def <span class="ident">calls_info</span></span>(<span>self, *, id: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns information about a Call.
<a href="https://api.slack.com/methods/calls.info">https://api.slack.com/methods/calls.info</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calls_info(
    self,
    *,
    id: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:  # skipcq: PYL-W0622
    &#34;&#34;&#34;Returns information about a Call.
    https://api.slack.com/methods/calls.info
    &#34;&#34;&#34;
    kwargs.update({&#34;id&#34;: id})
    return self.api_call(&#34;calls.info&#34;, http_verb=&#34;POST&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.calls_participants_add"><code class="name flex">
<span>def <span class="ident">calls_participants_add</span></span>(<span>self, *, id: str, users: Union[str, Sequence[Dict[str, str]]], **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Registers new participants added to a Call.
<a href="https://api.slack.com/methods/calls.participants.add">https://api.slack.com/methods/calls.participants.add</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calls_participants_add(
    self,
    *,
    id: str,  # skipcq: PYL-W0622
    users: Union[str, Sequence[Dict[str, str]]],
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Registers new participants added to a Call.
    https://api.slack.com/methods/calls.participants.add
    &#34;&#34;&#34;
    kwargs.update({&#34;id&#34;: id})
    _update_call_participants(kwargs, users)
    return self.api_call(&#34;calls.participants.add&#34;, http_verb=&#34;POST&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.calls_participants_remove"><code class="name flex">
<span>def <span class="ident">calls_participants_remove</span></span>(<span>self, *, id: str, users: Union[str, Sequence[Dict[str, str]]], **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Registers participants removed from a Call.
<a href="https://api.slack.com/methods/calls.participants.remove">https://api.slack.com/methods/calls.participants.remove</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calls_participants_remove(
    self,
    *,
    id: str,  # skipcq: PYL-W0622
    users: Union[str, Sequence[Dict[str, str]]],
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Registers participants removed from a Call.
    https://api.slack.com/methods/calls.participants.remove
    &#34;&#34;&#34;
    kwargs.update({&#34;id&#34;: id})
    _update_call_participants(kwargs, users)
    return self.api_call(&#34;calls.participants.remove&#34;, http_verb=&#34;POST&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.calls_update"><code class="name flex">
<span>def <span class="ident">calls_update</span></span>(<span>self, *, id: str, desktop_app_join_url: Optional[str] = None, join_url: Optional[str] = None, title: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Updates information about a Call.
<a href="https://api.slack.com/methods/calls.update">https://api.slack.com/methods/calls.update</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calls_update(
    self,
    *,
    id: str,
    desktop_app_join_url: Optional[str] = None,
    join_url: Optional[str] = None,
    title: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:  # skipcq: PYL-W0622
    &#34;&#34;&#34;Updates information about a Call.
    https://api.slack.com/methods/calls.update
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;id&#34;: id,
            &#34;desktop_app_join_url&#34;: desktop_app_join_url,
            &#34;join_url&#34;: join_url,
            &#34;title&#34;: title,
        }
    )
    return self.api_call(&#34;calls.update&#34;, http_verb=&#34;POST&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.channels_archive"><code class="name flex">
<span>def <span class="ident">channels_archive</span></span>(<span>self, *, channel: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Archives a channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def channels_archive(
    self,
    *,
    channel: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Archives a channel.&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel})
    kwargs = _remove_none_values(kwargs)
    return self.api_call(&#34;channels.archive&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.channels_create"><code class="name flex">
<span>def <span class="ident">channels_create</span></span>(<span>self, *, name: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def channels_create(
    self,
    *,
    name: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Creates a channel.&#34;&#34;&#34;
    kwargs.update({&#34;name&#34;: name})
    kwargs = _remove_none_values(kwargs)
    return self.api_call(&#34;channels.create&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.channels_history"><code class="name flex">
<span>def <span class="ident">channels_history</span></span>(<span>self, *, channel: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Fetches history of messages and events from a channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def channels_history(
    self,
    *,
    channel: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Fetches history of messages and events from a channel.&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel})
    return self.api_call(&#34;channels.history&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.channels_info"><code class="name flex">
<span>def <span class="ident">channels_info</span></span>(<span>self, *, channel: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets information about a channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def channels_info(
    self,
    *,
    channel: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Gets information about a channel.&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel})
    return self.api_call(&#34;channels.info&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.channels_invite"><code class="name flex">
<span>def <span class="ident">channels_invite</span></span>(<span>self, *, channel: str, user: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Invites a user to a channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def channels_invite(
    self,
    *,
    channel: str,
    user: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Invites a user to a channel.&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel, &#34;user&#34;: user})
    kwargs = _remove_none_values(kwargs)
    return self.api_call(&#34;channels.invite&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.channels_join"><code class="name flex">
<span>def <span class="ident">channels_join</span></span>(<span>self, *, name: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Joins a channel, creating it if needed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def channels_join(
    self,
    *,
    name: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Joins a channel, creating it if needed.&#34;&#34;&#34;
    kwargs.update({&#34;name&#34;: name})
    kwargs = _remove_none_values(kwargs)
    return self.api_call(&#34;channels.join&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.channels_kick"><code class="name flex">
<span>def <span class="ident">channels_kick</span></span>(<span>self, *, channel: str, user: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Removes a user from a channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def channels_kick(
    self,
    *,
    channel: str,
    user: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Removes a user from a channel.&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel, &#34;user&#34;: user})
    kwargs = _remove_none_values(kwargs)
    return self.api_call(&#34;channels.kick&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.channels_leave"><code class="name flex">
<span>def <span class="ident">channels_leave</span></span>(<span>self, *, channel: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Leaves a channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def channels_leave(
    self,
    *,
    channel: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Leaves a channel.&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel})
    kwargs = _remove_none_values(kwargs)
    return self.api_call(&#34;channels.leave&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.channels_list"><code class="name flex">
<span>def <span class="ident">channels_list</span></span>(<span>self, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Lists all channels in a Slack team.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def channels_list(
    self,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Lists all channels in a Slack team.&#34;&#34;&#34;
    return self.api_call(&#34;channels.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.channels_mark"><code class="name flex">
<span>def <span class="ident">channels_mark</span></span>(<span>self, *, channel: str, ts: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the read cursor in a channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def channels_mark(
    self,
    *,
    channel: str,
    ts: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Sets the read cursor in a channel.&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel, &#34;ts&#34;: ts})
    kwargs = _remove_none_values(kwargs)
    return self.api_call(&#34;channels.mark&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.channels_rename"><code class="name flex">
<span>def <span class="ident">channels_rename</span></span>(<span>self, *, channel: str, name: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Renames a channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def channels_rename(
    self,
    *,
    channel: str,
    name: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Renames a channel.&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel, &#34;name&#34;: name})
    kwargs = _remove_none_values(kwargs)
    return self.api_call(&#34;channels.rename&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.channels_replies"><code class="name flex">
<span>def <span class="ident">channels_replies</span></span>(<span>self, *, channel: str, thread_ts: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve a thread of messages posted to a channel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def channels_replies(
    self,
    *,
    channel: str,
    thread_ts: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Retrieve a thread of messages posted to a channel&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel, &#34;thread_ts&#34;: thread_ts})
    return self.api_call(&#34;channels.replies&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.channels_setPurpose"><code class="name flex">
<span>def <span class="ident">channels_setPurpose</span></span>(<span>self, *, channel: str, purpose: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the purpose for a channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def channels_setPurpose(
    self,
    *,
    channel: str,
    purpose: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Sets the purpose for a channel.&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel, &#34;purpose&#34;: purpose})
    kwargs = _remove_none_values(kwargs)
    return self.api_call(&#34;channels.setPurpose&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.channels_setTopic"><code class="name flex">
<span>def <span class="ident">channels_setTopic</span></span>(<span>self, *, channel: str, topic: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the topic for a channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def channels_setTopic(
    self,
    *,
    channel: str,
    topic: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Sets the topic for a channel.&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel, &#34;topic&#34;: topic})
    kwargs = _remove_none_values(kwargs)
    return self.api_call(&#34;channels.setTopic&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.channels_unarchive"><code class="name flex">
<span>def <span class="ident">channels_unarchive</span></span>(<span>self, *, channel: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Unarchives a channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def channels_unarchive(
    self,
    *,
    channel: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Unarchives a channel.&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel})
    kwargs = _remove_none_values(kwargs)
    return self.api_call(&#34;channels.unarchive&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.chat_delete"><code class="name flex">
<span>def <span class="ident">chat_delete</span></span>(<span>self, *, channel: str, ts: str, as_user: Optional[bool] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a message.
<a href="https://api.slack.com/methods/chat.delete">https://api.slack.com/methods/chat.delete</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chat_delete(
    self,
    *,
    channel: str,
    ts: str,
    as_user: Optional[bool] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Deletes a message.
    https://api.slack.com/methods/chat.delete
    &#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel, &#34;ts&#34;: ts, &#34;as_user&#34;: as_user})
    return self.api_call(&#34;chat.delete&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.chat_deleteScheduledMessage"><code class="name flex">
<span>def <span class="ident">chat_deleteScheduledMessage</span></span>(<span>self, *, channel: str, scheduled_message_id: str, as_user: Optional[bool] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a scheduled message.
<a href="https://api.slack.com/methods/chat.deleteScheduledMessage">https://api.slack.com/methods/chat.deleteScheduledMessage</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chat_deleteScheduledMessage(
    self,
    *,
    channel: str,
    scheduled_message_id: str,
    as_user: Optional[bool] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Deletes a scheduled message.
    https://api.slack.com/methods/chat.deleteScheduledMessage
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;channel&#34;: channel,
            &#34;scheduled_message_id&#34;: scheduled_message_id,
            &#34;as_user&#34;: as_user,
        }
    )
    return self.api_call(&#34;chat.deleteScheduledMessage&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.chat_getPermalink"><code class="name flex">
<span>def <span class="ident">chat_getPermalink</span></span>(<span>self, *, channel: str, message_ts: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve a permalink URL for a specific extant message
<a href="https://api.slack.com/methods/chat.getPermalink">https://api.slack.com/methods/chat.getPermalink</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chat_getPermalink(
    self,
    *,
    channel: str,
    message_ts: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Retrieve a permalink URL for a specific extant message
    https://api.slack.com/methods/chat.getPermalink
    &#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel, &#34;message_ts&#34;: message_ts})
    return self.api_call(&#34;chat.getPermalink&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.chat_meMessage"><code class="name flex">
<span>def <span class="ident">chat_meMessage</span></span>(<span>self, *, channel: str, text: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Share a me message into a channel.
<a href="https://api.slack.com/methods/chat.meMessage">https://api.slack.com/methods/chat.meMessage</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chat_meMessage(
    self,
    *,
    channel: str,
    text: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Share a me message into a channel.
    https://api.slack.com/methods/chat.meMessage
    &#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel, &#34;text&#34;: text})
    return self.api_call(&#34;chat.meMessage&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.chat_postEphemeral"><code class="name flex">
<span>def <span class="ident">chat_postEphemeral</span></span>(<span>self, *, channel: str, user: str, text: Optional[str] = None, as_user: Optional[bool] = None, attachments: Union[str, Sequence[Union[Dict, <a title="slack_sdk.models.attachments.Attachment" href="../models/attachments/index.html#slack_sdk.models.attachments.Attachment">Attachment</a>]], ForwardRef(None)] = None, blocks: Union[str, Sequence[Union[Dict, <a title="slack_sdk.models.blocks.blocks.Block" href="../models/blocks/blocks.html#slack_sdk.models.blocks.blocks.Block">Block</a>]], ForwardRef(None)] = None, thread_ts: Optional[str] = None, icon_emoji: Optional[str] = None, icon_url: Optional[str] = None, link_names: Optional[bool] = None, username: Optional[str] = None, parse: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Sends an ephemeral message to a user in a channel.
<a href="https://api.slack.com/methods/chat.postEphemeral">https://api.slack.com/methods/chat.postEphemeral</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chat_postEphemeral(
    self,
    *,
    channel: str,
    user: str,
    text: Optional[str] = None,
    as_user: Optional[bool] = None,
    attachments: Optional[Union[str, Sequence[Union[Dict, Attachment]]]] = None,
    blocks: Optional[Union[str, Sequence[Union[Dict, Block]]]] = None,
    thread_ts: Optional[str] = None,
    icon_emoji: Optional[str] = None,
    icon_url: Optional[str] = None,
    link_names: Optional[bool] = None,
    username: Optional[str] = None,
    parse: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Sends an ephemeral message to a user in a channel.
    https://api.slack.com/methods/chat.postEphemeral
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;channel&#34;: channel,
            &#34;user&#34;: user,
            &#34;text&#34;: text,
            &#34;as_user&#34;: as_user,
            &#34;attachments&#34;: attachments,
            &#34;blocks&#34;: blocks,
            &#34;thread_ts&#34;: thread_ts,
            &#34;icon_emoji&#34;: icon_emoji,
            &#34;icon_url&#34;: icon_url,
            &#34;link_names&#34;: link_names,
            &#34;username&#34;: username,
            &#34;parse&#34;: parse,
        }
    )
    _parse_web_class_objects(kwargs)
    kwargs = _remove_none_values(kwargs)
    _warn_if_text_or_attachment_fallback_is_missing(&#34;chat.postEphemeral&#34;, kwargs)
    # NOTE: intentionally using json over params for the API methods using blocks/attachments
    return self.api_call(&#34;chat.postEphemeral&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.chat_postMessage"><code class="name flex">
<span>def <span class="ident">chat_postMessage</span></span>(<span>self, *, channel: str, text: Optional[str] = None, as_user: Optional[bool] = None, attachments: Union[str, Sequence[Union[Dict, <a title="slack_sdk.models.attachments.Attachment" href="../models/attachments/index.html#slack_sdk.models.attachments.Attachment">Attachment</a>]], ForwardRef(None)] = None, blocks: Union[str, Sequence[Union[Dict, <a title="slack_sdk.models.blocks.blocks.Block" href="../models/blocks/blocks.html#slack_sdk.models.blocks.blocks.Block">Block</a>]], ForwardRef(None)] = None, thread_ts: Optional[str] = None, reply_broadcast: Optional[bool] = None, unfurl_links: Optional[bool] = None, unfurl_media: Optional[bool] = None, container_id: Optional[str] = None, icon_emoji: Optional[str] = None, icon_url: Optional[str] = None, mrkdwn: Optional[bool] = None, link_names: Optional[bool] = None, username: Optional[str] = None, parse: Optional[str] = None, metadata: Union[Dict, <a title="slack_sdk.models.metadata.Metadata" href="../models/metadata/index.html#slack_sdk.models.metadata.Metadata">Metadata</a>, ForwardRef(None)] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Sends a message to a channel.
<a href="https://api.slack.com/methods/chat.postMessage">https://api.slack.com/methods/chat.postMessage</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chat_postMessage(
    self,
    *,
    channel: str,
    text: Optional[str] = None,
    as_user: Optional[bool] = None,
    attachments: Optional[Union[str, Sequence[Union[Dict, Attachment]]]] = None,
    blocks: Optional[Union[str, Sequence[Union[Dict, Block]]]] = None,
    thread_ts: Optional[str] = None,
    reply_broadcast: Optional[bool] = None,
    unfurl_links: Optional[bool] = None,
    unfurl_media: Optional[bool] = None,
    container_id: Optional[str] = None,
    icon_emoji: Optional[str] = None,
    icon_url: Optional[str] = None,
    mrkdwn: Optional[bool] = None,
    link_names: Optional[bool] = None,
    username: Optional[str] = None,
    parse: Optional[str] = None,  # none, full
    metadata: Optional[Union[Dict, Metadata]] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Sends a message to a channel.
    https://api.slack.com/methods/chat.postMessage
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;channel&#34;: channel,
            &#34;text&#34;: text,
            &#34;as_user&#34;: as_user,
            &#34;attachments&#34;: attachments,
            &#34;blocks&#34;: blocks,
            &#34;thread_ts&#34;: thread_ts,
            &#34;reply_broadcast&#34;: reply_broadcast,
            &#34;unfurl_links&#34;: unfurl_links,
            &#34;unfurl_media&#34;: unfurl_media,
            &#34;container_id&#34;: container_id,
            &#34;icon_emoji&#34;: icon_emoji,
            &#34;icon_url&#34;: icon_url,
            &#34;mrkdwn&#34;: mrkdwn,
            &#34;link_names&#34;: link_names,
            &#34;username&#34;: username,
            &#34;parse&#34;: parse,
            &#34;metadata&#34;: metadata,
        }
    )
    _parse_web_class_objects(kwargs)
    kwargs = _remove_none_values(kwargs)
    _warn_if_text_or_attachment_fallback_is_missing(&#34;chat.postMessage&#34;, kwargs)
    # NOTE: intentionally using json over params for the API methods using blocks/attachments
    return self.api_call(&#34;chat.postMessage&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.chat_scheduleMessage"><code class="name flex">
<span>def <span class="ident">chat_scheduleMessage</span></span>(<span>self, *, channel: str, post_at: Union[str, int], text: str, as_user: Optional[bool] = None, attachments: Union[str, Sequence[Union[Dict, <a title="slack_sdk.models.attachments.Attachment" href="../models/attachments/index.html#slack_sdk.models.attachments.Attachment">Attachment</a>]], ForwardRef(None)] = None, blocks: Union[str, Sequence[Union[Dict, <a title="slack_sdk.models.blocks.blocks.Block" href="../models/blocks/blocks.html#slack_sdk.models.blocks.blocks.Block">Block</a>]], ForwardRef(None)] = None, thread_ts: Optional[str] = None, parse: Optional[str] = None, reply_broadcast: Optional[bool] = None, unfurl_links: Optional[bool] = None, unfurl_media: Optional[bool] = None, link_names: Optional[bool] = None, metadata: Union[Dict, <a title="slack_sdk.models.metadata.Metadata" href="../models/metadata/index.html#slack_sdk.models.metadata.Metadata">Metadata</a>, ForwardRef(None)] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Schedules a message.
<a href="https://api.slack.com/methods/chat.scheduleMessage">https://api.slack.com/methods/chat.scheduleMessage</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chat_scheduleMessage(
    self,
    *,
    channel: str,
    post_at: Union[str, int],
    text: str,
    as_user: Optional[bool] = None,
    attachments: Optional[Union[str, Sequence[Union[Dict, Attachment]]]] = None,
    blocks: Optional[Union[str, Sequence[Union[Dict, Block]]]] = None,
    thread_ts: Optional[str] = None,
    parse: Optional[str] = None,
    reply_broadcast: Optional[bool] = None,
    unfurl_links: Optional[bool] = None,
    unfurl_media: Optional[bool] = None,
    link_names: Optional[bool] = None,
    metadata: Optional[Union[Dict, Metadata]] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Schedules a message.
    https://api.slack.com/methods/chat.scheduleMessage
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;channel&#34;: channel,
            &#34;post_at&#34;: post_at,
            &#34;text&#34;: text,
            &#34;as_user&#34;: as_user,
            &#34;attachments&#34;: attachments,
            &#34;blocks&#34;: blocks,
            &#34;thread_ts&#34;: thread_ts,
            &#34;reply_broadcast&#34;: reply_broadcast,
            &#34;parse&#34;: parse,
            &#34;unfurl_links&#34;: unfurl_links,
            &#34;unfurl_media&#34;: unfurl_media,
            &#34;link_names&#34;: link_names,
            &#34;metadata&#34;: metadata,
        }
    )
    _parse_web_class_objects(kwargs)
    kwargs = _remove_none_values(kwargs)
    _warn_if_text_or_attachment_fallback_is_missing(&#34;chat.scheduleMessage&#34;, kwargs)
    # NOTE: intentionally using json over params for the API methods using blocks/attachments
    return self.api_call(&#34;chat.scheduleMessage&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.chat_scheduledMessages_list"><code class="name flex">
<span>def <span class="ident">chat_scheduledMessages_list</span></span>(<span>self, *, channel: Optional[str] = None, cursor: Optional[str] = None, latest: Optional[str] = None, limit: Optional[int] = None, oldest: Optional[str] = None, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Lists all scheduled messages.
<a href="https://api.slack.com/methods/chat.scheduledMessages.list">https://api.slack.com/methods/chat.scheduledMessages.list</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chat_scheduledMessages_list(
    self,
    *,
    channel: Optional[str] = None,
    cursor: Optional[str] = None,
    latest: Optional[str] = None,
    limit: Optional[int] = None,
    oldest: Optional[str] = None,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Lists all scheduled messages.
    https://api.slack.com/methods/chat.scheduledMessages.list
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;channel&#34;: channel,
            &#34;cursor&#34;: cursor,
            &#34;latest&#34;: latest,
            &#34;limit&#34;: limit,
            &#34;oldest&#34;: oldest,
            &#34;team_id&#34;: team_id,
        }
    )
    return self.api_call(&#34;chat.scheduledMessages.list&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.chat_unfurl"><code class="name flex">
<span>def <span class="ident">chat_unfurl</span></span>(<span>self, *, channel: Optional[str] = None, ts: Optional[str] = None, source: Optional[str] = None, unfurl_id: Optional[str] = None, unfurls: Optional[Dict[str, Dict]] = None, user_auth_blocks: Union[str, Sequence[Union[Dict, <a title="slack_sdk.models.blocks.blocks.Block" href="../models/blocks/blocks.html#slack_sdk.models.blocks.blocks.Block">Block</a>]], ForwardRef(None)] = None, user_auth_message: Optional[str] = None, user_auth_required: Optional[bool] = None, user_auth_url: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Provide custom unfurl behavior for user-posted URLs.
<a href="https://api.slack.com/methods/chat.unfurl">https://api.slack.com/methods/chat.unfurl</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chat_unfurl(
    self,
    *,
    channel: Optional[str] = None,
    ts: Optional[str] = None,
    source: Optional[str] = None,
    unfurl_id: Optional[str] = None,
    unfurls: Optional[Dict[str, Dict]] = None,  # or user_auth_*
    user_auth_blocks: Optional[Union[str, Sequence[Union[Dict, Block]]]] = None,
    user_auth_message: Optional[str] = None,
    user_auth_required: Optional[bool] = None,
    user_auth_url: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Provide custom unfurl behavior for user-posted URLs.
    https://api.slack.com/methods/chat.unfurl
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;channel&#34;: channel,
            &#34;ts&#34;: ts,
            &#34;source&#34;: source,
            &#34;unfurl_id&#34;: unfurl_id,
            &#34;unfurls&#34;: unfurls,
            &#34;user_auth_blocks&#34;: user_auth_blocks,
            &#34;user_auth_message&#34;: user_auth_message,
            &#34;user_auth_required&#34;: user_auth_required,
            &#34;user_auth_url&#34;: user_auth_url,
        }
    )
    _parse_web_class_objects(kwargs)  # for user_auth_blocks
    kwargs = _remove_none_values(kwargs)
    # NOTE: intentionally using json over params for API methods using blocks/attachments
    return self.api_call(&#34;chat.unfurl&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.chat_update"><code class="name flex">
<span>def <span class="ident">chat_update</span></span>(<span>self, *, channel: str, ts: str, text: Optional[str] = None, attachments: Union[str, Sequence[Union[Dict, <a title="slack_sdk.models.attachments.Attachment" href="../models/attachments/index.html#slack_sdk.models.attachments.Attachment">Attachment</a>]], ForwardRef(None)] = None, blocks: Union[str, Sequence[Union[Dict, <a title="slack_sdk.models.blocks.blocks.Block" href="../models/blocks/blocks.html#slack_sdk.models.blocks.blocks.Block">Block</a>]], ForwardRef(None)] = None, as_user: Optional[bool] = None, file_ids: Union[str, Sequence[str], ForwardRef(None)] = None, link_names: Optional[bool] = None, parse: Optional[str] = None, reply_broadcast: Optional[bool] = None, metadata: Union[Dict, <a title="slack_sdk.models.metadata.Metadata" href="../models/metadata/index.html#slack_sdk.models.metadata.Metadata">Metadata</a>, ForwardRef(None)] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Updates a message in a channel.
<a href="https://api.slack.com/methods/chat.update">https://api.slack.com/methods/chat.update</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chat_update(
    self,
    *,
    channel: str,
    ts: str,
    text: Optional[str] = None,
    attachments: Optional[Union[str, Sequence[Union[Dict, Attachment]]]] = None,
    blocks: Optional[Union[str, Sequence[Union[Dict, Block]]]] = None,
    as_user: Optional[bool] = None,
    file_ids: Optional[Union[str, Sequence[str]]] = None,
    link_names: Optional[bool] = None,
    parse: Optional[str] = None,  # none, full
    reply_broadcast: Optional[bool] = None,
    metadata: Optional[Union[Dict, Metadata]] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Updates a message in a channel.
    https://api.slack.com/methods/chat.update
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;channel&#34;: channel,
            &#34;ts&#34;: ts,
            &#34;text&#34;: text,
            &#34;attachments&#34;: attachments,
            &#34;blocks&#34;: blocks,
            &#34;as_user&#34;: as_user,
            &#34;link_names&#34;: link_names,
            &#34;parse&#34;: parse,
            &#34;reply_broadcast&#34;: reply_broadcast,
            &#34;metadata&#34;: metadata,
        }
    )
    if isinstance(file_ids, (list, Tuple)):
        kwargs.update({&#34;file_ids&#34;: &#34;,&#34;.join(file_ids)})
    else:
        kwargs.update({&#34;file_ids&#34;: file_ids})
    _parse_web_class_objects(kwargs)
    kwargs = _remove_none_values(kwargs)
    _warn_if_text_or_attachment_fallback_is_missing(&#34;chat.update&#34;, kwargs)
    # NOTE: intentionally using json over params for API methods using blocks/attachments
    return self.api_call(&#34;chat.update&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.conversations_acceptSharedInvite"><code class="name flex">
<span>def <span class="ident">conversations_acceptSharedInvite</span></span>(<span>self, *, channel_name: str, channel_id: Optional[str] = None, invite_id: Optional[str] = None, free_trial_accepted: Optional[bool] = None, is_private: Optional[bool] = None, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Accepts an invitation to a Slack Connect channel.
<a href="https://api.slack.com/methods/conversations.acceptSharedInvite">https://api.slack.com/methods/conversations.acceptSharedInvite</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conversations_acceptSharedInvite(
    self,
    *,
    channel_name: str,
    channel_id: Optional[str] = None,
    invite_id: Optional[str] = None,
    free_trial_accepted: Optional[bool] = None,
    is_private: Optional[bool] = None,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Accepts an invitation to a Slack Connect channel.
    https://api.slack.com/methods/conversations.acceptSharedInvite
    &#34;&#34;&#34;
    if channel_id is None and invite_id is None:
        raise e.SlackRequestError(&#34;Either channel_id or invite_id must be provided.&#34;)
    kwargs.update(
        {
            &#34;channel_name&#34;: channel_name,
            &#34;channel_id&#34;: channel_id,
            &#34;invite_id&#34;: invite_id,
            &#34;free_trial_accepted&#34;: free_trial_accepted,
            &#34;is_private&#34;: is_private,
            &#34;team_id&#34;: team_id,
        }
    )
    return self.api_call(&#34;conversations.acceptSharedInvite&#34;, http_verb=&#34;POST&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.conversations_approveSharedInvite"><code class="name flex">
<span>def <span class="ident">conversations_approveSharedInvite</span></span>(<span>self, *, invite_id: str, target_team: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Approves an invitation to a Slack Connect channel.
<a href="https://api.slack.com/methods/conversations.approveSharedInvite">https://api.slack.com/methods/conversations.approveSharedInvite</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conversations_approveSharedInvite(
    self,
    *,
    invite_id: str,
    target_team: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Approves an invitation to a Slack Connect channel.
    https://api.slack.com/methods/conversations.approveSharedInvite
    &#34;&#34;&#34;
    kwargs.update({&#34;invite_id&#34;: invite_id, &#34;target_team&#34;: target_team})
    return self.api_call(&#34;conversations.approveSharedInvite&#34;, http_verb=&#34;POST&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.conversations_archive"><code class="name flex">
<span>def <span class="ident">conversations_archive</span></span>(<span>self, *, channel: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Archives a conversation.
<a href="https://api.slack.com/methods/conversations.archive">https://api.slack.com/methods/conversations.archive</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conversations_archive(
    self,
    *,
    channel: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Archives a conversation.
    https://api.slack.com/methods/conversations.archive
    &#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel})
    return self.api_call(&#34;conversations.archive&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.conversations_close"><code class="name flex">
<span>def <span class="ident">conversations_close</span></span>(<span>self, *, channel: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Closes a direct message or multi-person direct message.
<a href="https://api.slack.com/methods/conversations.close">https://api.slack.com/methods/conversations.close</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conversations_close(
    self,
    *,
    channel: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Closes a direct message or multi-person direct message.
    https://api.slack.com/methods/conversations.close
    &#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel})
    return self.api_call(&#34;conversations.close&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.conversations_create"><code class="name flex">
<span>def <span class="ident">conversations_create</span></span>(<span>self, *, name: str, is_private: Optional[bool] = None, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Initiates a public or private channel-based conversation
<a href="https://api.slack.com/methods/conversations.create">https://api.slack.com/methods/conversations.create</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conversations_create(
    self,
    *,
    name: str,
    is_private: Optional[bool] = None,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Initiates a public or private channel-based conversation
    https://api.slack.com/methods/conversations.create
    &#34;&#34;&#34;
    kwargs.update({&#34;name&#34;: name, &#34;is_private&#34;: is_private, &#34;team_id&#34;: team_id})
    return self.api_call(&#34;conversations.create&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.conversations_declineSharedInvite"><code class="name flex">
<span>def <span class="ident">conversations_declineSharedInvite</span></span>(<span>self, *, invite_id: str, target_team: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Declines a Slack Connect channel invite.
<a href="https://api.slack.com/methods/conversations.declineSharedInvite">https://api.slack.com/methods/conversations.declineSharedInvite</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conversations_declineSharedInvite(
    self,
    *,
    invite_id: str,
    target_team: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Declines a Slack Connect channel invite.
    https://api.slack.com/methods/conversations.declineSharedInvite
    &#34;&#34;&#34;
    kwargs.update({&#34;invite_id&#34;: invite_id, &#34;target_team&#34;: target_team})
    return self.api_call(&#34;conversations.declineSharedInvite&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.conversations_history"><code class="name flex">
<span>def <span class="ident">conversations_history</span></span>(<span>self, *, channel: str, cursor: Optional[str] = None, inclusive: Optional[bool] = None, include_all_metadata: Optional[bool] = None, latest: Optional[str] = None, limit: Optional[int] = None, oldest: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Fetches a conversation's history of messages and events.
<a href="https://api.slack.com/methods/conversations.history">https://api.slack.com/methods/conversations.history</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conversations_history(
    self,
    *,
    channel: str,
    cursor: Optional[str] = None,
    inclusive: Optional[bool] = None,
    include_all_metadata: Optional[bool] = None,
    latest: Optional[str] = None,
    limit: Optional[int] = None,
    oldest: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Fetches a conversation&#39;s history of messages and events.
    https://api.slack.com/methods/conversations.history
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;channel&#34;: channel,
            &#34;cursor&#34;: cursor,
            &#34;inclusive&#34;: inclusive,
            &#34;include_all_metadata&#34;: include_all_metadata,
            &#34;limit&#34;: limit,
            &#34;latest&#34;: latest,
            &#34;oldest&#34;: oldest,
        }
    )
    return self.api_call(&#34;conversations.history&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.conversations_info"><code class="name flex">
<span>def <span class="ident">conversations_info</span></span>(<span>self, *, channel: str, include_locale: Optional[bool] = None, include_num_members: Optional[bool] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve information about a conversation.
<a href="https://api.slack.com/methods/conversations.info">https://api.slack.com/methods/conversations.info</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conversations_info(
    self,
    *,
    channel: str,
    include_locale: Optional[bool] = None,
    include_num_members: Optional[bool] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Retrieve information about a conversation.
    https://api.slack.com/methods/conversations.info
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;channel&#34;: channel,
            &#34;include_locale&#34;: include_locale,
            &#34;include_num_members&#34;: include_num_members,
        }
    )
    return self.api_call(&#34;conversations.info&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.conversations_invite"><code class="name flex">
<span>def <span class="ident">conversations_invite</span></span>(<span>self, *, channel: str, users: Union[str, Sequence[str]], force: Optional[bool] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Invites users to a channel.
<a href="https://api.slack.com/methods/conversations.invite">https://api.slack.com/methods/conversations.invite</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conversations_invite(
    self,
    *,
    channel: str,
    users: Union[str, Sequence[str]],
    force: Optional[bool] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Invites users to a channel.
    https://api.slack.com/methods/conversations.invite
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;channel&#34;: channel,
            &#34;force&#34;: force,
        }
    )
    if isinstance(users, (list, Tuple)):
        kwargs.update({&#34;users&#34;: &#34;,&#34;.join(users)})
    else:
        kwargs.update({&#34;users&#34;: users})
    return self.api_call(&#34;conversations.invite&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.conversations_inviteShared"><code class="name flex">
<span>def <span class="ident">conversations_inviteShared</span></span>(<span>self, *, channel: str, emails: Union[str, Sequence[str], ForwardRef(None)] = None, user_ids: Union[str, Sequence[str], ForwardRef(None)] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Sends an invitation to a Slack Connect channel.
<a href="https://api.slack.com/methods/conversations.inviteShared">https://api.slack.com/methods/conversations.inviteShared</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conversations_inviteShared(
    self,
    *,
    channel: str,
    emails: Optional[Union[str, Sequence[str]]] = None,
    user_ids: Optional[Union[str, Sequence[str]]] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Sends an invitation to a Slack Connect channel.
    https://api.slack.com/methods/conversations.inviteShared
    &#34;&#34;&#34;
    if emails is None and user_ids is None:
        raise e.SlackRequestError(&#34;Either emails or user ids must be provided.&#34;)
    kwargs.update({&#34;channel&#34;: channel})
    if isinstance(emails, (list, Tuple)):
        kwargs.update({&#34;emails&#34;: &#34;,&#34;.join(emails)})
    else:
        kwargs.update({&#34;emails&#34;: emails})
    if isinstance(user_ids, (list, Tuple)):
        kwargs.update({&#34;user_ids&#34;: &#34;,&#34;.join(user_ids)})
    else:
        kwargs.update({&#34;user_ids&#34;: user_ids})
    return self.api_call(&#34;conversations.inviteShared&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.conversations_join"><code class="name flex">
<span>def <span class="ident">conversations_join</span></span>(<span>self, *, channel: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Joins an existing conversation.
<a href="https://api.slack.com/methods/conversations.join">https://api.slack.com/methods/conversations.join</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conversations_join(
    self,
    *,
    channel: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Joins an existing conversation.
    https://api.slack.com/methods/conversations.join
    &#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel})
    return self.api_call(&#34;conversations.join&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.conversations_kick"><code class="name flex">
<span>def <span class="ident">conversations_kick</span></span>(<span>self, *, channel: str, user: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Removes a user from a conversation.
<a href="https://api.slack.com/methods/conversations.kick">https://api.slack.com/methods/conversations.kick</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conversations_kick(
    self,
    *,
    channel: str,
    user: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Removes a user from a conversation.
    https://api.slack.com/methods/conversations.kick
    &#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel, &#34;user&#34;: user})
    return self.api_call(&#34;conversations.kick&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.conversations_leave"><code class="name flex">
<span>def <span class="ident">conversations_leave</span></span>(<span>self, *, channel: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Leaves a conversation.
<a href="https://api.slack.com/methods/conversations.leave">https://api.slack.com/methods/conversations.leave</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conversations_leave(
    self,
    *,
    channel: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Leaves a conversation.
    https://api.slack.com/methods/conversations.leave
    &#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel})
    return self.api_call(&#34;conversations.leave&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.conversations_list"><code class="name flex">
<span>def <span class="ident">conversations_list</span></span>(<span>self, *, cursor: Optional[str] = None, exclude_archived: Optional[bool] = None, limit: Optional[int] = None, team_id: Optional[str] = None, types: Union[str, Sequence[str], ForwardRef(None)] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Lists all channels in a Slack team.
<a href="https://api.slack.com/methods/conversations.list">https://api.slack.com/methods/conversations.list</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conversations_list(
    self,
    *,
    cursor: Optional[str] = None,
    exclude_archived: Optional[bool] = None,
    limit: Optional[int] = None,
    team_id: Optional[str] = None,
    types: Optional[Union[str, Sequence[str]]] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Lists all channels in a Slack team.
    https://api.slack.com/methods/conversations.list
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;cursor&#34;: cursor,
            &#34;exclude_archived&#34;: exclude_archived,
            &#34;limit&#34;: limit,
            &#34;team_id&#34;: team_id,
        }
    )
    if isinstance(types, (list, Tuple)):
        kwargs.update({&#34;types&#34;: &#34;,&#34;.join(types)})
    else:
        kwargs.update({&#34;types&#34;: types})
    return self.api_call(&#34;conversations.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.conversations_listConnectInvites"><code class="name flex">
<span>def <span class="ident">conversations_listConnectInvites</span></span>(<span>self, *, count: Optional[int] = None, cursor: Optional[str] = None, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>List shared channel invites that have been generated
or received but have not yet been approved by all parties.
<a href="https://api.slack.com/methods/conversations.listConnectInvites">https://api.slack.com/methods/conversations.listConnectInvites</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conversations_listConnectInvites(
    self,
    *,
    count: Optional[int] = None,
    cursor: Optional[str] = None,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;List shared channel invites that have been generated
    or received but have not yet been approved by all parties.
    https://api.slack.com/methods/conversations.listConnectInvites
    &#34;&#34;&#34;
    kwargs.update({&#34;count&#34;: count, &#34;cursor&#34;: cursor, &#34;team_id&#34;: team_id})
    return self.api_call(&#34;conversations.listConnectInvites&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.conversations_mark"><code class="name flex">
<span>def <span class="ident">conversations_mark</span></span>(<span>self, *, channel: str, ts: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the read cursor in a channel.
<a href="https://api.slack.com/methods/conversations.mark">https://api.slack.com/methods/conversations.mark</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conversations_mark(
    self,
    *,
    channel: str,
    ts: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Sets the read cursor in a channel.
    https://api.slack.com/methods/conversations.mark
    &#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel, &#34;ts&#34;: ts})
    return self.api_call(&#34;conversations.mark&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.conversations_members"><code class="name flex">
<span>def <span class="ident">conversations_members</span></span>(<span>self, *, channel: str, cursor: Optional[str] = None, limit: Optional[int] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve members of a conversation.
<a href="https://api.slack.com/methods/conversations.members">https://api.slack.com/methods/conversations.members</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conversations_members(
    self,
    *,
    channel: str,
    cursor: Optional[str] = None,
    limit: Optional[int] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Retrieve members of a conversation.
    https://api.slack.com/methods/conversations.members
    &#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel, &#34;cursor&#34;: cursor, &#34;limit&#34;: limit})
    return self.api_call(&#34;conversations.members&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.conversations_open"><code class="name flex">
<span>def <span class="ident">conversations_open</span></span>(<span>self, *, channel: Optional[str] = None, return_im: Optional[bool] = None, users: Union[str, Sequence[str], ForwardRef(None)] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Opens or resumes a direct message or multi-person direct message.
<a href="https://api.slack.com/methods/conversations.open">https://api.slack.com/methods/conversations.open</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conversations_open(
    self,
    *,
    channel: Optional[str] = None,
    return_im: Optional[bool] = None,
    users: Optional[Union[str, Sequence[str]]] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Opens or resumes a direct message or multi-person direct message.
    https://api.slack.com/methods/conversations.open
    &#34;&#34;&#34;
    if channel is None and users is None:
        raise e.SlackRequestError(&#34;Either channel or users must be provided.&#34;)
    kwargs.update({&#34;channel&#34;: channel, &#34;return_im&#34;: return_im})
    if isinstance(users, (list, Tuple)):
        kwargs.update({&#34;users&#34;: &#34;,&#34;.join(users)})
    else:
        kwargs.update({&#34;users&#34;: users})
    return self.api_call(&#34;conversations.open&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.conversations_rename"><code class="name flex">
<span>def <span class="ident">conversations_rename</span></span>(<span>self, *, channel: str, name: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Renames a conversation.
<a href="https://api.slack.com/methods/conversations.rename">https://api.slack.com/methods/conversations.rename</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conversations_rename(
    self,
    *,
    channel: str,
    name: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Renames a conversation.
    https://api.slack.com/methods/conversations.rename
    &#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel, &#34;name&#34;: name})
    return self.api_call(&#34;conversations.rename&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.conversations_replies"><code class="name flex">
<span>def <span class="ident">conversations_replies</span></span>(<span>self, *, channel: str, ts: str, cursor: Optional[str] = None, inclusive: Optional[bool] = None, include_all_metadata: Optional[bool] = None, latest: Optional[str] = None, limit: Optional[int] = None, oldest: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve a thread of messages posted to a conversation
<a href="https://api.slack.com/methods/conversations.replies">https://api.slack.com/methods/conversations.replies</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conversations_replies(
    self,
    *,
    channel: str,
    ts: str,
    cursor: Optional[str] = None,
    inclusive: Optional[bool] = None,
    include_all_metadata: Optional[bool] = None,
    latest: Optional[str] = None,
    limit: Optional[int] = None,
    oldest: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Retrieve a thread of messages posted to a conversation
    https://api.slack.com/methods/conversations.replies
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;channel&#34;: channel,
            &#34;ts&#34;: ts,
            &#34;cursor&#34;: cursor,
            &#34;inclusive&#34;: inclusive,
            &#34;include_all_metadata&#34;: include_all_metadata,
            &#34;limit&#34;: limit,
            &#34;latest&#34;: latest,
            &#34;oldest&#34;: oldest,
        }
    )
    return self.api_call(&#34;conversations.replies&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.conversations_setPurpose"><code class="name flex">
<span>def <span class="ident">conversations_setPurpose</span></span>(<span>self, *, channel: str, purpose: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the purpose for a conversation.
<a href="https://api.slack.com/methods/conversations.setPurpose">https://api.slack.com/methods/conversations.setPurpose</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conversations_setPurpose(
    self,
    *,
    channel: str,
    purpose: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Sets the purpose for a conversation.
    https://api.slack.com/methods/conversations.setPurpose
    &#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel, &#34;purpose&#34;: purpose})
    return self.api_call(&#34;conversations.setPurpose&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.conversations_setTopic"><code class="name flex">
<span>def <span class="ident">conversations_setTopic</span></span>(<span>self, *, channel: str, topic: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the topic for a conversation.
<a href="https://api.slack.com/methods/conversations.setTopic">https://api.slack.com/methods/conversations.setTopic</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conversations_setTopic(
    self,
    *,
    channel: str,
    topic: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Sets the topic for a conversation.
    https://api.slack.com/methods/conversations.setTopic
    &#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel, &#34;topic&#34;: topic})
    return self.api_call(&#34;conversations.setTopic&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.conversations_unarchive"><code class="name flex">
<span>def <span class="ident">conversations_unarchive</span></span>(<span>self, *, channel: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Reverses conversation archival.
<a href="https://api.slack.com/methods/conversations.unarchive">https://api.slack.com/methods/conversations.unarchive</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conversations_unarchive(
    self,
    *,
    channel: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Reverses conversation archival.
    https://api.slack.com/methods/conversations.unarchive
    &#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel})
    return self.api_call(&#34;conversations.unarchive&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.dialog_open"><code class="name flex">
<span>def <span class="ident">dialog_open</span></span>(<span>self, *, dialog: Dict[str, Any], trigger_id: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Open a dialog with a user.
<a href="https://api.slack.com/methods/dialog.open">https://api.slack.com/methods/dialog.open</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dialog_open(
    self,
    *,
    dialog: Dict[str, Any],
    trigger_id: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Open a dialog with a user.
    https://api.slack.com/methods/dialog.open
    &#34;&#34;&#34;
    kwargs.update({&#34;dialog&#34;: dialog, &#34;trigger_id&#34;: trigger_id})
    kwargs = _remove_none_values(kwargs)
    # NOTE: As the dialog can be a dict, this API call works only with json format.
    return self.api_call(&#34;dialog.open&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.dnd_endDnd"><code class="name flex">
<span>def <span class="ident">dnd_endDnd</span></span>(<span>self, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Ends the current user's Do Not Disturb session immediately.
<a href="https://api.slack.com/methods/dnd.endDnd">https://api.slack.com/methods/dnd.endDnd</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dnd_endDnd(
    self,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Ends the current user&#39;s Do Not Disturb session immediately.
    https://api.slack.com/methods/dnd.endDnd
    &#34;&#34;&#34;
    return self.api_call(&#34;dnd.endDnd&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.dnd_endSnooze"><code class="name flex">
<span>def <span class="ident">dnd_endSnooze</span></span>(<span>self, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Ends the current user's snooze mode immediately.
<a href="https://api.slack.com/methods/dnd.endSnooze">https://api.slack.com/methods/dnd.endSnooze</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dnd_endSnooze(
    self,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Ends the current user&#39;s snooze mode immediately.
    https://api.slack.com/methods/dnd.endSnooze
    &#34;&#34;&#34;
    return self.api_call(&#34;dnd.endSnooze&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.dnd_info"><code class="name flex">
<span>def <span class="ident">dnd_info</span></span>(<span>self, *, team_id: Optional[str] = None, user: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves a user's current Do Not Disturb status.
<a href="https://api.slack.com/methods/dnd.info">https://api.slack.com/methods/dnd.info</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dnd_info(
    self,
    *,
    team_id: Optional[str] = None,
    user: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Retrieves a user&#39;s current Do Not Disturb status.
    https://api.slack.com/methods/dnd.info
    &#34;&#34;&#34;
    kwargs.update({&#34;team_id&#34;: team_id, &#34;user&#34;: user})
    return self.api_call(&#34;dnd.info&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.dnd_setSnooze"><code class="name flex">
<span>def <span class="ident">dnd_setSnooze</span></span>(<span>self, *, num_minutes: Union[str, int], **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Turns on Do Not Disturb mode for the current user, or changes its duration.
<a href="https://api.slack.com/methods/dnd.setSnooze">https://api.slack.com/methods/dnd.setSnooze</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dnd_setSnooze(
    self,
    *,
    num_minutes: Union[int, str],
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Turns on Do Not Disturb mode for the current user, or changes its duration.
    https://api.slack.com/methods/dnd.setSnooze
    &#34;&#34;&#34;
    kwargs.update({&#34;num_minutes&#34;: num_minutes})
    return self.api_call(&#34;dnd.setSnooze&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.dnd_teamInfo"><code class="name flex">
<span>def <span class="ident">dnd_teamInfo</span></span>(<span>self, users: Union[str, Sequence[str]], team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the Do Not Disturb status for users on a team.
<a href="https://api.slack.com/methods/dnd.teamInfo">https://api.slack.com/methods/dnd.teamInfo</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dnd_teamInfo(
    self,
    users: Union[str, Sequence[str]],
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Retrieves the Do Not Disturb status for users on a team.
    https://api.slack.com/methods/dnd.teamInfo
    &#34;&#34;&#34;
    if isinstance(users, (list, Tuple)):
        kwargs.update({&#34;users&#34;: &#34;,&#34;.join(users)})
    else:
        kwargs.update({&#34;users&#34;: users})
    kwargs.update({&#34;team_id&#34;: team_id})
    return self.api_call(&#34;dnd.teamInfo&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.emoji_list"><code class="name flex">
<span>def <span class="ident">emoji_list</span></span>(<span>self, include_categories: Optional[bool] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Lists custom emoji for a team.
<a href="https://api.slack.com/methods/emoji.list">https://api.slack.com/methods/emoji.list</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def emoji_list(
    self,
    include_categories: Optional[bool] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Lists custom emoji for a team.
    https://api.slack.com/methods/emoji.list
    &#34;&#34;&#34;
    kwargs.update({&#34;include_categories&#34;: include_categories})
    return self.api_call(&#34;emoji.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.files_comments_delete"><code class="name flex">
<span>def <span class="ident">files_comments_delete</span></span>(<span>self, *, file: str, id: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes an existing comment on a file.
<a href="https://api.slack.com/methods/files.comments.delete">https://api.slack.com/methods/files.comments.delete</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def files_comments_delete(
    self,
    *,
    file: str,
    id: str,
    **kwargs,  # skipcq: PYL-W0622
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Deletes an existing comment on a file.
    https://api.slack.com/methods/files.comments.delete
    &#34;&#34;&#34;
    kwargs.update({&#34;file&#34;: file, &#34;id&#34;: id})
    return self.api_call(&#34;files.comments.delete&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.files_completeUploadExternal"><code class="name flex">
<span>def <span class="ident">files_completeUploadExternal</span></span>(<span>self, *, files: List[Dict[str, str]], channel_id: Optional[str] = None, initial_comment: Optional[str] = None, thread_ts: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Finishes an upload started with files.getUploadURLExternal.
<a href="https://api.slack.com/methods/files.completeUploadExternal">https://api.slack.com/methods/files.completeUploadExternal</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def files_completeUploadExternal(
    self,
    *,
    files: List[Dict[str, str]],
    channel_id: Optional[str] = None,
    initial_comment: Optional[str] = None,
    thread_ts: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Finishes an upload started with files.getUploadURLExternal.
    https://api.slack.com/methods/files.completeUploadExternal
    &#34;&#34;&#34;
    _files = [{k: v for k, v in f.items() if v is not None} for f in files]
    kwargs.update(
        {
            &#34;files&#34;: json.dumps(_files),
            &#34;channel_id&#34;: channel_id,
            &#34;initial_comment&#34;: initial_comment,
            &#34;thread_ts&#34;: thread_ts,
        }
    )
    return self.api_call(&#34;files.completeUploadExternal&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.files_delete"><code class="name flex">
<span>def <span class="ident">files_delete</span></span>(<span>self, *, file: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a file.
<a href="https://api.slack.com/methods/files.delete">https://api.slack.com/methods/files.delete</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def files_delete(
    self,
    *,
    file: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Deletes a file.
    https://api.slack.com/methods/files.delete
    &#34;&#34;&#34;
    kwargs.update({&#34;file&#34;: file})
    return self.api_call(&#34;files.delete&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.files_getUploadURLExternal"><code class="name flex">
<span>def <span class="ident">files_getUploadURLExternal</span></span>(<span>self, *, filename: str, length: int, alt_txt: Optional[str] = None, snippet_type: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a URL for an edge external upload.
<a href="https://api.slack.com/methods/files.getUploadURLExternal">https://api.slack.com/methods/files.getUploadURLExternal</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def files_getUploadURLExternal(
    self,
    *,
    filename: str,
    length: int,
    alt_txt: Optional[str] = None,
    snippet_type: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Gets a URL for an edge external upload.
    https://api.slack.com/methods/files.getUploadURLExternal
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;filename&#34;: filename,
            &#34;length&#34;: length,
            &#34;alt_txt&#34;: alt_txt,
            &#34;snippet_type&#34;: snippet_type,
        }
    )
    return self.api_call(&#34;files.getUploadURLExternal&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.files_info"><code class="name flex">
<span>def <span class="ident">files_info</span></span>(<span>self, *, file: str, count: Optional[int] = None, cursor: Optional[str] = None, limit: Optional[int] = None, page: Optional[int] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets information about a team file.
<a href="https://api.slack.com/methods/files.info">https://api.slack.com/methods/files.info</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def files_info(
    self,
    *,
    file: str,
    count: Optional[int] = None,
    cursor: Optional[str] = None,
    limit: Optional[int] = None,
    page: Optional[int] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Gets information about a team file.
    https://api.slack.com/methods/files.info
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;file&#34;: file,
            &#34;count&#34;: count,
            &#34;cursor&#34;: cursor,
            &#34;limit&#34;: limit,
            &#34;page&#34;: page,
        }
    )
    return self.api_call(&#34;files.info&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.files_list"><code class="name flex">
<span>def <span class="ident">files_list</span></span>(<span>self, *, channel: Optional[str] = None, count: Optional[int] = None, page: Optional[int] = None, show_files_hidden_by_limit: Optional[bool] = None, team_id: Optional[str] = None, ts_from: Optional[str] = None, ts_to: Optional[str] = None, types: Union[str, Sequence[str], ForwardRef(None)] = None, user: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Lists &amp; filters team files.
<a href="https://api.slack.com/methods/files.list">https://api.slack.com/methods/files.list</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def files_list(
    self,
    *,
    channel: Optional[str] = None,
    count: Optional[int] = None,
    page: Optional[int] = None,
    show_files_hidden_by_limit: Optional[bool] = None,
    team_id: Optional[str] = None,
    ts_from: Optional[str] = None,
    ts_to: Optional[str] = None,
    types: Optional[Union[str, Sequence[str]]] = None,
    user: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Lists &amp; filters team files.
    https://api.slack.com/methods/files.list
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;channel&#34;: channel,
            &#34;count&#34;: count,
            &#34;page&#34;: page,
            &#34;show_files_hidden_by_limit&#34;: show_files_hidden_by_limit,
            &#34;team_id&#34;: team_id,
            &#34;ts_from&#34;: ts_from,
            &#34;ts_to&#34;: ts_to,
            &#34;user&#34;: user,
        }
    )
    if isinstance(types, (list, Tuple)):
        kwargs.update({&#34;types&#34;: &#34;,&#34;.join(types)})
    else:
        kwargs.update({&#34;types&#34;: types})
    return self.api_call(&#34;files.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.files_remote_add"><code class="name flex">
<span>def <span class="ident">files_remote_add</span></span>(<span>self, *, external_id: str, external_url: str, title: str, filetype: Optional[str] = None, indexable_file_contents: Union[str, bytes, io.IOBase, ForwardRef(None)] = None, preview_image: Union[str, bytes, io.IOBase, ForwardRef(None)] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a file from a remote service.
<a href="https://api.slack.com/methods/files.remote.add">https://api.slack.com/methods/files.remote.add</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def files_remote_add(
    self,
    *,
    external_id: str,
    external_url: str,
    title: str,
    filetype: Optional[str] = None,
    indexable_file_contents: Optional[Union[str, bytes, IOBase]] = None,
    preview_image: Optional[Union[str, bytes, IOBase]] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Adds a file from a remote service.
    https://api.slack.com/methods/files.remote.add
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;external_id&#34;: external_id,
            &#34;external_url&#34;: external_url,
            &#34;title&#34;: title,
            &#34;filetype&#34;: filetype,
        }
    )
    files = None
    # preview_image (file): Preview of the document via multipart/form-data.
    if preview_image is not None or indexable_file_contents is not None:
        files = {
            &#34;preview_image&#34;: preview_image,
            &#34;indexable_file_contents&#34;: indexable_file_contents,
        }

    return self.api_call(
        # Intentionally using &#34;POST&#34; method over &#34;GET&#34; here
        &#34;files.remote.add&#34;,
        http_verb=&#34;POST&#34;,
        data=kwargs,
        files=files,
    )</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.files_remote_info"><code class="name flex">
<span>def <span class="ident">files_remote_info</span></span>(<span>self, *, external_id: Optional[str] = None, file: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve information about a remote file added to Slack.
<a href="https://api.slack.com/methods/files.remote.info">https://api.slack.com/methods/files.remote.info</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def files_remote_info(
    self,
    *,
    external_id: Optional[str] = None,
    file: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Retrieve information about a remote file added to Slack.
    https://api.slack.com/methods/files.remote.info
    &#34;&#34;&#34;
    kwargs.update({&#34;external_id&#34;: external_id, &#34;file&#34;: file})
    return self.api_call(&#34;files.remote.info&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.files_remote_list"><code class="name flex">
<span>def <span class="ident">files_remote_list</span></span>(<span>self, *, channel: Optional[str] = None, cursor: Optional[str] = None, limit: Optional[int] = None, ts_from: Optional[str] = None, ts_to: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve information about a remote file added to Slack.
<a href="https://api.slack.com/methods/files.remote.list">https://api.slack.com/methods/files.remote.list</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def files_remote_list(
    self,
    *,
    channel: Optional[str] = None,
    cursor: Optional[str] = None,
    limit: Optional[int] = None,
    ts_from: Optional[str] = None,
    ts_to: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Retrieve information about a remote file added to Slack.
    https://api.slack.com/methods/files.remote.list
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;channel&#34;: channel,
            &#34;cursor&#34;: cursor,
            &#34;limit&#34;: limit,
            &#34;ts_from&#34;: ts_from,
            &#34;ts_to&#34;: ts_to,
        }
    )
    return self.api_call(&#34;files.remote.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.files_remote_remove"><code class="name flex">
<span>def <span class="ident">files_remote_remove</span></span>(<span>self, *, external_id: Optional[str] = None, file: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a remote file.
<a href="https://api.slack.com/methods/files.remote.remove">https://api.slack.com/methods/files.remote.remove</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def files_remote_remove(
    self,
    *,
    external_id: Optional[str] = None,
    file: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Remove a remote file.
    https://api.slack.com/methods/files.remote.remove
    &#34;&#34;&#34;
    kwargs.update({&#34;external_id&#34;: external_id, &#34;file&#34;: file})
    return self.api_call(&#34;files.remote.remove&#34;, http_verb=&#34;POST&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.files_remote_share"><code class="name flex">
<span>def <span class="ident">files_remote_share</span></span>(<span>self, *, channels: Union[str, Sequence[str]], external_id: Optional[str] = None, file: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Share a remote file into a channel.
<a href="https://api.slack.com/methods/files.remote.share">https://api.slack.com/methods/files.remote.share</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def files_remote_share(
    self,
    *,
    channels: Union[str, Sequence[str]],
    external_id: Optional[str] = None,
    file: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Share a remote file into a channel.
    https://api.slack.com/methods/files.remote.share
    &#34;&#34;&#34;
    if external_id is None and file is None:
        raise e.SlackRequestError(&#34;Either external_id or file must be provided.&#34;)
    if isinstance(channels, (list, Tuple)):
        kwargs.update({&#34;channels&#34;: &#34;,&#34;.join(channels)})
    else:
        kwargs.update({&#34;channels&#34;: channels})
    kwargs.update({&#34;external_id&#34;: external_id, &#34;file&#34;: file})
    return self.api_call(&#34;files.remote.share&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.files_remote_update"><code class="name flex">
<span>def <span class="ident">files_remote_update</span></span>(<span>self, *, external_id: Optional[str] = None, external_url: Optional[str] = None, file: Optional[str] = None, title: Optional[str] = None, filetype: Optional[str] = None, indexable_file_contents: Optional[str] = None, preview_image: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Updates an existing remote file.
<a href="https://api.slack.com/methods/files.remote.update">https://api.slack.com/methods/files.remote.update</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def files_remote_update(
    self,
    *,
    external_id: Optional[str] = None,
    external_url: Optional[str] = None,
    file: Optional[str] = None,
    title: Optional[str] = None,
    filetype: Optional[str] = None,
    indexable_file_contents: Optional[str] = None,
    preview_image: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Updates an existing remote file.
    https://api.slack.com/methods/files.remote.update
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;external_id&#34;: external_id,
            &#34;external_url&#34;: external_url,
            &#34;file&#34;: file,
            &#34;title&#34;: title,
            &#34;filetype&#34;: filetype,
        }
    )
    files = None
    # preview_image (file): Preview of the document via multipart/form-data.
    if preview_image is not None or indexable_file_contents is not None:
        files = {
            &#34;preview_image&#34;: preview_image,
            &#34;indexable_file_contents&#34;: indexable_file_contents,
        }

    return self.api_call(
        # Intentionally using &#34;POST&#34; method over &#34;GET&#34; here
        &#34;files.remote.update&#34;,
        http_verb=&#34;POST&#34;,
        data=kwargs,
        files=files,
    )</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.files_revokePublicURL"><code class="name flex">
<span>def <span class="ident">files_revokePublicURL</span></span>(<span>self, *, file: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Revokes public/external sharing access for a file
<a href="https://api.slack.com/methods/files.revokePublicURL">https://api.slack.com/methods/files.revokePublicURL</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def files_revokePublicURL(
    self,
    *,
    file: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Revokes public/external sharing access for a file
    https://api.slack.com/methods/files.revokePublicURL
    &#34;&#34;&#34;
    kwargs.update({&#34;file&#34;: file})
    return self.api_call(&#34;files.revokePublicURL&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.files_sharedPublicURL"><code class="name flex">
<span>def <span class="ident">files_sharedPublicURL</span></span>(<span>self, *, file: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Enables a file for public/external sharing.
<a href="https://api.slack.com/methods/files.sharedPublicURL">https://api.slack.com/methods/files.sharedPublicURL</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def files_sharedPublicURL(
    self,
    *,
    file: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Enables a file for public/external sharing.
    https://api.slack.com/methods/files.sharedPublicURL
    &#34;&#34;&#34;
    kwargs.update({&#34;file&#34;: file})
    return self.api_call(&#34;files.sharedPublicURL&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.files_upload"><code class="name flex">
<span>def <span class="ident">files_upload</span></span>(<span>self, *, file: Union[str, bytes, io.IOBase, ForwardRef(None)] = None, content: Union[str, bytes, ForwardRef(None)] = None, filename: Optional[str] = None, filetype: Optional[str] = None, initial_comment: Optional[str] = None, thread_ts: Optional[str] = None, title: Optional[str] = None, channels: Union[str, Sequence[str], ForwardRef(None)] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Uploads or creates a file.
<a href="https://api.slack.com/methods/files.upload">https://api.slack.com/methods/files.upload</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def files_upload(
    self,
    *,
    file: Optional[Union[str, bytes, IOBase]] = None,
    content: Optional[Union[str, bytes]] = None,
    filename: Optional[str] = None,
    filetype: Optional[str] = None,
    initial_comment: Optional[str] = None,
    thread_ts: Optional[str] = None,
    title: Optional[str] = None,
    channels: Optional[Union[str, Sequence[str]]] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Uploads or creates a file.
    https://api.slack.com/methods/files.upload
    &#34;&#34;&#34;
    _print_files_upload_v2_suggestion()

    if file is None and content is None:
        raise e.SlackRequestError(&#34;The file or content argument must be specified.&#34;)
    if file is not None and content is not None:
        raise e.SlackRequestError(&#34;You cannot specify both the file and the content argument.&#34;)

    if isinstance(channels, (list, Tuple)):
        kwargs.update({&#34;channels&#34;: &#34;,&#34;.join(channels)})
    else:
        kwargs.update({&#34;channels&#34;: channels})
    kwargs.update(
        {
            &#34;filename&#34;: filename,
            &#34;filetype&#34;: filetype,
            &#34;initial_comment&#34;: initial_comment,
            &#34;thread_ts&#34;: thread_ts,
            &#34;title&#34;: title,
        }
    )
    if file:
        if kwargs.get(&#34;filename&#34;) is None and isinstance(file, str):
            # use the local filename if filename is missing
            if kwargs.get(&#34;filename&#34;) is None:
                kwargs[&#34;filename&#34;] = file.split(os.path.sep)[-1]
        return self.api_call(&#34;files.upload&#34;, files={&#34;file&#34;: file}, data=kwargs)
    else:
        kwargs[&#34;content&#34;] = content
        return self.api_call(&#34;files.upload&#34;, data=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.files_upload_v2"><code class="name flex">
<span>def <span class="ident">files_upload_v2</span></span>(<span>self, *, filename: Optional[str] = None, file: Union[str, bytes, io.IOBase, ForwardRef(None)] = None, content: Union[str, bytes, ForwardRef(None)] = None, title: Optional[str] = None, alt_txt: Optional[str] = None, snippet_type: Optional[str] = None, file_uploads: Optional[List[Dict[str, Any]]] = None, channel: Optional[str] = None, initial_comment: Optional[str] = None, thread_ts: Optional[str] = None, request_file_info: bool = True, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>This wrapper method provides an easy way to upload files using the following endpoints:</p>
<ul>
<li>
<p>step1: <a href="https://api.slack.com/methods/files.getUploadURLExternal">https://api.slack.com/methods/files.getUploadURLExternal</a></p>
</li>
<li>
<p>step2: "https://files.slack.com/upload/v1/&hellip;" URLs returned from files.getUploadURLExternal API</p>
</li>
<li>
<p>step3: <a href="https://api.slack.com/methods/files.completeUploadExternal">https://api.slack.com/methods/files.completeUploadExternal</a>
and <a href="https://api.slack.com/methods/files.info">https://api.slack.com/methods/files.info</a></p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def files_upload_v2(
    self,
    *,
    # for sending a single file
    filename: Optional[str] = None,  # you can skip this only when sending along with content parameter
    file: Optional[Union[str, bytes, IOBase]] = None,
    content: Optional[Union[str, bytes]] = None,
    title: Optional[str] = None,
    alt_txt: Optional[str] = None,
    snippet_type: Optional[str] = None,
    # To upload multiple files at a time
    file_uploads: Optional[List[Dict[str, Any]]] = None,
    channel: Optional[str] = None,
    initial_comment: Optional[str] = None,
    thread_ts: Optional[str] = None,
    request_file_info: bool = True,  # since v3.23, this flag is no longer necessary
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;This wrapper method provides an easy way to upload files using the following endpoints:

    - step1: https://api.slack.com/methods/files.getUploadURLExternal

    - step2: &#34;https://files.slack.com/upload/v1/...&#34; URLs returned from files.getUploadURLExternal API

    - step3: https://api.slack.com/methods/files.completeUploadExternal
        and https://api.slack.com/methods/files.info

    &#34;&#34;&#34;
    if file is None and content is None and file_uploads is None:
        raise e.SlackRequestError(&#34;Any of file, content, and file_uploads must be specified.&#34;)
    if file is not None and content is not None:
        raise e.SlackRequestError(&#34;You cannot specify both the file and the content argument.&#34;)

    # deprecated arguments:
    channels, filetype = kwargs.get(&#34;channels&#34;), kwargs.get(&#34;filetype&#34;)

    if channels is not None:
        warnings.warn(
            &#34;Although the channels parameter is still supported for smooth migration from legacy files.upload, &#34;
            &#34;we recommend using the new channel parameter with a single str value instead for more clarity.&#34;
        )
        if (isinstance(channels, (list, Tuple)) and len(channels) &gt; 1) or (
            isinstance(channels, str) and len(channels.split(&#34;,&#34;)) &gt; 1
        ):
            raise e.SlackRequestError(
                &#34;Sharing files with multiple channels is no longer supported in v2. &#34;
                &#34;Share files in each channel separately instead.&#34;
            )
    if filetype is not None:
        warnings.warn(&#34;The filetype parameter is no longer supported. Please remove it from the arguments.&#34;)

    # step1: files.getUploadURLExternal per file
    files: List[Dict[str, Any]] = []
    if file_uploads is not None:
        for f in file_uploads:
            files.append(_to_v2_file_upload_item(f))
    else:
        f = _to_v2_file_upload_item(
            {
                &#34;filename&#34;: filename,
                &#34;file&#34;: file,
                &#34;content&#34;: content,
                &#34;title&#34;: title,
                &#34;alt_txt&#34;: alt_txt,
                &#34;snippet_type&#34;: snippet_type,
            }
        )
        files.append(f)

    for f in files:
        url_response = self.files_getUploadURLExternal(
            filename=f.get(&#34;filename&#34;),
            length=f.get(&#34;length&#34;),
            alt_txt=f.get(&#34;alt_txt&#34;),
            snippet_type=f.get(&#34;snippet_type&#34;),
            token=kwargs.get(&#34;token&#34;),
        )
        _validate_for_legacy_client(url_response)
        f[&#34;file_id&#34;] = url_response.get(&#34;file_id&#34;)  # type: ignore
        f[&#34;upload_url&#34;] = url_response.get(&#34;upload_url&#34;)  # type: ignore

    # step2: &#34;https://files.slack.com/upload/v1/...&#34; per file
    for f in files:
        upload_result = _upload_file_via_v2_url(
            url=f[&#34;upload_url&#34;],
            data=f[&#34;data&#34;],
            logger=self._logger,
            timeout=self.timeout,
            proxy=self.proxy,
            ssl=self.ssl,
        )
        if upload_result.get(&#34;status&#34;) != 200:
            status = upload_result.get(&#34;status&#34;)
            body = upload_result.get(&#34;body&#34;)
            message = (
                &#34;Failed to upload a file &#34;
                f&#34;(status: {status}, body: {body}, filename: {f.get(&#39;filename&#39;)}, title: {f.get(&#39;title&#39;)})&#34;
            )
            raise e.SlackRequestError(message)

    # step3: files.completeUploadExternal with all the sets of (file_id + title)
    channel_to_share = channel
    if channels is not None:
        if isinstance(channels, str):
            channel_to_share = channels.split(&#34;,&#34;)[0]
        else:
            channel_to_share = channels[0]
    completion = self.files_completeUploadExternal(
        files=[{&#34;id&#34;: f[&#34;file_id&#34;], &#34;title&#34;: f[&#34;title&#34;]} for f in files],
        channel_id=channel_to_share,
        initial_comment=initial_comment,
        thread_ts=thread_ts,
        **kwargs,
    )
    if len(completion.get(&#34;files&#34;)) == 1:  # type: ignore
        completion.data[&#34;file&#34;] = completion.get(&#34;files&#34;)[0]  # type: ignore
    return completion</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.functions_completeError"><code class="name flex">
<span>def <span class="ident">functions_completeError</span></span>(<span>self, *, function_execution_id: str, error: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Signal the failure to execute a function
<a href="https://api.slack.com/methods/functions.completeError">https://api.slack.com/methods/functions.completeError</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def functions_completeError(
    self,
    *,
    function_execution_id: str,
    error: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Signal the failure to execute a function
    https://api.slack.com/methods/functions.completeError
    &#34;&#34;&#34;
    kwargs.update({&#34;function_execution_id&#34;: function_execution_id, &#34;error&#34;: error})
    return self.api_call(&#34;functions.completeError&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.functions_completeSuccess"><code class="name flex">
<span>def <span class="ident">functions_completeSuccess</span></span>(<span>self, *, function_execution_id: str, outputs: Dict[str, Any], **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Signal the successful completion of a function
<a href="https://api.slack.com/methods/functions.completeSuccess">https://api.slack.com/methods/functions.completeSuccess</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def functions_completeSuccess(
    self,
    *,
    function_execution_id: str,
    outputs: Dict[str, Any],
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Signal the successful completion of a function
    https://api.slack.com/methods/functions.completeSuccess
    &#34;&#34;&#34;
    kwargs.update({&#34;function_execution_id&#34;: function_execution_id, &#34;outputs&#34;: json.dumps(outputs)})
    return self.api_call(&#34;functions.completeSuccess&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.groups_archive"><code class="name flex">
<span>def <span class="ident">groups_archive</span></span>(<span>self, *, channel: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Archives a private channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def groups_archive(
    self,
    *,
    channel: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Archives a private channel.&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel})
    kwargs = _remove_none_values(kwargs)
    return self.api_call(&#34;groups.archive&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.groups_create"><code class="name flex">
<span>def <span class="ident">groups_create</span></span>(<span>self, *, name: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a private channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def groups_create(
    self,
    *,
    name: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Creates a private channel.&#34;&#34;&#34;
    kwargs.update({&#34;name&#34;: name})
    kwargs = _remove_none_values(kwargs)
    return self.api_call(&#34;groups.create&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.groups_createChild"><code class="name flex">
<span>def <span class="ident">groups_createChild</span></span>(<span>self, *, channel: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Clones and archives a private channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def groups_createChild(
    self,
    *,
    channel: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Clones and archives a private channel.&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel})
    return self.api_call(&#34;groups.createChild&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.groups_history"><code class="name flex">
<span>def <span class="ident">groups_history</span></span>(<span>self, *, channel: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Fetches history of messages and events from a private channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def groups_history(
    self,
    *,
    channel: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Fetches history of messages and events from a private channel.&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel})
    return self.api_call(&#34;groups.history&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.groups_info"><code class="name flex">
<span>def <span class="ident">groups_info</span></span>(<span>self, *, channel: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets information about a private channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def groups_info(
    self,
    *,
    channel: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Gets information about a private channel.&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel})
    return self.api_call(&#34;groups.info&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.groups_invite"><code class="name flex">
<span>def <span class="ident">groups_invite</span></span>(<span>self, *, channel: str, user: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Invites a user to a private channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def groups_invite(
    self,
    *,
    channel: str,
    user: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Invites a user to a private channel.&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel, &#34;user&#34;: user})
    kwargs = _remove_none_values(kwargs)
    return self.api_call(&#34;groups.invite&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.groups_kick"><code class="name flex">
<span>def <span class="ident">groups_kick</span></span>(<span>self, *, channel: str, user: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Removes a user from a private channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def groups_kick(
    self,
    *,
    channel: str,
    user: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Removes a user from a private channel.&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel, &#34;user&#34;: user})
    kwargs = _remove_none_values(kwargs)
    return self.api_call(&#34;groups.kick&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.groups_leave"><code class="name flex">
<span>def <span class="ident">groups_leave</span></span>(<span>self, *, channel: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Leaves a private channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def groups_leave(
    self,
    *,
    channel: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Leaves a private channel.&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel})
    kwargs = _remove_none_values(kwargs)
    return self.api_call(&#34;groups.leave&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.groups_list"><code class="name flex">
<span>def <span class="ident">groups_list</span></span>(<span>self, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Lists private channels that the calling user has access to.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def groups_list(
    self,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Lists private channels that the calling user has access to.&#34;&#34;&#34;
    return self.api_call(&#34;groups.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.groups_mark"><code class="name flex">
<span>def <span class="ident">groups_mark</span></span>(<span>self, *, channel: str, ts: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the read cursor in a private channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def groups_mark(
    self,
    *,
    channel: str,
    ts: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Sets the read cursor in a private channel.&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel, &#34;ts&#34;: ts})
    kwargs = _remove_none_values(kwargs)
    return self.api_call(&#34;groups.mark&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.groups_open"><code class="name flex">
<span>def <span class="ident">groups_open</span></span>(<span>self, *, channel: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Opens a private channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def groups_open(
    self,
    *,
    channel: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Opens a private channel.&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel})
    kwargs = _remove_none_values(kwargs)
    return self.api_call(&#34;groups.open&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.groups_rename"><code class="name flex">
<span>def <span class="ident">groups_rename</span></span>(<span>self, *, channel: str, name: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Renames a private channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def groups_rename(
    self,
    *,
    channel: str,
    name: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Renames a private channel.&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel, &#34;name&#34;: name})
    kwargs = _remove_none_values(kwargs)
    return self.api_call(&#34;groups.rename&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.groups_replies"><code class="name flex">
<span>def <span class="ident">groups_replies</span></span>(<span>self, *, channel: str, thread_ts: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve a thread of messages posted to a private channel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def groups_replies(
    self,
    *,
    channel: str,
    thread_ts: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Retrieve a thread of messages posted to a private channel&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel, &#34;thread_ts&#34;: thread_ts})
    return self.api_call(&#34;groups.replies&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.groups_setPurpose"><code class="name flex">
<span>def <span class="ident">groups_setPurpose</span></span>(<span>self, *, channel: str, purpose: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the purpose for a private channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def groups_setPurpose(
    self,
    *,
    channel: str,
    purpose: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Sets the purpose for a private channel.&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel, &#34;purpose&#34;: purpose})
    kwargs = _remove_none_values(kwargs)
    return self.api_call(&#34;groups.setPurpose&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.groups_setTopic"><code class="name flex">
<span>def <span class="ident">groups_setTopic</span></span>(<span>self, *, channel: str, topic: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the topic for a private channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def groups_setTopic(
    self,
    *,
    channel: str,
    topic: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Sets the topic for a private channel.&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel, &#34;topic&#34;: topic})
    kwargs = _remove_none_values(kwargs)
    return self.api_call(&#34;groups.setTopic&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.groups_unarchive"><code class="name flex">
<span>def <span class="ident">groups_unarchive</span></span>(<span>self, *, channel: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Unarchives a private channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def groups_unarchive(
    self,
    *,
    channel: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Unarchives a private channel.&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel})
    kwargs = _remove_none_values(kwargs)
    return self.api_call(&#34;groups.unarchive&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.im_close"><code class="name flex">
<span>def <span class="ident">im_close</span></span>(<span>self, *, channel: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Close a direct message channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def im_close(
    self,
    *,
    channel: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Close a direct message channel.&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel})
    kwargs = _remove_none_values(kwargs)
    return self.api_call(&#34;im.close&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.im_history"><code class="name flex">
<span>def <span class="ident">im_history</span></span>(<span>self, *, channel: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Fetches history of messages and events from direct message channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def im_history(
    self,
    *,
    channel: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Fetches history of messages and events from direct message channel.&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel})
    return self.api_call(&#34;im.history&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.im_list"><code class="name flex">
<span>def <span class="ident">im_list</span></span>(<span>self, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Lists direct message channels for the calling user.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def im_list(
    self,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Lists direct message channels for the calling user.&#34;&#34;&#34;
    return self.api_call(&#34;im.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.im_mark"><code class="name flex">
<span>def <span class="ident">im_mark</span></span>(<span>self, *, channel: str, ts: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the read cursor in a direct message channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def im_mark(
    self,
    *,
    channel: str,
    ts: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Sets the read cursor in a direct message channel.&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel, &#34;ts&#34;: ts})
    kwargs = _remove_none_values(kwargs)
    return self.api_call(&#34;im.mark&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.im_open"><code class="name flex">
<span>def <span class="ident">im_open</span></span>(<span>self, *, user: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Opens a direct message channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def im_open(
    self,
    *,
    user: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Opens a direct message channel.&#34;&#34;&#34;
    kwargs.update({&#34;user&#34;: user})
    kwargs = _remove_none_values(kwargs)
    return self.api_call(&#34;im.open&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.im_replies"><code class="name flex">
<span>def <span class="ident">im_replies</span></span>(<span>self, *, channel: str, thread_ts: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve a thread of messages posted to a direct message conversation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def im_replies(
    self,
    *,
    channel: str,
    thread_ts: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Retrieve a thread of messages posted to a direct message conversation&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel, &#34;thread_ts&#34;: thread_ts})
    return self.api_call(&#34;im.replies&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.migration_exchange"><code class="name flex">
<span>def <span class="ident">migration_exchange</span></span>(<span>self, *, users: Union[str, Sequence[str]], team_id: Optional[str] = None, to_old: Optional[bool] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>For Enterprise Grid workspaces, map local user IDs to global user IDs
<a href="https://api.slack.com/methods/migration.exchange">https://api.slack.com/methods/migration.exchange</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def migration_exchange(
    self,
    *,
    users: Union[str, Sequence[str]],
    team_id: Optional[str] = None,
    to_old: Optional[bool] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;For Enterprise Grid workspaces, map local user IDs to global user IDs
    https://api.slack.com/methods/migration.exchange
    &#34;&#34;&#34;
    if isinstance(users, (list, Tuple)):
        kwargs.update({&#34;users&#34;: &#34;,&#34;.join(users)})
    else:
        kwargs.update({&#34;users&#34;: users})
    kwargs.update({&#34;team_id&#34;: team_id, &#34;to_old&#34;: to_old})
    return self.api_call(&#34;migration.exchange&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.mpim_close"><code class="name flex">
<span>def <span class="ident">mpim_close</span></span>(<span>self, *, channel: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Closes a multiparty direct message channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mpim_close(
    self,
    *,
    channel: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Closes a multiparty direct message channel.&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel})
    kwargs = _remove_none_values(kwargs)
    return self.api_call(&#34;mpim.close&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.mpim_history"><code class="name flex">
<span>def <span class="ident">mpim_history</span></span>(<span>self, *, channel: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Fetches history of messages and events from a multiparty direct message.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mpim_history(
    self,
    *,
    channel: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Fetches history of messages and events from a multiparty direct message.&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel})
    return self.api_call(&#34;mpim.history&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.mpim_list"><code class="name flex">
<span>def <span class="ident">mpim_list</span></span>(<span>self, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Lists multiparty direct message channels for the calling user.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mpim_list(
    self,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Lists multiparty direct message channels for the calling user.&#34;&#34;&#34;
    return self.api_call(&#34;mpim.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.mpim_mark"><code class="name flex">
<span>def <span class="ident">mpim_mark</span></span>(<span>self, *, channel: str, ts: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the read cursor in a multiparty direct message channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mpim_mark(
    self,
    *,
    channel: str,
    ts: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Sets the read cursor in a multiparty direct message channel.&#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel, &#34;ts&#34;: ts})
    kwargs = _remove_none_values(kwargs)
    return self.api_call(&#34;mpim.mark&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.mpim_open"><code class="name flex">
<span>def <span class="ident">mpim_open</span></span>(<span>self, *, users: Union[str, Sequence[str]], **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>This method opens a multiparty direct message.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mpim_open(
    self,
    *,
    users: Union[str, Sequence[str]],
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;This method opens a multiparty direct message.&#34;&#34;&#34;
    if isinstance(users, (list, Tuple)):
        kwargs.update({&#34;users&#34;: &#34;,&#34;.join(users)})
    else:
        kwargs.update({&#34;users&#34;: users})
    return self.api_call(&#34;mpim.open&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.mpim_replies"><code class="name flex">
<span>def <span class="ident">mpim_replies</span></span>(<span>self, *, channel: str, thread_ts: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve a thread of messages posted to a direct message conversation from a
multiparty direct message.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mpim_replies(
    self,
    *,
    channel: str,
    thread_ts: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Retrieve a thread of messages posted to a direct message conversation from a
    multiparty direct message.
    &#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel, &#34;thread_ts&#34;: thread_ts})
    return self.api_call(&#34;mpim.replies&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.oauth_access"><code class="name flex">
<span>def <span class="ident">oauth_access</span></span>(<span>self, *, client_id: str, client_secret: str, code: str, redirect_uri: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Exchanges a temporary OAuth verifier code for an access token.
<a href="https://api.slack.com/methods/oauth.access">https://api.slack.com/methods/oauth.access</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def oauth_access(
    self,
    *,
    client_id: str,
    client_secret: str,
    code: str,
    redirect_uri: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Exchanges a temporary OAuth verifier code for an access token.
    https://api.slack.com/methods/oauth.access
    &#34;&#34;&#34;
    if redirect_uri is not None:
        kwargs.update({&#34;redirect_uri&#34;: redirect_uri})
    kwargs.update({&#34;code&#34;: code})
    return self.api_call(
        &#34;oauth.access&#34;,
        data=kwargs,
        auth={&#34;client_id&#34;: client_id, &#34;client_secret&#34;: client_secret},
    )</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.oauth_v2_access"><code class="name flex">
<span>def <span class="ident">oauth_v2_access</span></span>(<span>self, *, client_id: str, client_secret: str, code: Optional[str] = None, redirect_uri: Optional[str] = None, grant_type: Optional[str] = None, refresh_token: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Exchanges a temporary OAuth verifier code for an access token.
<a href="https://api.slack.com/methods/oauth.v2.access">https://api.slack.com/methods/oauth.v2.access</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def oauth_v2_access(
    self,
    *,
    client_id: str,
    client_secret: str,
    # This field is required when processing the OAuth redirect URL requests
    # while it&#39;s absent for token rotation
    code: Optional[str] = None,
    redirect_uri: Optional[str] = None,
    # This field is required for token rotation
    grant_type: Optional[str] = None,
    # This field is required for token rotation
    refresh_token: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Exchanges a temporary OAuth verifier code for an access token.
    https://api.slack.com/methods/oauth.v2.access
    &#34;&#34;&#34;
    if redirect_uri is not None:
        kwargs.update({&#34;redirect_uri&#34;: redirect_uri})
    if code is not None:
        kwargs.update({&#34;code&#34;: code})
    if grant_type is not None:
        kwargs.update({&#34;grant_type&#34;: grant_type})
    if refresh_token is not None:
        kwargs.update({&#34;refresh_token&#34;: refresh_token})
    return self.api_call(
        &#34;oauth.v2.access&#34;,
        data=kwargs,
        auth={&#34;client_id&#34;: client_id, &#34;client_secret&#34;: client_secret},
    )</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.oauth_v2_exchange"><code class="name flex">
<span>def <span class="ident">oauth_v2_exchange</span></span>(<span>self, *, token: str, client_id: str, client_secret: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Exchanges a legacy access token for a new expiring access token and refresh token
<a href="https://api.slack.com/methods/oauth.v2.exchange">https://api.slack.com/methods/oauth.v2.exchange</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def oauth_v2_exchange(
    self,
    *,
    token: str,
    client_id: str,
    client_secret: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Exchanges a legacy access token for a new expiring access token and refresh token
    https://api.slack.com/methods/oauth.v2.exchange
    &#34;&#34;&#34;
    kwargs.update({&#34;client_id&#34;: client_id, &#34;client_secret&#34;: client_secret, &#34;token&#34;: token})
    return self.api_call(&#34;oauth.v2.exchange&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.openid_connect_token"><code class="name flex">
<span>def <span class="ident">openid_connect_token</span></span>(<span>self, client_id: str, client_secret: str, code: Optional[str] = None, redirect_uri: Optional[str] = None, grant_type: Optional[str] = None, refresh_token: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Exchanges a temporary OAuth verifier code for an access token for Sign in with Slack.
<a href="https://api.slack.com/methods/openid.connect.token">https://api.slack.com/methods/openid.connect.token</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def openid_connect_token(
    self,
    client_id: str,
    client_secret: str,
    code: Optional[str] = None,
    redirect_uri: Optional[str] = None,
    grant_type: Optional[str] = None,
    refresh_token: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Exchanges a temporary OAuth verifier code for an access token for Sign in with Slack.
    https://api.slack.com/methods/openid.connect.token
    &#34;&#34;&#34;
    if redirect_uri is not None:
        kwargs.update({&#34;redirect_uri&#34;: redirect_uri})
    if code is not None:
        kwargs.update({&#34;code&#34;: code})
    if grant_type is not None:
        kwargs.update({&#34;grant_type&#34;: grant_type})
    if refresh_token is not None:
        kwargs.update({&#34;refresh_token&#34;: refresh_token})
    return self.api_call(
        &#34;openid.connect.token&#34;,
        data=kwargs,
        auth={&#34;client_id&#34;: client_id, &#34;client_secret&#34;: client_secret},
    )</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.openid_connect_userInfo"><code class="name flex">
<span>def <span class="ident">openid_connect_userInfo</span></span>(<span>self, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the identity of a user who has authorized Sign in with Slack.
<a href="https://api.slack.com/methods/openid.connect.userInfo">https://api.slack.com/methods/openid.connect.userInfo</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def openid_connect_userInfo(
    self,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Get the identity of a user who has authorized Sign in with Slack.
    https://api.slack.com/methods/openid.connect.userInfo
    &#34;&#34;&#34;
    return self.api_call(&#34;openid.connect.userInfo&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.pins_add"><code class="name flex">
<span>def <span class="ident">pins_add</span></span>(<span>self, *, channel: str, timestamp: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Pins an item to a channel.
<a href="https://api.slack.com/methods/pins.add">https://api.slack.com/methods/pins.add</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pins_add(
    self,
    *,
    channel: str,
    timestamp: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Pins an item to a channel.
    https://api.slack.com/methods/pins.add
    &#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel, &#34;timestamp&#34;: timestamp})
    return self.api_call(&#34;pins.add&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.pins_list"><code class="name flex">
<span>def <span class="ident">pins_list</span></span>(<span>self, *, channel: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Lists items pinned to a channel.
<a href="https://api.slack.com/methods/pins.list">https://api.slack.com/methods/pins.list</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pins_list(
    self,
    *,
    channel: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Lists items pinned to a channel.
    https://api.slack.com/methods/pins.list
    &#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel})
    return self.api_call(&#34;pins.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.pins_remove"><code class="name flex">
<span>def <span class="ident">pins_remove</span></span>(<span>self, *, channel: str, timestamp: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Un-pins an item from a channel.
<a href="https://api.slack.com/methods/pins.remove">https://api.slack.com/methods/pins.remove</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pins_remove(
    self,
    *,
    channel: str,
    timestamp: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Un-pins an item from a channel.
    https://api.slack.com/methods/pins.remove
    &#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel, &#34;timestamp&#34;: timestamp})
    return self.api_call(&#34;pins.remove&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.reactions_add"><code class="name flex">
<span>def <span class="ident">reactions_add</span></span>(<span>self, *, channel: str, name: str, timestamp: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a reaction to an item.
<a href="https://api.slack.com/methods/reactions.add">https://api.slack.com/methods/reactions.add</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reactions_add(
    self,
    *,
    channel: str,
    name: str,
    timestamp: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Adds a reaction to an item.
    https://api.slack.com/methods/reactions.add
    &#34;&#34;&#34;
    kwargs.update({&#34;channel&#34;: channel, &#34;name&#34;: name, &#34;timestamp&#34;: timestamp})
    return self.api_call(&#34;reactions.add&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.reactions_get"><code class="name flex">
<span>def <span class="ident">reactions_get</span></span>(<span>self, *, channel: Optional[str] = None, file: Optional[str] = None, file_comment: Optional[str] = None, full: Optional[bool] = None, timestamp: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets reactions for an item.
<a href="https://api.slack.com/methods/reactions.get">https://api.slack.com/methods/reactions.get</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reactions_get(
    self,
    *,
    channel: Optional[str] = None,
    file: Optional[str] = None,
    file_comment: Optional[str] = None,
    full: Optional[bool] = None,
    timestamp: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Gets reactions for an item.
    https://api.slack.com/methods/reactions.get
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;channel&#34;: channel,
            &#34;file&#34;: file,
            &#34;file_comment&#34;: file_comment,
            &#34;full&#34;: full,
            &#34;timestamp&#34;: timestamp,
        }
    )
    return self.api_call(&#34;reactions.get&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.reactions_list"><code class="name flex">
<span>def <span class="ident">reactions_list</span></span>(<span>self, *, count: Optional[int] = None, cursor: Optional[str] = None, full: Optional[bool] = None, limit: Optional[int] = None, page: Optional[int] = None, team_id: Optional[str] = None, user: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Lists reactions made by a user.
<a href="https://api.slack.com/methods/reactions.list">https://api.slack.com/methods/reactions.list</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reactions_list(
    self,
    *,
    count: Optional[int] = None,
    cursor: Optional[str] = None,
    full: Optional[bool] = None,
    limit: Optional[int] = None,
    page: Optional[int] = None,
    team_id: Optional[str] = None,
    user: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Lists reactions made by a user.
    https://api.slack.com/methods/reactions.list
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;count&#34;: count,
            &#34;cursor&#34;: cursor,
            &#34;full&#34;: full,
            &#34;limit&#34;: limit,
            &#34;page&#34;: page,
            &#34;team_id&#34;: team_id,
            &#34;user&#34;: user,
        }
    )
    return self.api_call(&#34;reactions.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.reactions_remove"><code class="name flex">
<span>def <span class="ident">reactions_remove</span></span>(<span>self, *, name: str, channel: Optional[str] = None, file: Optional[str] = None, file_comment: Optional[str] = None, timestamp: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Removes a reaction from an item.
<a href="https://api.slack.com/methods/reactions.remove">https://api.slack.com/methods/reactions.remove</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reactions_remove(
    self,
    *,
    name: str,
    channel: Optional[str] = None,
    file: Optional[str] = None,
    file_comment: Optional[str] = None,
    timestamp: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Removes a reaction from an item.
    https://api.slack.com/methods/reactions.remove
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;name&#34;: name,
            &#34;channel&#34;: channel,
            &#34;file&#34;: file,
            &#34;file_comment&#34;: file_comment,
            &#34;timestamp&#34;: timestamp,
        }
    )
    return self.api_call(&#34;reactions.remove&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.reminders_add"><code class="name flex">
<span>def <span class="ident">reminders_add</span></span>(<span>self, *, text: str, time: str, team_id: Optional[str] = None, user: Optional[str] = None, recurrence: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a reminder.
<a href="https://api.slack.com/methods/reminders.add">https://api.slack.com/methods/reminders.add</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reminders_add(
    self,
    *,
    text: str,
    time: str,
    team_id: Optional[str] = None,
    user: Optional[str] = None,
    recurrence: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Creates a reminder.
    https://api.slack.com/methods/reminders.add
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;text&#34;: text,
            &#34;time&#34;: time,
            &#34;team_id&#34;: team_id,
            &#34;user&#34;: user,
            &#34;recurrence&#34;: recurrence,
        }
    )
    return self.api_call(&#34;reminders.add&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.reminders_complete"><code class="name flex">
<span>def <span class="ident">reminders_complete</span></span>(<span>self, *, reminder: str, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Marks a reminder as complete.
<a href="https://api.slack.com/methods/reminders.complete">https://api.slack.com/methods/reminders.complete</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reminders_complete(
    self,
    *,
    reminder: str,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Marks a reminder as complete.
    https://api.slack.com/methods/reminders.complete
    &#34;&#34;&#34;
    kwargs.update({&#34;reminder&#34;: reminder, &#34;team_id&#34;: team_id})
    return self.api_call(&#34;reminders.complete&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.reminders_delete"><code class="name flex">
<span>def <span class="ident">reminders_delete</span></span>(<span>self, *, reminder: str, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a reminder.
<a href="https://api.slack.com/methods/reminders.delete">https://api.slack.com/methods/reminders.delete</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reminders_delete(
    self,
    *,
    reminder: str,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Deletes a reminder.
    https://api.slack.com/methods/reminders.delete
    &#34;&#34;&#34;
    kwargs.update({&#34;reminder&#34;: reminder, &#34;team_id&#34;: team_id})
    return self.api_call(&#34;reminders.delete&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.reminders_info"><code class="name flex">
<span>def <span class="ident">reminders_info</span></span>(<span>self, *, reminder: str, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets information about a reminder.
<a href="https://api.slack.com/methods/reminders.info">https://api.slack.com/methods/reminders.info</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reminders_info(
    self,
    *,
    reminder: str,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Gets information about a reminder.
    https://api.slack.com/methods/reminders.info
    &#34;&#34;&#34;
    kwargs.update({&#34;reminder&#34;: reminder, &#34;team_id&#34;: team_id})
    return self.api_call(&#34;reminders.info&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.reminders_list"><code class="name flex">
<span>def <span class="ident">reminders_list</span></span>(<span>self, *, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Lists all reminders created by or for a given user.
<a href="https://api.slack.com/methods/reminders.list">https://api.slack.com/methods/reminders.list</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reminders_list(
    self,
    *,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Lists all reminders created by or for a given user.
    https://api.slack.com/methods/reminders.list
    &#34;&#34;&#34;
    kwargs.update({&#34;team_id&#34;: team_id})
    return self.api_call(&#34;reminders.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.rtm_connect"><code class="name flex">
<span>def <span class="ident">rtm_connect</span></span>(<span>self, *, batch_presence_aware: Optional[bool] = None, presence_sub: Optional[bool] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Starts a Real Time Messaging session.
<a href="https://api.slack.com/methods/rtm.connect">https://api.slack.com/methods/rtm.connect</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rtm_connect(
    self,
    *,
    batch_presence_aware: Optional[bool] = None,
    presence_sub: Optional[bool] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Starts a Real Time Messaging session.
    https://api.slack.com/methods/rtm.connect
    &#34;&#34;&#34;
    kwargs.update({&#34;batch_presence_aware&#34;: batch_presence_aware, &#34;presence_sub&#34;: presence_sub})
    return self.api_call(&#34;rtm.connect&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.rtm_start"><code class="name flex">
<span>def <span class="ident">rtm_start</span></span>(<span>self, *, batch_presence_aware: Optional[bool] = None, include_locale: Optional[bool] = None, mpim_aware: Optional[bool] = None, no_latest: Optional[bool] = None, no_unreads: Optional[bool] = None, presence_sub: Optional[bool] = None, simple_latest: Optional[bool] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Starts a Real Time Messaging session.
<a href="https://api.slack.com/methods/rtm.start">https://api.slack.com/methods/rtm.start</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rtm_start(
    self,
    *,
    batch_presence_aware: Optional[bool] = None,
    include_locale: Optional[bool] = None,
    mpim_aware: Optional[bool] = None,
    no_latest: Optional[bool] = None,
    no_unreads: Optional[bool] = None,
    presence_sub: Optional[bool] = None,
    simple_latest: Optional[bool] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Starts a Real Time Messaging session.
    https://api.slack.com/methods/rtm.start
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;batch_presence_aware&#34;: batch_presence_aware,
            &#34;include_locale&#34;: include_locale,
            &#34;mpim_aware&#34;: mpim_aware,
            &#34;no_latest&#34;: no_latest,
            &#34;no_unreads&#34;: no_unreads,
            &#34;presence_sub&#34;: presence_sub,
            &#34;simple_latest&#34;: simple_latest,
        }
    )
    return self.api_call(&#34;rtm.start&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.search_all"><code class="name flex">
<span>def <span class="ident">search_all</span></span>(<span>self, *, query: str, count: Optional[int] = None, highlight: Optional[bool] = None, page: Optional[int] = None, sort: Optional[str] = None, sort_dir: Optional[str] = None, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Searches for messages and files matching a query.
<a href="https://api.slack.com/methods/search.all">https://api.slack.com/methods/search.all</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_all(
    self,
    *,
    query: str,
    count: Optional[int] = None,
    highlight: Optional[bool] = None,
    page: Optional[int] = None,
    sort: Optional[str] = None,
    sort_dir: Optional[str] = None,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Searches for messages and files matching a query.
    https://api.slack.com/methods/search.all
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;query&#34;: query,
            &#34;count&#34;: count,
            &#34;highlight&#34;: highlight,
            &#34;page&#34;: page,
            &#34;sort&#34;: sort,
            &#34;sort_dir&#34;: sort_dir,
            &#34;team_id&#34;: team_id,
        }
    )
    return self.api_call(&#34;search.all&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.search_files"><code class="name flex">
<span>def <span class="ident">search_files</span></span>(<span>self, *, query: str, count: Optional[int] = None, highlight: Optional[bool] = None, page: Optional[int] = None, sort: Optional[str] = None, sort_dir: Optional[str] = None, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Searches for files matching a query.
<a href="https://api.slack.com/methods/search.files">https://api.slack.com/methods/search.files</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_files(
    self,
    *,
    query: str,
    count: Optional[int] = None,
    highlight: Optional[bool] = None,
    page: Optional[int] = None,
    sort: Optional[str] = None,
    sort_dir: Optional[str] = None,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Searches for files matching a query.
    https://api.slack.com/methods/search.files
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;query&#34;: query,
            &#34;count&#34;: count,
            &#34;highlight&#34;: highlight,
            &#34;page&#34;: page,
            &#34;sort&#34;: sort,
            &#34;sort_dir&#34;: sort_dir,
            &#34;team_id&#34;: team_id,
        }
    )
    return self.api_call(&#34;search.files&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.search_messages"><code class="name flex">
<span>def <span class="ident">search_messages</span></span>(<span>self, *, query: str, count: Optional[int] = None, cursor: Optional[str] = None, highlight: Optional[bool] = None, page: Optional[int] = None, sort: Optional[str] = None, sort_dir: Optional[str] = None, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Searches for messages matching a query.
<a href="https://api.slack.com/methods/search.messages">https://api.slack.com/methods/search.messages</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_messages(
    self,
    *,
    query: str,
    count: Optional[int] = None,
    cursor: Optional[str] = None,
    highlight: Optional[bool] = None,
    page: Optional[int] = None,
    sort: Optional[str] = None,
    sort_dir: Optional[str] = None,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Searches for messages matching a query.
    https://api.slack.com/methods/search.messages
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;query&#34;: query,
            &#34;count&#34;: count,
            &#34;cursor&#34;: cursor,
            &#34;highlight&#34;: highlight,
            &#34;page&#34;: page,
            &#34;sort&#34;: sort,
            &#34;sort_dir&#34;: sort_dir,
            &#34;team_id&#34;: team_id,
        }
    )
    return self.api_call(&#34;search.messages&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.stars_add"><code class="name flex">
<span>def <span class="ident">stars_add</span></span>(<span>self, *, channel: Optional[str] = None, file: Optional[str] = None, file_comment: Optional[str] = None, timestamp: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a star to an item.
<a href="https://api.slack.com/methods/stars.add">https://api.slack.com/methods/stars.add</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stars_add(
    self,
    *,
    channel: Optional[str] = None,
    file: Optional[str] = None,
    file_comment: Optional[str] = None,
    timestamp: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Adds a star to an item.
    https://api.slack.com/methods/stars.add
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;channel&#34;: channel,
            &#34;file&#34;: file,
            &#34;file_comment&#34;: file_comment,
            &#34;timestamp&#34;: timestamp,
        }
    )
    return self.api_call(&#34;stars.add&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.stars_list"><code class="name flex">
<span>def <span class="ident">stars_list</span></span>(<span>self, *, count: Optional[int] = None, cursor: Optional[str] = None, limit: Optional[int] = None, page: Optional[int] = None, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Lists stars for a user.
<a href="https://api.slack.com/methods/stars.list">https://api.slack.com/methods/stars.list</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stars_list(
    self,
    *,
    count: Optional[int] = None,
    cursor: Optional[str] = None,
    limit: Optional[int] = None,
    page: Optional[int] = None,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Lists stars for a user.
    https://api.slack.com/methods/stars.list
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;count&#34;: count,
            &#34;cursor&#34;: cursor,
            &#34;limit&#34;: limit,
            &#34;page&#34;: page,
            &#34;team_id&#34;: team_id,
        }
    )
    return self.api_call(&#34;stars.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.stars_remove"><code class="name flex">
<span>def <span class="ident">stars_remove</span></span>(<span>self, *, channel: Optional[str] = None, file: Optional[str] = None, file_comment: Optional[str] = None, timestamp: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Removes a star from an item.
<a href="https://api.slack.com/methods/stars.remove">https://api.slack.com/methods/stars.remove</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stars_remove(
    self,
    *,
    channel: Optional[str] = None,
    file: Optional[str] = None,
    file_comment: Optional[str] = None,
    timestamp: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Removes a star from an item.
    https://api.slack.com/methods/stars.remove
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;channel&#34;: channel,
            &#34;file&#34;: file,
            &#34;file_comment&#34;: file_comment,
            &#34;timestamp&#34;: timestamp,
        }
    )
    return self.api_call(&#34;stars.remove&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.team_accessLogs"><code class="name flex">
<span>def <span class="ident">team_accessLogs</span></span>(<span>self, *, before: Union[str, int, ForwardRef(None)] = None, count: Union[str, int, ForwardRef(None)] = None, page: Union[str, int, ForwardRef(None)] = None, team_id: Optional[str] = None, cursor: Optional[str] = None, limit: Optional[int] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the access logs for the current team.
<a href="https://api.slack.com/methods/team.accessLogs">https://api.slack.com/methods/team.accessLogs</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def team_accessLogs(
    self,
    *,
    before: Optional[Union[int, str]] = None,
    count: Optional[Union[int, str]] = None,
    page: Optional[Union[int, str]] = None,
    team_id: Optional[str] = None,
    cursor: Optional[str] = None,
    limit: Optional[int] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Gets the access logs for the current team.
    https://api.slack.com/methods/team.accessLogs
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;before&#34;: before,
            &#34;count&#34;: count,
            &#34;page&#34;: page,
            &#34;team_id&#34;: team_id,
            &#34;cursor&#34;: cursor,
            &#34;limit&#34;: limit,
        }
    )
    return self.api_call(&#34;team.accessLogs&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.team_billableInfo"><code class="name flex">
<span>def <span class="ident">team_billableInfo</span></span>(<span>self, *, team_id: Optional[str] = None, user: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets billable users information for the current team.
<a href="https://api.slack.com/methods/team.billableInfo">https://api.slack.com/methods/team.billableInfo</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def team_billableInfo(
    self,
    *,
    team_id: Optional[str] = None,
    user: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Gets billable users information for the current team.
    https://api.slack.com/methods/team.billableInfo
    &#34;&#34;&#34;
    kwargs.update({&#34;team_id&#34;: team_id, &#34;user&#34;: user})
    return self.api_call(&#34;team.billableInfo&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.team_billing_info"><code class="name flex">
<span>def <span class="ident">team_billing_info</span></span>(<span>self, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Reads a workspace's billing plan information.
<a href="https://api.slack.com/methods/team.billing.info">https://api.slack.com/methods/team.billing.info</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def team_billing_info(
    self,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Reads a workspace&#39;s billing plan information.
    https://api.slack.com/methods/team.billing.info
    &#34;&#34;&#34;
    return self.api_call(&#34;team.billing.info&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.team_info"><code class="name flex">
<span>def <span class="ident">team_info</span></span>(<span>self, *, team: Optional[str] = None, domain: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets information about the current team.
<a href="https://api.slack.com/methods/team.info">https://api.slack.com/methods/team.info</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def team_info(
    self,
    *,
    team: Optional[str] = None,
    domain: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Gets information about the current team.
    https://api.slack.com/methods/team.info
    &#34;&#34;&#34;
    kwargs.update({&#34;team&#34;: team, &#34;domain&#34;: domain})
    return self.api_call(&#34;team.info&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.team_integrationLogs"><code class="name flex">
<span>def <span class="ident">team_integrationLogs</span></span>(<span>self, *, app_id: Optional[str] = None, change_type: Optional[str] = None, count: Union[str, int, ForwardRef(None)] = None, page: Union[str, int, ForwardRef(None)] = None, service_id: Optional[str] = None, team_id: Optional[str] = None, user: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the integration logs for the current team.
<a href="https://api.slack.com/methods/team.integrationLogs">https://api.slack.com/methods/team.integrationLogs</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def team_integrationLogs(
    self,
    *,
    app_id: Optional[str] = None,
    change_type: Optional[str] = None,
    count: Optional[Union[int, str]] = None,
    page: Optional[Union[int, str]] = None,
    service_id: Optional[str] = None,
    team_id: Optional[str] = None,
    user: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Gets the integration logs for the current team.
    https://api.slack.com/methods/team.integrationLogs
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;app_id&#34;: app_id,
            &#34;change_type&#34;: change_type,
            &#34;count&#34;: count,
            &#34;page&#34;: page,
            &#34;service_id&#34;: service_id,
            &#34;team_id&#34;: team_id,
            &#34;user&#34;: user,
        }
    )
    return self.api_call(&#34;team.integrationLogs&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.team_preferences_list"><code class="name flex">
<span>def <span class="ident">team_preferences_list</span></span>(<span>self, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve a list of a workspace's team preferences.
<a href="https://api.slack.com/methods/team.preferences.list">https://api.slack.com/methods/team.preferences.list</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def team_preferences_list(
    self,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Retrieve a list of a workspace&#39;s team preferences.
    https://api.slack.com/methods/team.preferences.list
    &#34;&#34;&#34;
    return self.api_call(&#34;team.preferences.list&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.team_profile_get"><code class="name flex">
<span>def <span class="ident">team_profile_get</span></span>(<span>self, *, visibility: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve a team's profile.
<a href="https://api.slack.com/methods/team.profile.get">https://api.slack.com/methods/team.profile.get</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def team_profile_get(
    self,
    *,
    visibility: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Retrieve a team&#39;s profile.
    https://api.slack.com/methods/team.profile.get
    &#34;&#34;&#34;
    kwargs.update({&#34;visibility&#34;: visibility})
    return self.api_call(&#34;team.profile.get&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.tooling_tokens_rotate"><code class="name flex">
<span>def <span class="ident">tooling_tokens_rotate</span></span>(<span>self, *, refresh_token: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Exchanges a refresh token for a new app configuration token
<a href="https://api.slack.com/methods/tooling.tokens.rotate">https://api.slack.com/methods/tooling.tokens.rotate</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tooling_tokens_rotate(
    self,
    *,
    refresh_token: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Exchanges a refresh token for a new app configuration token
    https://api.slack.com/methods/tooling.tokens.rotate
    &#34;&#34;&#34;
    kwargs.update({&#34;refresh_token&#34;: refresh_token})
    return self.api_call(&#34;tooling.tokens.rotate&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.usergroups_create"><code class="name flex">
<span>def <span class="ident">usergroups_create</span></span>(<span>self, *, name: str, channels: Union[str, Sequence[str], ForwardRef(None)] = None, description: Optional[str] = None, handle: Optional[str] = None, include_count: Optional[bool] = None, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Create a User Group
<a href="https://api.slack.com/methods/usergroups.create">https://api.slack.com/methods/usergroups.create</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def usergroups_create(
    self,
    *,
    name: str,
    channels: Optional[Union[str, Sequence[str]]] = None,
    description: Optional[str] = None,
    handle: Optional[str] = None,
    include_count: Optional[bool] = None,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Create a User Group
    https://api.slack.com/methods/usergroups.create
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;name&#34;: name,
            &#34;description&#34;: description,
            &#34;handle&#34;: handle,
            &#34;include_count&#34;: include_count,
            &#34;team_id&#34;: team_id,
        }
    )
    if isinstance(channels, (list, Tuple)):
        kwargs.update({&#34;channels&#34;: &#34;,&#34;.join(channels)})
    else:
        kwargs.update({&#34;channels&#34;: channels})
    return self.api_call(&#34;usergroups.create&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.usergroups_disable"><code class="name flex">
<span>def <span class="ident">usergroups_disable</span></span>(<span>self, *, usergroup: str, include_count: Optional[bool] = None, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Disable an existing User Group
<a href="https://api.slack.com/methods/usergroups.disable">https://api.slack.com/methods/usergroups.disable</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def usergroups_disable(
    self,
    *,
    usergroup: str,
    include_count: Optional[bool] = None,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Disable an existing User Group
    https://api.slack.com/methods/usergroups.disable
    &#34;&#34;&#34;
    kwargs.update({&#34;usergroup&#34;: usergroup, &#34;include_count&#34;: include_count, &#34;team_id&#34;: team_id})
    return self.api_call(&#34;usergroups.disable&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.usergroups_enable"><code class="name flex">
<span>def <span class="ident">usergroups_enable</span></span>(<span>self, *, usergroup: str, include_count: Optional[bool] = None, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Enable a User Group
<a href="https://api.slack.com/methods/usergroups.enable">https://api.slack.com/methods/usergroups.enable</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def usergroups_enable(
    self,
    *,
    usergroup: str,
    include_count: Optional[bool] = None,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Enable a User Group
    https://api.slack.com/methods/usergroups.enable
    &#34;&#34;&#34;
    kwargs.update({&#34;usergroup&#34;: usergroup, &#34;include_count&#34;: include_count, &#34;team_id&#34;: team_id})
    return self.api_call(&#34;usergroups.enable&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.usergroups_list"><code class="name flex">
<span>def <span class="ident">usergroups_list</span></span>(<span>self, *, include_count: Optional[bool] = None, include_disabled: Optional[bool] = None, include_users: Optional[bool] = None, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>List all User Groups for a team
<a href="https://api.slack.com/methods/usergroups.list">https://api.slack.com/methods/usergroups.list</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def usergroups_list(
    self,
    *,
    include_count: Optional[bool] = None,
    include_disabled: Optional[bool] = None,
    include_users: Optional[bool] = None,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;List all User Groups for a team
    https://api.slack.com/methods/usergroups.list
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;include_count&#34;: include_count,
            &#34;include_disabled&#34;: include_disabled,
            &#34;include_users&#34;: include_users,
            &#34;team_id&#34;: team_id,
        }
    )
    return self.api_call(&#34;usergroups.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.usergroups_update"><code class="name flex">
<span>def <span class="ident">usergroups_update</span></span>(<span>self, *, usergroup: str, channels: Union[str, Sequence[str], ForwardRef(None)] = None, description: Optional[str] = None, handle: Optional[str] = None, include_count: Optional[bool] = None, name: Optional[str] = None, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Update an existing User Group
<a href="https://api.slack.com/methods/usergroups.update">https://api.slack.com/methods/usergroups.update</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def usergroups_update(
    self,
    *,
    usergroup: str,
    channels: Optional[Union[str, Sequence[str]]] = None,
    description: Optional[str] = None,
    handle: Optional[str] = None,
    include_count: Optional[bool] = None,
    name: Optional[str] = None,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Update an existing User Group
    https://api.slack.com/methods/usergroups.update
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;usergroup&#34;: usergroup,
            &#34;description&#34;: description,
            &#34;handle&#34;: handle,
            &#34;include_count&#34;: include_count,
            &#34;name&#34;: name,
            &#34;team_id&#34;: team_id,
        }
    )
    if isinstance(channels, (list, Tuple)):
        kwargs.update({&#34;channels&#34;: &#34;,&#34;.join(channels)})
    else:
        kwargs.update({&#34;channels&#34;: channels})
    return self.api_call(&#34;usergroups.update&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.usergroups_users_list"><code class="name flex">
<span>def <span class="ident">usergroups_users_list</span></span>(<span>self, *, usergroup: str, include_disabled: Optional[bool] = None, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>List all users in a User Group
<a href="https://api.slack.com/methods/usergroups.users.list">https://api.slack.com/methods/usergroups.users.list</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def usergroups_users_list(
    self,
    *,
    usergroup: str,
    include_disabled: Optional[bool] = None,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;List all users in a User Group
    https://api.slack.com/methods/usergroups.users.list
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;usergroup&#34;: usergroup,
            &#34;include_disabled&#34;: include_disabled,
            &#34;team_id&#34;: team_id,
        }
    )
    return self.api_call(&#34;usergroups.users.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.usergroups_users_update"><code class="name flex">
<span>def <span class="ident">usergroups_users_update</span></span>(<span>self, *, usergroup: str, users: Union[str, Sequence[str]], include_count: Optional[bool] = None, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Update the list of users for a User Group
<a href="https://api.slack.com/methods/usergroups.users.update">https://api.slack.com/methods/usergroups.users.update</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def usergroups_users_update(
    self,
    *,
    usergroup: str,
    users: Union[str, Sequence[str]],
    include_count: Optional[bool] = None,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Update the list of users for a User Group
    https://api.slack.com/methods/usergroups.users.update
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;usergroup&#34;: usergroup,
            &#34;include_count&#34;: include_count,
            &#34;team_id&#34;: team_id,
        }
    )
    if isinstance(users, (list, Tuple)):
        kwargs.update({&#34;users&#34;: &#34;,&#34;.join(users)})
    else:
        kwargs.update({&#34;users&#34;: users})
    return self.api_call(&#34;usergroups.users.update&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.users_conversations"><code class="name flex">
<span>def <span class="ident">users_conversations</span></span>(<span>self, *, cursor: Optional[str] = None, exclude_archived: Optional[bool] = None, limit: Optional[int] = None, team_id: Optional[str] = None, types: Union[str, Sequence[str], ForwardRef(None)] = None, user: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>List conversations the calling user may access.
<a href="https://api.slack.com/methods/users.conversations">https://api.slack.com/methods/users.conversations</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def users_conversations(
    self,
    *,
    cursor: Optional[str] = None,
    exclude_archived: Optional[bool] = None,
    limit: Optional[int] = None,
    team_id: Optional[str] = None,
    types: Optional[Union[str, Sequence[str]]] = None,
    user: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;List conversations the calling user may access.
    https://api.slack.com/methods/users.conversations
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;cursor&#34;: cursor,
            &#34;exclude_archived&#34;: exclude_archived,
            &#34;limit&#34;: limit,
            &#34;team_id&#34;: team_id,
            &#34;user&#34;: user,
        }
    )
    if isinstance(types, (list, Tuple)):
        kwargs.update({&#34;types&#34;: &#34;,&#34;.join(types)})
    else:
        kwargs.update({&#34;types&#34;: types})
    return self.api_call(&#34;users.conversations&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.users_deletePhoto"><code class="name flex">
<span>def <span class="ident">users_deletePhoto</span></span>(<span>self, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Delete the user profile photo
<a href="https://api.slack.com/methods/users.deletePhoto">https://api.slack.com/methods/users.deletePhoto</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def users_deletePhoto(
    self,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Delete the user profile photo
    https://api.slack.com/methods/users.deletePhoto
    &#34;&#34;&#34;
    return self.api_call(&#34;users.deletePhoto&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.users_getPresence"><code class="name flex">
<span>def <span class="ident">users_getPresence</span></span>(<span>self, *, user: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets user presence information.
<a href="https://api.slack.com/methods/users.getPresence">https://api.slack.com/methods/users.getPresence</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def users_getPresence(
    self,
    *,
    user: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Gets user presence information.
    https://api.slack.com/methods/users.getPresence
    &#34;&#34;&#34;
    kwargs.update({&#34;user&#34;: user})
    return self.api_call(&#34;users.getPresence&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.users_identity"><code class="name flex">
<span>def <span class="ident">users_identity</span></span>(<span>self, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get a user's identity.
<a href="https://api.slack.com/methods/users.identity">https://api.slack.com/methods/users.identity</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def users_identity(
    self,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Get a user&#39;s identity.
    https://api.slack.com/methods/users.identity
    &#34;&#34;&#34;
    return self.api_call(&#34;users.identity&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.users_info"><code class="name flex">
<span>def <span class="ident">users_info</span></span>(<span>self, *, user: str, include_locale: Optional[bool] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets information about a user.
<a href="https://api.slack.com/methods/users.info">https://api.slack.com/methods/users.info</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def users_info(
    self,
    *,
    user: str,
    include_locale: Optional[bool] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Gets information about a user.
    https://api.slack.com/methods/users.info
    &#34;&#34;&#34;
    kwargs.update({&#34;user&#34;: user, &#34;include_locale&#34;: include_locale})
    return self.api_call(&#34;users.info&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.users_list"><code class="name flex">
<span>def <span class="ident">users_list</span></span>(<span>self, *, cursor: Optional[str] = None, include_locale: Optional[bool] = None, limit: Optional[int] = None, team_id: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Lists all users in a Slack team.
<a href="https://api.slack.com/methods/users.list">https://api.slack.com/methods/users.list</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def users_list(
    self,
    *,
    cursor: Optional[str] = None,
    include_locale: Optional[bool] = None,
    limit: Optional[int] = None,
    team_id: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Lists all users in a Slack team.
    https://api.slack.com/methods/users.list
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;cursor&#34;: cursor,
            &#34;include_locale&#34;: include_locale,
            &#34;limit&#34;: limit,
            &#34;team_id&#34;: team_id,
        }
    )
    return self.api_call(&#34;users.list&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.users_lookupByEmail"><code class="name flex">
<span>def <span class="ident">users_lookupByEmail</span></span>(<span>self, *, email: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Find a user with an email address.
<a href="https://api.slack.com/methods/users.lookupByEmail">https://api.slack.com/methods/users.lookupByEmail</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def users_lookupByEmail(
    self,
    *,
    email: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Find a user with an email address.
    https://api.slack.com/methods/users.lookupByEmail
    &#34;&#34;&#34;
    kwargs.update({&#34;email&#34;: email})
    return self.api_call(&#34;users.lookupByEmail&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.users_profile_get"><code class="name flex">
<span>def <span class="ident">users_profile_get</span></span>(<span>self, *, user: Optional[str] = None, include_labels: Optional[bool] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves a user's profile information.
<a href="https://api.slack.com/methods/users.profile.get">https://api.slack.com/methods/users.profile.get</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def users_profile_get(
    self,
    *,
    user: Optional[str] = None,
    include_labels: Optional[bool] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Retrieves a user&#39;s profile information.
    https://api.slack.com/methods/users.profile.get
    &#34;&#34;&#34;
    kwargs.update({&#34;user&#34;: user, &#34;include_labels&#34;: include_labels})
    return self.api_call(&#34;users.profile.get&#34;, http_verb=&#34;GET&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.users_profile_set"><code class="name flex">
<span>def <span class="ident">users_profile_set</span></span>(<span>self, *, name: Optional[str] = None, value: Optional[str] = None, user: Optional[str] = None, profile: Optional[Dict] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Set the profile information for a user.
<a href="https://api.slack.com/methods/users.profile.set">https://api.slack.com/methods/users.profile.set</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def users_profile_set(
    self,
    *,
    name: Optional[str] = None,
    value: Optional[str] = None,
    user: Optional[str] = None,
    profile: Optional[Dict] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Set the profile information for a user.
    https://api.slack.com/methods/users.profile.set
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;name&#34;: name,
            &#34;profile&#34;: profile,
            &#34;user&#34;: user,
            &#34;value&#34;: value,
        }
    )
    kwargs = _remove_none_values(kwargs)
    # NOTE: Intentionally using json for the &#34;profile&#34; parameter
    return self.api_call(&#34;users.profile.set&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.users_setPhoto"><code class="name flex">
<span>def <span class="ident">users_setPhoto</span></span>(<span>self, *, image: Union[str, io.IOBase], crop_w: Union[str, int, ForwardRef(None)] = None, crop_x: Union[str, int, ForwardRef(None)] = None, crop_y: Union[str, int, ForwardRef(None)] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Set the user profile photo
<a href="https://api.slack.com/methods/users.setPhoto">https://api.slack.com/methods/users.setPhoto</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def users_setPhoto(
    self,
    *,
    image: Union[str, IOBase],
    crop_w: Optional[Union[int, str]] = None,
    crop_x: Optional[Union[int, str]] = None,
    crop_y: Optional[Union[int, str]] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Set the user profile photo
    https://api.slack.com/methods/users.setPhoto
    &#34;&#34;&#34;
    kwargs.update({&#34;crop_w&#34;: crop_w, &#34;crop_x&#34;: crop_x, &#34;crop_y&#34;: crop_y})
    return self.api_call(&#34;users.setPhoto&#34;, files={&#34;image&#34;: image}, data=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.users_setPresence"><code class="name flex">
<span>def <span class="ident">users_setPresence</span></span>(<span>self, *, presence: str, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Manually sets user presence.
<a href="https://api.slack.com/methods/users.setPresence">https://api.slack.com/methods/users.setPresence</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def users_setPresence(
    self,
    *,
    presence: str,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Manually sets user presence.
    https://api.slack.com/methods/users.setPresence
    &#34;&#34;&#34;
    kwargs.update({&#34;presence&#34;: presence})
    return self.api_call(&#34;users.setPresence&#34;, params=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.views_open"><code class="name flex">
<span>def <span class="ident">views_open</span></span>(<span>self, *, trigger_id: str, view: Union[dict, <a title="slack_sdk.models.views.View" href="../models/views/index.html#slack_sdk.models.views.View">View</a>], **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Open a view for a user.
<a href="https://api.slack.com/methods/views.open">https://api.slack.com/methods/views.open</a>
See <a href="https://api.slack.com/block-kit/surfaces/modals">https://api.slack.com/block-kit/surfaces/modals</a> for details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def views_open(
    self,
    *,
    trigger_id: str,
    view: Union[dict, View],
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Open a view for a user.
    https://api.slack.com/methods/views.open
    See https://api.slack.com/block-kit/surfaces/modals for details.
    &#34;&#34;&#34;
    kwargs.update({&#34;trigger_id&#34;: trigger_id})
    if isinstance(view, View):
        kwargs.update({&#34;view&#34;: view.to_dict()})
    else:
        kwargs.update({&#34;view&#34;: view})
    kwargs = _remove_none_values(kwargs)
    # NOTE: Intentionally using json for the &#34;view&#34; parameter
    return self.api_call(&#34;views.open&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.views_publish"><code class="name flex">
<span>def <span class="ident">views_publish</span></span>(<span>self, *, user_id: str, view: Union[dict, <a title="slack_sdk.models.views.View" href="../models/views/index.html#slack_sdk.models.views.View">View</a>], hash: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Publish a static view for a User.
Create or update the view that comprises an
app's Home tab (<a href="https://api.slack.com/surfaces/tabs">https://api.slack.com/surfaces/tabs</a>)
<a href="https://api.slack.com/methods/views.publish">https://api.slack.com/methods/views.publish</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def views_publish(
    self,
    *,
    user_id: str,
    view: Union[dict, View],
    hash: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Publish a static view for a User.
    Create or update the view that comprises an
    app&#39;s Home tab (https://api.slack.com/surfaces/tabs)
    https://api.slack.com/methods/views.publish
    &#34;&#34;&#34;
    kwargs.update({&#34;user_id&#34;: user_id, &#34;hash&#34;: hash})
    if isinstance(view, View):
        kwargs.update({&#34;view&#34;: view.to_dict()})
    else:
        kwargs.update({&#34;view&#34;: view})
    kwargs = _remove_none_values(kwargs)
    # NOTE: Intentionally using json for the &#34;view&#34; parameter
    return self.api_call(&#34;views.publish&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.views_push"><code class="name flex">
<span>def <span class="ident">views_push</span></span>(<span>self, *, trigger_id: str, view: Union[dict, <a title="slack_sdk.models.views.View" href="../models/views/index.html#slack_sdk.models.views.View">View</a>], **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Push a view onto the stack of a root view.
Push a new view onto the existing view stack by passing a view
payload and a valid trigger_id generated from an interaction
within the existing modal.
Read the modals documentation (<a href="https://api.slack.com/block-kit/surfaces/modals">https://api.slack.com/block-kit/surfaces/modals</a>)
to learn more about the lifecycle and intricacies of views.
<a href="https://api.slack.com/methods/views.push">https://api.slack.com/methods/views.push</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def views_push(
    self,
    *,
    trigger_id: str,
    view: Union[dict, View],
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Push a view onto the stack of a root view.
    Push a new view onto the existing view stack by passing a view
    payload and a valid trigger_id generated from an interaction
    within the existing modal.
    Read the modals documentation (https://api.slack.com/block-kit/surfaces/modals)
    to learn more about the lifecycle and intricacies of views.
    https://api.slack.com/methods/views.push
    &#34;&#34;&#34;
    kwargs.update({&#34;trigger_id&#34;: trigger_id})
    if isinstance(view, View):
        kwargs.update({&#34;view&#34;: view.to_dict()})
    else:
        kwargs.update({&#34;view&#34;: view})
    kwargs = _remove_none_values(kwargs)
    # NOTE: Intentionally using json for the &#34;view&#34; parameter
    return self.api_call(&#34;views.push&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.views_update"><code class="name flex">
<span>def <span class="ident">views_update</span></span>(<span>self, *, view: Union[dict, <a title="slack_sdk.models.views.View" href="../models/views/index.html#slack_sdk.models.views.View">View</a>], external_id: Optional[str] = None, view_id: Optional[str] = None, hash: Optional[str] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Update an existing view.
Update a view by passing a new view definition along with the
view_id returned in views.open or the external_id.
See the modals documentation (<a href="https://api.slack.com/block-kit/surfaces/modals#updating_views">https://api.slack.com/block-kit/surfaces/modals#updating_views</a>)
to learn more about updating views and avoiding race conditions with the hash argument.
<a href="https://api.slack.com/methods/views.update">https://api.slack.com/methods/views.update</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def views_update(
    self,
    *,
    view: Union[dict, View],
    external_id: Optional[str] = None,
    view_id: Optional[str] = None,
    hash: Optional[str] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Update an existing view.
    Update a view by passing a new view definition along with the
    view_id returned in views.open or the external_id.
    See the modals documentation (https://api.slack.com/block-kit/surfaces/modals#updating_views)
    to learn more about updating views and avoiding race conditions with the hash argument.
    https://api.slack.com/methods/views.update
    &#34;&#34;&#34;
    if isinstance(view, View):
        kwargs.update({&#34;view&#34;: view.to_dict()})
    else:
        kwargs.update({&#34;view&#34;: view})
    if external_id:
        kwargs.update({&#34;external_id&#34;: external_id})
    elif view_id:
        kwargs.update({&#34;view_id&#34;: view_id})
    else:
        raise e.SlackRequestError(&#34;Either view_id or external_id is required.&#34;)
    kwargs.update({&#34;hash&#34;: hash})
    kwargs = _remove_none_values(kwargs)
    # NOTE: Intentionally using json for the &#34;view&#34; parameter
    return self.api_call(&#34;views.update&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.workflows_stepCompleted"><code class="name flex">
<span>def <span class="ident">workflows_stepCompleted</span></span>(<span>self, *, workflow_step_execute_id: str, outputs: Optional[dict] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Indicate a successful outcome of a workflow step's execution.
<a href="https://api.slack.com/methods/workflows.stepCompleted">https://api.slack.com/methods/workflows.stepCompleted</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def workflows_stepCompleted(
    self,
    *,
    workflow_step_execute_id: str,
    outputs: Optional[dict] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Indicate a successful outcome of a workflow step&#39;s execution.
    https://api.slack.com/methods/workflows.stepCompleted
    &#34;&#34;&#34;
    kwargs.update({&#34;workflow_step_execute_id&#34;: workflow_step_execute_id})
    if outputs is not None:
        kwargs.update({&#34;outputs&#34;: outputs})
    kwargs = _remove_none_values(kwargs)
    # NOTE: Intentionally using json for the &#34;outputs&#34; parameter
    return self.api_call(&#34;workflows.stepCompleted&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.workflows_stepFailed"><code class="name flex">
<span>def <span class="ident">workflows_stepFailed</span></span>(<span>self, *, workflow_step_execute_id: str, error: Dict[str, str], **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Indicate an unsuccessful outcome of a workflow step's execution.
<a href="https://api.slack.com/methods/workflows.stepFailed">https://api.slack.com/methods/workflows.stepFailed</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def workflows_stepFailed(
    self,
    *,
    workflow_step_execute_id: str,
    error: Dict[str, str],
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Indicate an unsuccessful outcome of a workflow step&#39;s execution.
    https://api.slack.com/methods/workflows.stepFailed
    &#34;&#34;&#34;
    kwargs.update(
        {
            &#34;workflow_step_execute_id&#34;: workflow_step_execute_id,
            &#34;error&#34;: error,
        }
    )
    kwargs = _remove_none_values(kwargs)
    # NOTE: Intentionally using json for the &#34;error&#34; parameter
    return self.api_call(&#34;workflows.stepFailed&#34;, json=kwargs)</code></pre>
</details>
</dd>
<dt id="slack_sdk.web.legacy_client.LegacyWebClient.workflows_updateStep"><code class="name flex">
<span>def <span class="ident">workflows_updateStep</span></span>(<span>self, *, workflow_step_edit_id: str, inputs: Optional[Dict[str, Any]] = None, outputs: Optional[List[Dict[str, str]]] = None, **kwargs) ‑> Union[_asyncio.Future, <a title="slack_sdk.web.legacy_slack_response.LegacySlackResponse" href="legacy_slack_response.html#slack_sdk.web.legacy_slack_response.LegacySlackResponse">LegacySlackResponse</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Update the configuration for a workflow extension step.
<a href="https://api.slack.com/methods/workflows.updateStep">https://api.slack.com/methods/workflows.updateStep</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def workflows_updateStep(
    self,
    *,
    workflow_step_edit_id: str,
    inputs: Optional[Dict[str, Any]] = None,
    outputs: Optional[List[Dict[str, str]]] = None,
    **kwargs,
) -&gt; Union[Future, SlackResponse]:
    &#34;&#34;&#34;Update the configuration for a workflow extension step.
    https://api.slack.com/methods/workflows.updateStep
    &#34;&#34;&#34;
    kwargs.update({&#34;workflow_step_edit_id&#34;: workflow_step_edit_id})
    if inputs is not None:
        kwargs.update({&#34;inputs&#34;: inputs})
    if outputs is not None:
        kwargs.update({&#34;outputs&#34;: outputs})
    kwargs = _remove_none_values(kwargs)
    # NOTE: Intentionally using json for the &#34;inputs&#34; / &#34;outputs&#34; parameters
    return self.api_call(&#34;workflows.updateStep&#34;, json=kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="slack_sdk.web.legacy_base_client.LegacyBaseClient" href="legacy_base_client.html#slack_sdk.web.legacy_base_client.LegacyBaseClient">LegacyBaseClient</a></b></code>:
<ul class="hlist">
<li><code><a title="slack_sdk.web.legacy_base_client.LegacyBaseClient.api_call" href="legacy_base_client.html#slack_sdk.web.legacy_base_client.LegacyBaseClient.api_call">api_call</a></code></li>
<li><code><a title="slack_sdk.web.legacy_base_client.LegacyBaseClient.base_url" href="legacy_base_client.html#slack_sdk.web.legacy_base_client.LegacyBaseClient.base_url">base_url</a></code></li>
<li><code><a title="slack_sdk.web.legacy_base_client.LegacyBaseClient.headers" href="legacy_base_client.html#slack_sdk.web.legacy_base_client.LegacyBaseClient.headers">headers</a></code></li>
<li><code><a title="slack_sdk.web.legacy_base_client.LegacyBaseClient.proxy" href="legacy_base_client.html#slack_sdk.web.legacy_base_client.LegacyBaseClient.proxy">proxy</a></code></li>
<li><code><a title="slack_sdk.web.legacy_base_client.LegacyBaseClient.ssl" href="legacy_base_client.html#slack_sdk.web.legacy_base_client.LegacyBaseClient.ssl">ssl</a></code></li>
<li><code><a title="slack_sdk.web.legacy_base_client.LegacyBaseClient.timeout" href="legacy_base_client.html#slack_sdk.web.legacy_base_client.LegacyBaseClient.timeout">timeout</a></code></li>
<li><code><a title="slack_sdk.web.legacy_base_client.LegacyBaseClient.token" href="legacy_base_client.html#slack_sdk.web.legacy_base_client.LegacyBaseClient.token">token</a></code></li>
<li><code><a title="slack_sdk.web.legacy_base_client.LegacyBaseClient.validate_slack_signature" href="legacy_base_client.html#slack_sdk.web.legacy_base_client.LegacyBaseClient.validate_slack_signature">validate_slack_signature</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="slack_sdk.web" href="index.html">slack_sdk.web</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="slack_sdk.web.legacy_client.LegacyWebClient" href="#slack_sdk.web.legacy_client.LegacyWebClient">LegacyWebClient</a></code></h4>
<ul class="">
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_analytics_getFile" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_analytics_getFile">admin_analytics_getFile</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_activities_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_activities_list">admin_apps_activities_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_approve" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_approve">admin_apps_approve</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_approved_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_approved_list">admin_apps_approved_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_clearResolution" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_clearResolution">admin_apps_clearResolution</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_config_lookup" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_config_lookup">admin_apps_config_lookup</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_config_set" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_config_set">admin_apps_config_set</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_requests_cancel" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_requests_cancel">admin_apps_requests_cancel</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_requests_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_requests_list">admin_apps_requests_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_restrict" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_restrict">admin_apps_restrict</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_restricted_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_restricted_list">admin_apps_restricted_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_uninstall" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_apps_uninstall">admin_apps_uninstall</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_auth_policy_assignEntities" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_auth_policy_assignEntities">admin_auth_policy_assignEntities</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_auth_policy_getEntities" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_auth_policy_getEntities">admin_auth_policy_getEntities</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_auth_policy_removeEntities" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_auth_policy_removeEntities">admin_auth_policy_removeEntities</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_barriers_create" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_barriers_create">admin_barriers_create</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_barriers_delete" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_barriers_delete">admin_barriers_delete</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_barriers_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_barriers_list">admin_barriers_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_barriers_update" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_barriers_update">admin_barriers_update</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_archive" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_archive">admin_conversations_archive</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_bulkArchive" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_bulkArchive">admin_conversations_bulkArchive</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_bulkDelete" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_bulkDelete">admin_conversations_bulkDelete</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_bulkMove" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_bulkMove">admin_conversations_bulkMove</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_convertToPrivate" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_convertToPrivate">admin_conversations_convertToPrivate</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_convertToPublic" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_convertToPublic">admin_conversations_convertToPublic</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_create" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_create">admin_conversations_create</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_delete" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_delete">admin_conversations_delete</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_disconnectShared" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_disconnectShared">admin_conversations_disconnectShared</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_ekm_listOriginalConnectedChannelInfo" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_ekm_listOriginalConnectedChannelInfo">admin_conversations_ekm_listOriginalConnectedChannelInfo</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_getConversationPrefs" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_getConversationPrefs">admin_conversations_getConversationPrefs</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_getCustomRetention" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_getCustomRetention">admin_conversations_getCustomRetention</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_getTeams" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_getTeams">admin_conversations_getTeams</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_invite" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_invite">admin_conversations_invite</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_lookup" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_lookup">admin_conversations_lookup</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_removeCustomRetention" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_removeCustomRetention">admin_conversations_removeCustomRetention</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_rename" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_rename">admin_conversations_rename</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_restrictAccess_addGroup" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_restrictAccess_addGroup">admin_conversations_restrictAccess_addGroup</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_restrictAccess_listGroups" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_restrictAccess_listGroups">admin_conversations_restrictAccess_listGroups</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_restrictAccess_removeGroup" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_restrictAccess_removeGroup">admin_conversations_restrictAccess_removeGroup</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_search" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_search">admin_conversations_search</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_setConversationPrefs" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_setConversationPrefs">admin_conversations_setConversationPrefs</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_setCustomRetention" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_setCustomRetention">admin_conversations_setCustomRetention</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_setTeams" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_setTeams">admin_conversations_setTeams</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_unarchive" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_conversations_unarchive">admin_conversations_unarchive</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_emoji_add" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_emoji_add">admin_emoji_add</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_emoji_addAlias" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_emoji_addAlias">admin_emoji_addAlias</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_emoji_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_emoji_list">admin_emoji_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_emoji_remove" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_emoji_remove">admin_emoji_remove</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_emoji_rename" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_emoji_rename">admin_emoji_rename</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_functions_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_functions_list">admin_functions_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_functions_permissions_lookup" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_functions_permissions_lookup">admin_functions_permissions_lookup</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_functions_permissions_set" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_functions_permissions_set">admin_functions_permissions_set</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_inviteRequests_approve" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_inviteRequests_approve">admin_inviteRequests_approve</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_inviteRequests_approved_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_inviteRequests_approved_list">admin_inviteRequests_approved_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_inviteRequests_denied_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_inviteRequests_denied_list">admin_inviteRequests_denied_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_inviteRequests_deny" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_inviteRequests_deny">admin_inviteRequests_deny</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_inviteRequests_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_inviteRequests_list">admin_inviteRequests_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_roles_addAssignments" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_roles_addAssignments">admin_roles_addAssignments</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_roles_listAssignments" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_roles_listAssignments">admin_roles_listAssignments</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_roles_removeAssignments" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_roles_removeAssignments">admin_roles_removeAssignments</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_teams_admins_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_teams_admins_list">admin_teams_admins_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_teams_create" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_teams_create">admin_teams_create</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_teams_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_teams_list">admin_teams_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_teams_owners_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_teams_owners_list">admin_teams_owners_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_teams_settings_info" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_teams_settings_info">admin_teams_settings_info</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_teams_settings_setDefaultChannels" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_teams_settings_setDefaultChannels">admin_teams_settings_setDefaultChannels</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_teams_settings_setDescription" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_teams_settings_setDescription">admin_teams_settings_setDescription</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_teams_settings_setDiscoverability" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_teams_settings_setDiscoverability">admin_teams_settings_setDiscoverability</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_teams_settings_setIcon" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_teams_settings_setIcon">admin_teams_settings_setIcon</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_teams_settings_setName" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_teams_settings_setName">admin_teams_settings_setName</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_usergroups_addChannels" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_usergroups_addChannels">admin_usergroups_addChannels</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_usergroups_addTeams" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_usergroups_addTeams">admin_usergroups_addTeams</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_usergroups_listChannels" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_usergroups_listChannels">admin_usergroups_listChannels</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_usergroups_removeChannels" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_usergroups_removeChannels">admin_usergroups_removeChannels</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_assign" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_users_assign">admin_users_assign</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_invite" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_users_invite">admin_users_invite</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_users_list">admin_users_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_remove" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_users_remove">admin_users_remove</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_session_clearSettings" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_users_session_clearSettings">admin_users_session_clearSettings</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_session_getSettings" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_users_session_getSettings">admin_users_session_getSettings</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_session_invalidate" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_users_session_invalidate">admin_users_session_invalidate</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_session_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_users_session_list">admin_users_session_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_session_reset" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_users_session_reset">admin_users_session_reset</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_session_resetBulk" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_users_session_resetBulk">admin_users_session_resetBulk</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_session_setSettings" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_users_session_setSettings">admin_users_session_setSettings</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_setAdmin" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_users_setAdmin">admin_users_setAdmin</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_setExpiration" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_users_setExpiration">admin_users_setExpiration</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_setOwner" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_users_setOwner">admin_users_setOwner</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_setRegular" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_users_setRegular">admin_users_setRegular</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_users_unsupportedVersions_export" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_users_unsupportedVersions_export">admin_users_unsupportedVersions_export</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_workflows_collaborators_add" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_workflows_collaborators_add">admin_workflows_collaborators_add</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_workflows_collaborators_remove" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_workflows_collaborators_remove">admin_workflows_collaborators_remove</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_workflows_permissions_lookup" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_workflows_permissions_lookup">admin_workflows_permissions_lookup</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_workflows_search" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_workflows_search">admin_workflows_search</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.admin_workflows_unpublish" href="#slack_sdk.web.legacy_client.LegacyWebClient.admin_workflows_unpublish">admin_workflows_unpublish</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.api_test" href="#slack_sdk.web.legacy_client.LegacyWebClient.api_test">api_test</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.apps_connections_open" href="#slack_sdk.web.legacy_client.LegacyWebClient.apps_connections_open">apps_connections_open</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.apps_event_authorizations_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.apps_event_authorizations_list">apps_event_authorizations_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.apps_manifest_create" href="#slack_sdk.web.legacy_client.LegacyWebClient.apps_manifest_create">apps_manifest_create</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.apps_manifest_delete" href="#slack_sdk.web.legacy_client.LegacyWebClient.apps_manifest_delete">apps_manifest_delete</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.apps_manifest_export" href="#slack_sdk.web.legacy_client.LegacyWebClient.apps_manifest_export">apps_manifest_export</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.apps_manifest_update" href="#slack_sdk.web.legacy_client.LegacyWebClient.apps_manifest_update">apps_manifest_update</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.apps_manifest_validate" href="#slack_sdk.web.legacy_client.LegacyWebClient.apps_manifest_validate">apps_manifest_validate</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.apps_uninstall" href="#slack_sdk.web.legacy_client.LegacyWebClient.apps_uninstall">apps_uninstall</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.auth_revoke" href="#slack_sdk.web.legacy_client.LegacyWebClient.auth_revoke">auth_revoke</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.auth_teams_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.auth_teams_list">auth_teams_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.auth_test" href="#slack_sdk.web.legacy_client.LegacyWebClient.auth_test">auth_test</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.bookmarks_add" href="#slack_sdk.web.legacy_client.LegacyWebClient.bookmarks_add">bookmarks_add</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.bookmarks_edit" href="#slack_sdk.web.legacy_client.LegacyWebClient.bookmarks_edit">bookmarks_edit</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.bookmarks_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.bookmarks_list">bookmarks_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.bookmarks_remove" href="#slack_sdk.web.legacy_client.LegacyWebClient.bookmarks_remove">bookmarks_remove</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.bots_info" href="#slack_sdk.web.legacy_client.LegacyWebClient.bots_info">bots_info</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.calls_add" href="#slack_sdk.web.legacy_client.LegacyWebClient.calls_add">calls_add</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.calls_end" href="#slack_sdk.web.legacy_client.LegacyWebClient.calls_end">calls_end</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.calls_info" href="#slack_sdk.web.legacy_client.LegacyWebClient.calls_info">calls_info</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.calls_participants_add" href="#slack_sdk.web.legacy_client.LegacyWebClient.calls_participants_add">calls_participants_add</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.calls_participants_remove" href="#slack_sdk.web.legacy_client.LegacyWebClient.calls_participants_remove">calls_participants_remove</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.calls_update" href="#slack_sdk.web.legacy_client.LegacyWebClient.calls_update">calls_update</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.channels_archive" href="#slack_sdk.web.legacy_client.LegacyWebClient.channels_archive">channels_archive</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.channels_create" href="#slack_sdk.web.legacy_client.LegacyWebClient.channels_create">channels_create</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.channels_history" href="#slack_sdk.web.legacy_client.LegacyWebClient.channels_history">channels_history</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.channels_info" href="#slack_sdk.web.legacy_client.LegacyWebClient.channels_info">channels_info</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.channels_invite" href="#slack_sdk.web.legacy_client.LegacyWebClient.channels_invite">channels_invite</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.channels_join" href="#slack_sdk.web.legacy_client.LegacyWebClient.channels_join">channels_join</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.channels_kick" href="#slack_sdk.web.legacy_client.LegacyWebClient.channels_kick">channels_kick</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.channels_leave" href="#slack_sdk.web.legacy_client.LegacyWebClient.channels_leave">channels_leave</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.channels_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.channels_list">channels_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.channels_mark" href="#slack_sdk.web.legacy_client.LegacyWebClient.channels_mark">channels_mark</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.channels_rename" href="#slack_sdk.web.legacy_client.LegacyWebClient.channels_rename">channels_rename</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.channels_replies" href="#slack_sdk.web.legacy_client.LegacyWebClient.channels_replies">channels_replies</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.channels_setPurpose" href="#slack_sdk.web.legacy_client.LegacyWebClient.channels_setPurpose">channels_setPurpose</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.channels_setTopic" href="#slack_sdk.web.legacy_client.LegacyWebClient.channels_setTopic">channels_setTopic</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.channels_unarchive" href="#slack_sdk.web.legacy_client.LegacyWebClient.channels_unarchive">channels_unarchive</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.chat_delete" href="#slack_sdk.web.legacy_client.LegacyWebClient.chat_delete">chat_delete</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.chat_deleteScheduledMessage" href="#slack_sdk.web.legacy_client.LegacyWebClient.chat_deleteScheduledMessage">chat_deleteScheduledMessage</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.chat_getPermalink" href="#slack_sdk.web.legacy_client.LegacyWebClient.chat_getPermalink">chat_getPermalink</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.chat_meMessage" href="#slack_sdk.web.legacy_client.LegacyWebClient.chat_meMessage">chat_meMessage</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.chat_postEphemeral" href="#slack_sdk.web.legacy_client.LegacyWebClient.chat_postEphemeral">chat_postEphemeral</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.chat_postMessage" href="#slack_sdk.web.legacy_client.LegacyWebClient.chat_postMessage">chat_postMessage</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.chat_scheduleMessage" href="#slack_sdk.web.legacy_client.LegacyWebClient.chat_scheduleMessage">chat_scheduleMessage</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.chat_scheduledMessages_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.chat_scheduledMessages_list">chat_scheduledMessages_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.chat_unfurl" href="#slack_sdk.web.legacy_client.LegacyWebClient.chat_unfurl">chat_unfurl</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.chat_update" href="#slack_sdk.web.legacy_client.LegacyWebClient.chat_update">chat_update</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.conversations_acceptSharedInvite" href="#slack_sdk.web.legacy_client.LegacyWebClient.conversations_acceptSharedInvite">conversations_acceptSharedInvite</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.conversations_approveSharedInvite" href="#slack_sdk.web.legacy_client.LegacyWebClient.conversations_approveSharedInvite">conversations_approveSharedInvite</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.conversations_archive" href="#slack_sdk.web.legacy_client.LegacyWebClient.conversations_archive">conversations_archive</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.conversations_close" href="#slack_sdk.web.legacy_client.LegacyWebClient.conversations_close">conversations_close</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.conversations_create" href="#slack_sdk.web.legacy_client.LegacyWebClient.conversations_create">conversations_create</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.conversations_declineSharedInvite" href="#slack_sdk.web.legacy_client.LegacyWebClient.conversations_declineSharedInvite">conversations_declineSharedInvite</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.conversations_history" href="#slack_sdk.web.legacy_client.LegacyWebClient.conversations_history">conversations_history</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.conversations_info" href="#slack_sdk.web.legacy_client.LegacyWebClient.conversations_info">conversations_info</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.conversations_invite" href="#slack_sdk.web.legacy_client.LegacyWebClient.conversations_invite">conversations_invite</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.conversations_inviteShared" href="#slack_sdk.web.legacy_client.LegacyWebClient.conversations_inviteShared">conversations_inviteShared</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.conversations_join" href="#slack_sdk.web.legacy_client.LegacyWebClient.conversations_join">conversations_join</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.conversations_kick" href="#slack_sdk.web.legacy_client.LegacyWebClient.conversations_kick">conversations_kick</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.conversations_leave" href="#slack_sdk.web.legacy_client.LegacyWebClient.conversations_leave">conversations_leave</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.conversations_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.conversations_list">conversations_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.conversations_listConnectInvites" href="#slack_sdk.web.legacy_client.LegacyWebClient.conversations_listConnectInvites">conversations_listConnectInvites</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.conversations_mark" href="#slack_sdk.web.legacy_client.LegacyWebClient.conversations_mark">conversations_mark</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.conversations_members" href="#slack_sdk.web.legacy_client.LegacyWebClient.conversations_members">conversations_members</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.conversations_open" href="#slack_sdk.web.legacy_client.LegacyWebClient.conversations_open">conversations_open</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.conversations_rename" href="#slack_sdk.web.legacy_client.LegacyWebClient.conversations_rename">conversations_rename</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.conversations_replies" href="#slack_sdk.web.legacy_client.LegacyWebClient.conversations_replies">conversations_replies</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.conversations_setPurpose" href="#slack_sdk.web.legacy_client.LegacyWebClient.conversations_setPurpose">conversations_setPurpose</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.conversations_setTopic" href="#slack_sdk.web.legacy_client.LegacyWebClient.conversations_setTopic">conversations_setTopic</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.conversations_unarchive" href="#slack_sdk.web.legacy_client.LegacyWebClient.conversations_unarchive">conversations_unarchive</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.dialog_open" href="#slack_sdk.web.legacy_client.LegacyWebClient.dialog_open">dialog_open</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.dnd_endDnd" href="#slack_sdk.web.legacy_client.LegacyWebClient.dnd_endDnd">dnd_endDnd</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.dnd_endSnooze" href="#slack_sdk.web.legacy_client.LegacyWebClient.dnd_endSnooze">dnd_endSnooze</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.dnd_info" href="#slack_sdk.web.legacy_client.LegacyWebClient.dnd_info">dnd_info</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.dnd_setSnooze" href="#slack_sdk.web.legacy_client.LegacyWebClient.dnd_setSnooze">dnd_setSnooze</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.dnd_teamInfo" href="#slack_sdk.web.legacy_client.LegacyWebClient.dnd_teamInfo">dnd_teamInfo</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.emoji_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.emoji_list">emoji_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.files_comments_delete" href="#slack_sdk.web.legacy_client.LegacyWebClient.files_comments_delete">files_comments_delete</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.files_completeUploadExternal" href="#slack_sdk.web.legacy_client.LegacyWebClient.files_completeUploadExternal">files_completeUploadExternal</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.files_delete" href="#slack_sdk.web.legacy_client.LegacyWebClient.files_delete">files_delete</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.files_getUploadURLExternal" href="#slack_sdk.web.legacy_client.LegacyWebClient.files_getUploadURLExternal">files_getUploadURLExternal</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.files_info" href="#slack_sdk.web.legacy_client.LegacyWebClient.files_info">files_info</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.files_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.files_list">files_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.files_remote_add" href="#slack_sdk.web.legacy_client.LegacyWebClient.files_remote_add">files_remote_add</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.files_remote_info" href="#slack_sdk.web.legacy_client.LegacyWebClient.files_remote_info">files_remote_info</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.files_remote_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.files_remote_list">files_remote_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.files_remote_remove" href="#slack_sdk.web.legacy_client.LegacyWebClient.files_remote_remove">files_remote_remove</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.files_remote_share" href="#slack_sdk.web.legacy_client.LegacyWebClient.files_remote_share">files_remote_share</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.files_remote_update" href="#slack_sdk.web.legacy_client.LegacyWebClient.files_remote_update">files_remote_update</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.files_revokePublicURL" href="#slack_sdk.web.legacy_client.LegacyWebClient.files_revokePublicURL">files_revokePublicURL</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.files_sharedPublicURL" href="#slack_sdk.web.legacy_client.LegacyWebClient.files_sharedPublicURL">files_sharedPublicURL</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.files_upload" href="#slack_sdk.web.legacy_client.LegacyWebClient.files_upload">files_upload</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.files_upload_v2" href="#slack_sdk.web.legacy_client.LegacyWebClient.files_upload_v2">files_upload_v2</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.functions_completeError" href="#slack_sdk.web.legacy_client.LegacyWebClient.functions_completeError">functions_completeError</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.functions_completeSuccess" href="#slack_sdk.web.legacy_client.LegacyWebClient.functions_completeSuccess">functions_completeSuccess</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.groups_archive" href="#slack_sdk.web.legacy_client.LegacyWebClient.groups_archive">groups_archive</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.groups_create" href="#slack_sdk.web.legacy_client.LegacyWebClient.groups_create">groups_create</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.groups_createChild" href="#slack_sdk.web.legacy_client.LegacyWebClient.groups_createChild">groups_createChild</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.groups_history" href="#slack_sdk.web.legacy_client.LegacyWebClient.groups_history">groups_history</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.groups_info" href="#slack_sdk.web.legacy_client.LegacyWebClient.groups_info">groups_info</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.groups_invite" href="#slack_sdk.web.legacy_client.LegacyWebClient.groups_invite">groups_invite</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.groups_kick" href="#slack_sdk.web.legacy_client.LegacyWebClient.groups_kick">groups_kick</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.groups_leave" href="#slack_sdk.web.legacy_client.LegacyWebClient.groups_leave">groups_leave</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.groups_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.groups_list">groups_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.groups_mark" href="#slack_sdk.web.legacy_client.LegacyWebClient.groups_mark">groups_mark</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.groups_open" href="#slack_sdk.web.legacy_client.LegacyWebClient.groups_open">groups_open</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.groups_rename" href="#slack_sdk.web.legacy_client.LegacyWebClient.groups_rename">groups_rename</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.groups_replies" href="#slack_sdk.web.legacy_client.LegacyWebClient.groups_replies">groups_replies</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.groups_setPurpose" href="#slack_sdk.web.legacy_client.LegacyWebClient.groups_setPurpose">groups_setPurpose</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.groups_setTopic" href="#slack_sdk.web.legacy_client.LegacyWebClient.groups_setTopic">groups_setTopic</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.groups_unarchive" href="#slack_sdk.web.legacy_client.LegacyWebClient.groups_unarchive">groups_unarchive</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.im_close" href="#slack_sdk.web.legacy_client.LegacyWebClient.im_close">im_close</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.im_history" href="#slack_sdk.web.legacy_client.LegacyWebClient.im_history">im_history</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.im_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.im_list">im_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.im_mark" href="#slack_sdk.web.legacy_client.LegacyWebClient.im_mark">im_mark</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.im_open" href="#slack_sdk.web.legacy_client.LegacyWebClient.im_open">im_open</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.im_replies" href="#slack_sdk.web.legacy_client.LegacyWebClient.im_replies">im_replies</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.migration_exchange" href="#slack_sdk.web.legacy_client.LegacyWebClient.migration_exchange">migration_exchange</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.mpim_close" href="#slack_sdk.web.legacy_client.LegacyWebClient.mpim_close">mpim_close</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.mpim_history" href="#slack_sdk.web.legacy_client.LegacyWebClient.mpim_history">mpim_history</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.mpim_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.mpim_list">mpim_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.mpim_mark" href="#slack_sdk.web.legacy_client.LegacyWebClient.mpim_mark">mpim_mark</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.mpim_open" href="#slack_sdk.web.legacy_client.LegacyWebClient.mpim_open">mpim_open</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.mpim_replies" href="#slack_sdk.web.legacy_client.LegacyWebClient.mpim_replies">mpim_replies</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.oauth_access" href="#slack_sdk.web.legacy_client.LegacyWebClient.oauth_access">oauth_access</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.oauth_v2_access" href="#slack_sdk.web.legacy_client.LegacyWebClient.oauth_v2_access">oauth_v2_access</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.oauth_v2_exchange" href="#slack_sdk.web.legacy_client.LegacyWebClient.oauth_v2_exchange">oauth_v2_exchange</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.openid_connect_token" href="#slack_sdk.web.legacy_client.LegacyWebClient.openid_connect_token">openid_connect_token</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.openid_connect_userInfo" href="#slack_sdk.web.legacy_client.LegacyWebClient.openid_connect_userInfo">openid_connect_userInfo</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.pins_add" href="#slack_sdk.web.legacy_client.LegacyWebClient.pins_add">pins_add</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.pins_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.pins_list">pins_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.pins_remove" href="#slack_sdk.web.legacy_client.LegacyWebClient.pins_remove">pins_remove</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.reactions_add" href="#slack_sdk.web.legacy_client.LegacyWebClient.reactions_add">reactions_add</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.reactions_get" href="#slack_sdk.web.legacy_client.LegacyWebClient.reactions_get">reactions_get</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.reactions_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.reactions_list">reactions_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.reactions_remove" href="#slack_sdk.web.legacy_client.LegacyWebClient.reactions_remove">reactions_remove</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.reminders_add" href="#slack_sdk.web.legacy_client.LegacyWebClient.reminders_add">reminders_add</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.reminders_complete" href="#slack_sdk.web.legacy_client.LegacyWebClient.reminders_complete">reminders_complete</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.reminders_delete" href="#slack_sdk.web.legacy_client.LegacyWebClient.reminders_delete">reminders_delete</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.reminders_info" href="#slack_sdk.web.legacy_client.LegacyWebClient.reminders_info">reminders_info</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.reminders_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.reminders_list">reminders_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.rtm_connect" href="#slack_sdk.web.legacy_client.LegacyWebClient.rtm_connect">rtm_connect</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.rtm_start" href="#slack_sdk.web.legacy_client.LegacyWebClient.rtm_start">rtm_start</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.search_all" href="#slack_sdk.web.legacy_client.LegacyWebClient.search_all">search_all</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.search_files" href="#slack_sdk.web.legacy_client.LegacyWebClient.search_files">search_files</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.search_messages" href="#slack_sdk.web.legacy_client.LegacyWebClient.search_messages">search_messages</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.stars_add" href="#slack_sdk.web.legacy_client.LegacyWebClient.stars_add">stars_add</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.stars_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.stars_list">stars_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.stars_remove" href="#slack_sdk.web.legacy_client.LegacyWebClient.stars_remove">stars_remove</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.team_accessLogs" href="#slack_sdk.web.legacy_client.LegacyWebClient.team_accessLogs">team_accessLogs</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.team_billableInfo" href="#slack_sdk.web.legacy_client.LegacyWebClient.team_billableInfo">team_billableInfo</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.team_billing_info" href="#slack_sdk.web.legacy_client.LegacyWebClient.team_billing_info">team_billing_info</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.team_info" href="#slack_sdk.web.legacy_client.LegacyWebClient.team_info">team_info</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.team_integrationLogs" href="#slack_sdk.web.legacy_client.LegacyWebClient.team_integrationLogs">team_integrationLogs</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.team_preferences_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.team_preferences_list">team_preferences_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.team_profile_get" href="#slack_sdk.web.legacy_client.LegacyWebClient.team_profile_get">team_profile_get</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.tooling_tokens_rotate" href="#slack_sdk.web.legacy_client.LegacyWebClient.tooling_tokens_rotate">tooling_tokens_rotate</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.usergroups_create" href="#slack_sdk.web.legacy_client.LegacyWebClient.usergroups_create">usergroups_create</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.usergroups_disable" href="#slack_sdk.web.legacy_client.LegacyWebClient.usergroups_disable">usergroups_disable</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.usergroups_enable" href="#slack_sdk.web.legacy_client.LegacyWebClient.usergroups_enable">usergroups_enable</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.usergroups_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.usergroups_list">usergroups_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.usergroups_update" href="#slack_sdk.web.legacy_client.LegacyWebClient.usergroups_update">usergroups_update</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.usergroups_users_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.usergroups_users_list">usergroups_users_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.usergroups_users_update" href="#slack_sdk.web.legacy_client.LegacyWebClient.usergroups_users_update">usergroups_users_update</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.users_conversations" href="#slack_sdk.web.legacy_client.LegacyWebClient.users_conversations">users_conversations</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.users_deletePhoto" href="#slack_sdk.web.legacy_client.LegacyWebClient.users_deletePhoto">users_deletePhoto</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.users_getPresence" href="#slack_sdk.web.legacy_client.LegacyWebClient.users_getPresence">users_getPresence</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.users_identity" href="#slack_sdk.web.legacy_client.LegacyWebClient.users_identity">users_identity</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.users_info" href="#slack_sdk.web.legacy_client.LegacyWebClient.users_info">users_info</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.users_list" href="#slack_sdk.web.legacy_client.LegacyWebClient.users_list">users_list</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.users_lookupByEmail" href="#slack_sdk.web.legacy_client.LegacyWebClient.users_lookupByEmail">users_lookupByEmail</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.users_profile_get" href="#slack_sdk.web.legacy_client.LegacyWebClient.users_profile_get">users_profile_get</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.users_profile_set" href="#slack_sdk.web.legacy_client.LegacyWebClient.users_profile_set">users_profile_set</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.users_setPhoto" href="#slack_sdk.web.legacy_client.LegacyWebClient.users_setPhoto">users_setPhoto</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.users_setPresence" href="#slack_sdk.web.legacy_client.LegacyWebClient.users_setPresence">users_setPresence</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.views_open" href="#slack_sdk.web.legacy_client.LegacyWebClient.views_open">views_open</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.views_publish" href="#slack_sdk.web.legacy_client.LegacyWebClient.views_publish">views_publish</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.views_push" href="#slack_sdk.web.legacy_client.LegacyWebClient.views_push">views_push</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.views_update" href="#slack_sdk.web.legacy_client.LegacyWebClient.views_update">views_update</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.workflows_stepCompleted" href="#slack_sdk.web.legacy_client.LegacyWebClient.workflows_stepCompleted">workflows_stepCompleted</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.workflows_stepFailed" href="#slack_sdk.web.legacy_client.LegacyWebClient.workflows_stepFailed">workflows_stepFailed</a></code></li>
<li><code><a title="slack_sdk.web.legacy_client.LegacyWebClient.workflows_updateStep" href="#slack_sdk.web.legacy_client.LegacyWebClient.workflows_updateStep">workflows_updateStep</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>