<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>slack_sdk.scim.v1.client API documentation</title>
<meta name="description" content="SCIM API is a set of APIs for provisioning and managing user accounts and groups.
SCIM is used by Single Sign-On (SSO) services and identity providers …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>slack_sdk.scim.v1.client</code></h1>
</header>
<section id="section-intro">
<p>SCIM API is a set of APIs for provisioning and managing user accounts and groups.
SCIM is used by Single Sign-On (SSO) services and identity providers to manage people across a variety of tools,
including Slack.</p>
<p>Refer to <a href="https://slack.dev/python-slack-sdk/scim/">https://slack.dev/python-slack-sdk/scim/</a> for details.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;SCIM API is a set of APIs for provisioning and managing user accounts and groups.
SCIM is used by Single Sign-On (SSO) services and identity providers to manage people across a variety of tools,
including Slack.

Refer to https://slack.dev/python-slack-sdk/scim/ for details.
&#34;&#34;&#34;
import json
import logging
import urllib
from http.client import HTTPResponse
from ssl import SSLContext
from typing import Dict, Optional, Union, Any, List
from urllib.error import HTTPError
from urllib.parse import quote
from urllib.request import Request, urlopen, OpenerDirector, ProxyHandler, HTTPSHandler

from slack_sdk.errors import SlackRequestError
from .internal_utils import (
    _build_query,
    _build_request_headers,
    _debug_log_response,
    get_user_agent,
    _to_dict_without_not_given,
)
from .response import (
    SCIMResponse,
    SearchUsersResponse,
    ReadUserResponse,
    SearchGroupsResponse,
    ReadGroupResponse,
    UserCreateResponse,
    UserPatchResponse,
    UserUpdateResponse,
    UserDeleteResponse,
    GroupCreateResponse,
    GroupPatchResponse,
    GroupUpdateResponse,
    GroupDeleteResponse,
)
from .user import User
from .group import Group

from slack_sdk.http_retry import default_retry_handlers
from slack_sdk.http_retry.handler import RetryHandler
from slack_sdk.http_retry.request import HttpRequest as RetryHttpRequest
from slack_sdk.http_retry.response import HttpResponse as RetryHttpResponse
from slack_sdk.http_retry.state import RetryState

from ...proxy_env_variable_loader import load_http_proxy_from_env


class SCIMClient:
    BASE_URL = &#34;https://api.slack.com/scim/v1/&#34;

    token: str
    timeout: int
    ssl: Optional[SSLContext]
    proxy: Optional[str]
    base_url: str
    default_headers: Dict[str, str]
    logger: logging.Logger
    retry_handlers: List[RetryHandler]

    def __init__(
        self,
        token: str,
        timeout: int = 30,
        ssl: Optional[SSLContext] = None,
        proxy: Optional[str] = None,
        base_url: str = BASE_URL,
        default_headers: Optional[Dict[str, str]] = None,
        user_agent_prefix: Optional[str] = None,
        user_agent_suffix: Optional[str] = None,
        logger: Optional[logging.Logger] = None,
        retry_handlers: Optional[List[RetryHandler]] = None,
    ):
        &#34;&#34;&#34;API client for SCIM API
        See https://api.slack.com/scim for more details

        Args:
            token: An admin user&#39;s token, which starts with `xoxp-`
            timeout: Request timeout (in seconds)
            ssl: `ssl.SSLContext` to use for requests
            proxy: Proxy URL (e.g., `localhost:9000`, `http://localhost:9000`)
            base_url: The base URL for API calls
            default_headers: Request headers to add to all requests
            user_agent_prefix: Prefix for User-Agent header value
            user_agent_suffix: Suffix for User-Agent header value
            logger: Custom logger
            retry_handlers: Retry handlers
        &#34;&#34;&#34;
        self.token = token
        self.timeout = timeout
        self.ssl = ssl
        self.proxy = proxy
        self.base_url = base_url
        self.default_headers = default_headers if default_headers else {}
        self.default_headers[&#34;User-Agent&#34;] = get_user_agent(user_agent_prefix, user_agent_suffix)
        self.logger = logger if logger is not None else logging.getLogger(__name__)
        self.retry_handlers = retry_handlers if retry_handlers is not None else default_retry_handlers()

        if self.proxy is None or len(self.proxy.strip()) == 0:
            env_variable = load_http_proxy_from_env(self.logger)
            if env_variable is not None:
                self.proxy = env_variable

    # -------------------------
    # Users
    # -------------------------

    def search_users(
        self,
        *,
        # Pagination required as of August 30, 2019.
        count: int,
        start_index: int,
        filter: Optional[str] = None,
    ) -&gt; SearchUsersResponse:
        return SearchUsersResponse(
            self.api_call(
                http_verb=&#34;GET&#34;,
                path=&#34;Users&#34;,
                query_params={
                    &#34;filter&#34;: filter,
                    &#34;count&#34;: count,
                    &#34;startIndex&#34;: start_index,
                },
            )
        )

    def read_user(self, id: str) -&gt; ReadUserResponse:
        return ReadUserResponse(self.api_call(http_verb=&#34;GET&#34;, path=f&#34;Users/{quote(id)}&#34;))

    def create_user(self, user: Union[Dict[str, Any], User]) -&gt; UserCreateResponse:
        return UserCreateResponse(
            self.api_call(
                http_verb=&#34;POST&#34;,
                path=&#34;Users&#34;,
                body_params=user.to_dict() if isinstance(user, User) else _to_dict_without_not_given(user),
            )
        )

    def patch_user(self, id: str, partial_user: Union[Dict[str, Any], User]) -&gt; UserPatchResponse:
        return UserPatchResponse(
            self.api_call(
                http_verb=&#34;PATCH&#34;,
                path=f&#34;Users/{quote(id)}&#34;,
                body_params=partial_user.to_dict()
                if isinstance(partial_user, User)
                else _to_dict_without_not_given(partial_user),
            )
        )

    def update_user(self, user: Union[Dict[str, Any], User]) -&gt; UserUpdateResponse:
        user_id = user.id if isinstance(user, User) else user[&#34;id&#34;]
        return UserUpdateResponse(
            self.api_call(
                http_verb=&#34;PUT&#34;,
                path=f&#34;Users/{quote(user_id)}&#34;,
                body_params=user.to_dict() if isinstance(user, User) else _to_dict_without_not_given(user),
            )
        )

    def delete_user(self, id: str) -&gt; UserDeleteResponse:
        return UserDeleteResponse(
            self.api_call(
                http_verb=&#34;DELETE&#34;,
                path=f&#34;Users/{quote(id)}&#34;,
            )
        )

    # -------------------------
    # Groups
    # -------------------------

    def search_groups(
        self,
        *,
        # Pagination required as of August 30, 2019.
        count: int,
        start_index: int,
        filter: Optional[str] = None,
    ) -&gt; SearchGroupsResponse:
        return SearchGroupsResponse(
            self.api_call(
                http_verb=&#34;GET&#34;,
                path=&#34;Groups&#34;,
                query_params={
                    &#34;filter&#34;: filter,
                    &#34;count&#34;: count,
                    &#34;startIndex&#34;: start_index,
                },
            )
        )

    def read_group(self, id: str) -&gt; ReadGroupResponse:
        return ReadGroupResponse(self.api_call(http_verb=&#34;GET&#34;, path=f&#34;Groups/{quote(id)}&#34;))

    def create_group(self, group: Union[Dict[str, Any], Group]) -&gt; GroupCreateResponse:
        return GroupCreateResponse(
            self.api_call(
                http_verb=&#34;POST&#34;,
                path=&#34;Groups&#34;,
                body_params=group.to_dict() if isinstance(group, Group) else _to_dict_without_not_given(group),
            )
        )

    def patch_group(self, id: str, partial_group: Union[Dict[str, Any], Group]) -&gt; GroupPatchResponse:
        return GroupPatchResponse(
            self.api_call(
                http_verb=&#34;PATCH&#34;,
                path=f&#34;Groups/{quote(id)}&#34;,
                body_params=partial_group.to_dict()
                if isinstance(partial_group, Group)
                else _to_dict_without_not_given(partial_group),
            )
        )

    def update_group(self, group: Union[Dict[str, Any], Group]) -&gt; GroupUpdateResponse:
        group_id = group.id if isinstance(group, Group) else group[&#34;id&#34;]
        return GroupUpdateResponse(
            self.api_call(
                http_verb=&#34;PUT&#34;,
                path=f&#34;Groups/{quote(group_id)}&#34;,
                body_params=group.to_dict() if isinstance(group, Group) else _to_dict_without_not_given(group),
            )
        )

    def delete_group(self, id: str) -&gt; GroupDeleteResponse:
        return GroupDeleteResponse(
            self.api_call(
                http_verb=&#34;DELETE&#34;,
                path=f&#34;Groups/{quote(id)}&#34;,
            )
        )

    # -------------------------

    def api_call(
        self,
        *,
        http_verb: str,
        path: str,
        query_params: Optional[Dict[str, Any]] = None,
        body_params: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
    ) -&gt; SCIMResponse:
        &#34;&#34;&#34;Performs a Slack API request and returns the result.&#34;&#34;&#34;
        url = f&#34;{self.base_url}{path}&#34;
        query = _build_query(query_params)
        if len(query) &gt; 0:
            url += f&#34;?{query}&#34;

        return self._perform_http_request(
            http_verb=http_verb,
            url=url,
            body=body_params,
            headers=_build_request_headers(
                token=self.token,
                default_headers=self.default_headers,
                additional_headers=headers,
            ),
        )

    def _perform_http_request(
        self,
        *,
        http_verb: str = &#34;GET&#34;,
        url: str,
        body: Optional[Dict[str, Any]] = None,
        headers: Dict[str, str],
    ) -&gt; SCIMResponse:
        if body is not None:
            if body.get(&#34;schemas&#34;) is None:
                body[&#34;schemas&#34;] = [&#34;urn:scim:schemas:core:1.0&#34;]
            body = json.dumps(body)
        headers[&#34;Content-Type&#34;] = &#34;application/json;charset=utf-8&#34;

        if self.logger.level &lt;= logging.DEBUG:
            headers_for_logging = {k: &#34;(redacted)&#34; if k.lower() == &#34;authorization&#34; else v for k, v in headers.items()}
            self.logger.debug(f&#34;Sending a request - {http_verb} url: {url}, body: {body}, headers: {headers_for_logging}&#34;)

        # NOTE: Intentionally ignore the `http_verb` here
        # Slack APIs accepts any API method requests with POST methods
        req = Request(
            method=http_verb,
            url=url,
            data=body.encode(&#34;utf-8&#34;) if body is not None else None,
            headers=headers,
        )
        resp = None
        last_error = None

        retry_state = RetryState()
        counter_for_safety = 0
        while counter_for_safety &lt; 100:
            counter_for_safety += 1
            # If this is a retry, the next try started here. We can reset the flag.
            retry_state.next_attempt_requested = False

            try:
                resp = self._perform_http_request_internal(url, req)
                # The resp is a 200 OK response
                return resp

            except HTTPError as e:
                # read the response body here
                charset = e.headers.get_content_charset() or &#34;utf-8&#34;
                response_body: str = e.read().decode(charset)
                # As adding new values to HTTPError#headers can be ignored, building a new dict object here
                response_headers = dict(e.headers.items())
                resp = SCIMResponse(
                    url=url,
                    status_code=e.code,
                    raw_body=response_body,
                    headers=response_headers,
                )
                if e.code == 429:
                    # for backward-compatibility with WebClient (v.2.5.0 or older)
                    if &#34;retry-after&#34; not in resp.headers and &#34;Retry-After&#34; in resp.headers:
                        resp.headers[&#34;retry-after&#34;] = resp.headers[&#34;Retry-After&#34;]
                    if &#34;Retry-After&#34; not in resp.headers and &#34;retry-after&#34; in resp.headers:
                        resp.headers[&#34;Retry-After&#34;] = resp.headers[&#34;retry-after&#34;]
                _debug_log_response(self.logger, resp)

                # Try to find a retry handler for this error
                retry_request = RetryHttpRequest.from_urllib_http_request(req)
                retry_response = RetryHttpResponse(
                    status_code=e.code,
                    headers={k: [v] for k, v in e.headers.items()},
                    data=response_body.encode(&#34;utf-8&#34;) if response_body is not None else None,
                )
                for handler in self.retry_handlers:
                    if handler.can_retry(
                        state=retry_state,
                        request=retry_request,
                        response=retry_response,
                        error=e,
                    ):
                        if self.logger.level &lt;= logging.DEBUG:
                            self.logger.info(
                                f&#34;A retry handler found: {type(handler).__name__} for {req.method} {req.full_url} - {e}&#34;
                            )
                        handler.prepare_for_next_attempt(
                            state=retry_state,
                            request=retry_request,
                            response=retry_response,
                            error=e,
                        )
                        break

                if retry_state.next_attempt_requested is False:
                    return resp

            except Exception as err:
                last_error = err
                self.logger.error(f&#34;Failed to send a request to Slack API server: {err}&#34;)

                # Try to find a retry handler for this error
                retry_request = RetryHttpRequest.from_urllib_http_request(req)
                for handler in self.retry_handlers:
                    if handler.can_retry(
                        state=retry_state,
                        request=retry_request,
                        response=None,
                        error=err,
                    ):
                        if self.logger.level &lt;= logging.DEBUG:
                            self.logger.info(
                                f&#34;A retry handler found: {type(handler).__name__} for {req.method} {req.full_url} - {err}&#34;
                            )
                        handler.prepare_for_next_attempt(
                            state=retry_state,
                            request=retry_request,
                            response=None,
                            error=err,
                        )
                        self.logger.info(f&#34;Going to retry the same request: {req.method} {req.full_url}&#34;)
                        break

                if retry_state.next_attempt_requested is False:
                    raise err

        if resp is not None:
            return resp
        raise last_error

    def _perform_http_request_internal(self, url: str, req: Request) -&gt; SCIMResponse:
        opener: Optional[OpenerDirector] = None
        # for security (BAN-B310)
        if url.lower().startswith(&#34;http&#34;):
            if self.proxy is not None:
                if isinstance(self.proxy, str):
                    opener = urllib.request.build_opener(
                        ProxyHandler({&#34;http&#34;: self.proxy, &#34;https&#34;: self.proxy}),
                        HTTPSHandler(context=self.ssl),
                    )
                else:
                    raise SlackRequestError(f&#34;Invalid proxy detected: {self.proxy} must be a str value&#34;)
        else:
            raise SlackRequestError(f&#34;Invalid URL detected: {url}&#34;)

        # NOTE: BAN-B310 is already checked above
        http_resp: Optional[HTTPResponse] = None
        if opener:
            http_resp = opener.open(req, timeout=self.timeout)  # skipcq: BAN-B310
        else:
            http_resp = urlopen(req, context=self.ssl, timeout=self.timeout)  # skipcq: BAN-B310
        charset: str = http_resp.headers.get_content_charset() or &#34;utf-8&#34;
        response_body: str = http_resp.read().decode(charset)
        resp = SCIMResponse(
            url=url,
            status_code=http_resp.status,
            raw_body=response_body,
            headers=http_resp.headers,
        )
        _debug_log_response(self.logger, resp)
        return resp</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="slack_sdk.scim.v1.client.SCIMClient"><code class="flex name class">
<span>class <span class="ident">SCIMClient</span></span>
<span>(</span><span>token: str, timeout: int = 30, ssl: Optional[ssl.SSLContext] = None, proxy: Optional[str] = None, base_url: str = 'https://api.slack.com/scim/v1/', default_headers: Optional[Dict[str, str]] = None, user_agent_prefix: Optional[str] = None, user_agent_suffix: Optional[str] = None, logger: Optional[logging.Logger] = None, retry_handlers: Optional[List[<a title="slack_sdk.http_retry.handler.RetryHandler" href="../../http_retry/handler.html#slack_sdk.http_retry.handler.RetryHandler">RetryHandler</a>]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>API client for SCIM API
See <a href="https://api.slack.com/scim">https://api.slack.com/scim</a> for more details</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>token</code></strong></dt>
<dd>An admin user's token, which starts with <code>xoxp-</code></dd>
<dt><strong><code>timeout</code></strong></dt>
<dd>Request timeout (in seconds)</dd>
<dt><strong><code>ssl</code></strong></dt>
<dd><code>ssl.SSLContext</code> to use for requests</dd>
<dt><strong><code>proxy</code></strong></dt>
<dd>Proxy URL (e.g., <code>localhost:9000</code>, <code>http://localhost:9000</code>)</dd>
<dt><strong><code>base_url</code></strong></dt>
<dd>The base URL for API calls</dd>
<dt><strong><code>default_headers</code></strong></dt>
<dd>Request headers to add to all requests</dd>
<dt><strong><code>user_agent_prefix</code></strong></dt>
<dd>Prefix for User-Agent header value</dd>
<dt><strong><code>user_agent_suffix</code></strong></dt>
<dd>Suffix for User-Agent header value</dd>
<dt><strong><code>logger</code></strong></dt>
<dd>Custom logger</dd>
<dt><strong><code>retry_handlers</code></strong></dt>
<dd>Retry handlers</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SCIMClient:
    BASE_URL = &#34;https://api.slack.com/scim/v1/&#34;

    token: str
    timeout: int
    ssl: Optional[SSLContext]
    proxy: Optional[str]
    base_url: str
    default_headers: Dict[str, str]
    logger: logging.Logger
    retry_handlers: List[RetryHandler]

    def __init__(
        self,
        token: str,
        timeout: int = 30,
        ssl: Optional[SSLContext] = None,
        proxy: Optional[str] = None,
        base_url: str = BASE_URL,
        default_headers: Optional[Dict[str, str]] = None,
        user_agent_prefix: Optional[str] = None,
        user_agent_suffix: Optional[str] = None,
        logger: Optional[logging.Logger] = None,
        retry_handlers: Optional[List[RetryHandler]] = None,
    ):
        &#34;&#34;&#34;API client for SCIM API
        See https://api.slack.com/scim for more details

        Args:
            token: An admin user&#39;s token, which starts with `xoxp-`
            timeout: Request timeout (in seconds)
            ssl: `ssl.SSLContext` to use for requests
            proxy: Proxy URL (e.g., `localhost:9000`, `http://localhost:9000`)
            base_url: The base URL for API calls
            default_headers: Request headers to add to all requests
            user_agent_prefix: Prefix for User-Agent header value
            user_agent_suffix: Suffix for User-Agent header value
            logger: Custom logger
            retry_handlers: Retry handlers
        &#34;&#34;&#34;
        self.token = token
        self.timeout = timeout
        self.ssl = ssl
        self.proxy = proxy
        self.base_url = base_url
        self.default_headers = default_headers if default_headers else {}
        self.default_headers[&#34;User-Agent&#34;] = get_user_agent(user_agent_prefix, user_agent_suffix)
        self.logger = logger if logger is not None else logging.getLogger(__name__)
        self.retry_handlers = retry_handlers if retry_handlers is not None else default_retry_handlers()

        if self.proxy is None or len(self.proxy.strip()) == 0:
            env_variable = load_http_proxy_from_env(self.logger)
            if env_variable is not None:
                self.proxy = env_variable

    # -------------------------
    # Users
    # -------------------------

    def search_users(
        self,
        *,
        # Pagination required as of August 30, 2019.
        count: int,
        start_index: int,
        filter: Optional[str] = None,
    ) -&gt; SearchUsersResponse:
        return SearchUsersResponse(
            self.api_call(
                http_verb=&#34;GET&#34;,
                path=&#34;Users&#34;,
                query_params={
                    &#34;filter&#34;: filter,
                    &#34;count&#34;: count,
                    &#34;startIndex&#34;: start_index,
                },
            )
        )

    def read_user(self, id: str) -&gt; ReadUserResponse:
        return ReadUserResponse(self.api_call(http_verb=&#34;GET&#34;, path=f&#34;Users/{quote(id)}&#34;))

    def create_user(self, user: Union[Dict[str, Any], User]) -&gt; UserCreateResponse:
        return UserCreateResponse(
            self.api_call(
                http_verb=&#34;POST&#34;,
                path=&#34;Users&#34;,
                body_params=user.to_dict() if isinstance(user, User) else _to_dict_without_not_given(user),
            )
        )

    def patch_user(self, id: str, partial_user: Union[Dict[str, Any], User]) -&gt; UserPatchResponse:
        return UserPatchResponse(
            self.api_call(
                http_verb=&#34;PATCH&#34;,
                path=f&#34;Users/{quote(id)}&#34;,
                body_params=partial_user.to_dict()
                if isinstance(partial_user, User)
                else _to_dict_without_not_given(partial_user),
            )
        )

    def update_user(self, user: Union[Dict[str, Any], User]) -&gt; UserUpdateResponse:
        user_id = user.id if isinstance(user, User) else user[&#34;id&#34;]
        return UserUpdateResponse(
            self.api_call(
                http_verb=&#34;PUT&#34;,
                path=f&#34;Users/{quote(user_id)}&#34;,
                body_params=user.to_dict() if isinstance(user, User) else _to_dict_without_not_given(user),
            )
        )

    def delete_user(self, id: str) -&gt; UserDeleteResponse:
        return UserDeleteResponse(
            self.api_call(
                http_verb=&#34;DELETE&#34;,
                path=f&#34;Users/{quote(id)}&#34;,
            )
        )

    # -------------------------
    # Groups
    # -------------------------

    def search_groups(
        self,
        *,
        # Pagination required as of August 30, 2019.
        count: int,
        start_index: int,
        filter: Optional[str] = None,
    ) -&gt; SearchGroupsResponse:
        return SearchGroupsResponse(
            self.api_call(
                http_verb=&#34;GET&#34;,
                path=&#34;Groups&#34;,
                query_params={
                    &#34;filter&#34;: filter,
                    &#34;count&#34;: count,
                    &#34;startIndex&#34;: start_index,
                },
            )
        )

    def read_group(self, id: str) -&gt; ReadGroupResponse:
        return ReadGroupResponse(self.api_call(http_verb=&#34;GET&#34;, path=f&#34;Groups/{quote(id)}&#34;))

    def create_group(self, group: Union[Dict[str, Any], Group]) -&gt; GroupCreateResponse:
        return GroupCreateResponse(
            self.api_call(
                http_verb=&#34;POST&#34;,
                path=&#34;Groups&#34;,
                body_params=group.to_dict() if isinstance(group, Group) else _to_dict_without_not_given(group),
            )
        )

    def patch_group(self, id: str, partial_group: Union[Dict[str, Any], Group]) -&gt; GroupPatchResponse:
        return GroupPatchResponse(
            self.api_call(
                http_verb=&#34;PATCH&#34;,
                path=f&#34;Groups/{quote(id)}&#34;,
                body_params=partial_group.to_dict()
                if isinstance(partial_group, Group)
                else _to_dict_without_not_given(partial_group),
            )
        )

    def update_group(self, group: Union[Dict[str, Any], Group]) -&gt; GroupUpdateResponse:
        group_id = group.id if isinstance(group, Group) else group[&#34;id&#34;]
        return GroupUpdateResponse(
            self.api_call(
                http_verb=&#34;PUT&#34;,
                path=f&#34;Groups/{quote(group_id)}&#34;,
                body_params=group.to_dict() if isinstance(group, Group) else _to_dict_without_not_given(group),
            )
        )

    def delete_group(self, id: str) -&gt; GroupDeleteResponse:
        return GroupDeleteResponse(
            self.api_call(
                http_verb=&#34;DELETE&#34;,
                path=f&#34;Groups/{quote(id)}&#34;,
            )
        )

    # -------------------------

    def api_call(
        self,
        *,
        http_verb: str,
        path: str,
        query_params: Optional[Dict[str, Any]] = None,
        body_params: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
    ) -&gt; SCIMResponse:
        &#34;&#34;&#34;Performs a Slack API request and returns the result.&#34;&#34;&#34;
        url = f&#34;{self.base_url}{path}&#34;
        query = _build_query(query_params)
        if len(query) &gt; 0:
            url += f&#34;?{query}&#34;

        return self._perform_http_request(
            http_verb=http_verb,
            url=url,
            body=body_params,
            headers=_build_request_headers(
                token=self.token,
                default_headers=self.default_headers,
                additional_headers=headers,
            ),
        )

    def _perform_http_request(
        self,
        *,
        http_verb: str = &#34;GET&#34;,
        url: str,
        body: Optional[Dict[str, Any]] = None,
        headers: Dict[str, str],
    ) -&gt; SCIMResponse:
        if body is not None:
            if body.get(&#34;schemas&#34;) is None:
                body[&#34;schemas&#34;] = [&#34;urn:scim:schemas:core:1.0&#34;]
            body = json.dumps(body)
        headers[&#34;Content-Type&#34;] = &#34;application/json;charset=utf-8&#34;

        if self.logger.level &lt;= logging.DEBUG:
            headers_for_logging = {k: &#34;(redacted)&#34; if k.lower() == &#34;authorization&#34; else v for k, v in headers.items()}
            self.logger.debug(f&#34;Sending a request - {http_verb} url: {url}, body: {body}, headers: {headers_for_logging}&#34;)

        # NOTE: Intentionally ignore the `http_verb` here
        # Slack APIs accepts any API method requests with POST methods
        req = Request(
            method=http_verb,
            url=url,
            data=body.encode(&#34;utf-8&#34;) if body is not None else None,
            headers=headers,
        )
        resp = None
        last_error = None

        retry_state = RetryState()
        counter_for_safety = 0
        while counter_for_safety &lt; 100:
            counter_for_safety += 1
            # If this is a retry, the next try started here. We can reset the flag.
            retry_state.next_attempt_requested = False

            try:
                resp = self._perform_http_request_internal(url, req)
                # The resp is a 200 OK response
                return resp

            except HTTPError as e:
                # read the response body here
                charset = e.headers.get_content_charset() or &#34;utf-8&#34;
                response_body: str = e.read().decode(charset)
                # As adding new values to HTTPError#headers can be ignored, building a new dict object here
                response_headers = dict(e.headers.items())
                resp = SCIMResponse(
                    url=url,
                    status_code=e.code,
                    raw_body=response_body,
                    headers=response_headers,
                )
                if e.code == 429:
                    # for backward-compatibility with WebClient (v.2.5.0 or older)
                    if &#34;retry-after&#34; not in resp.headers and &#34;Retry-After&#34; in resp.headers:
                        resp.headers[&#34;retry-after&#34;] = resp.headers[&#34;Retry-After&#34;]
                    if &#34;Retry-After&#34; not in resp.headers and &#34;retry-after&#34; in resp.headers:
                        resp.headers[&#34;Retry-After&#34;] = resp.headers[&#34;retry-after&#34;]
                _debug_log_response(self.logger, resp)

                # Try to find a retry handler for this error
                retry_request = RetryHttpRequest.from_urllib_http_request(req)
                retry_response = RetryHttpResponse(
                    status_code=e.code,
                    headers={k: [v] for k, v in e.headers.items()},
                    data=response_body.encode(&#34;utf-8&#34;) if response_body is not None else None,
                )
                for handler in self.retry_handlers:
                    if handler.can_retry(
                        state=retry_state,
                        request=retry_request,
                        response=retry_response,
                        error=e,
                    ):
                        if self.logger.level &lt;= logging.DEBUG:
                            self.logger.info(
                                f&#34;A retry handler found: {type(handler).__name__} for {req.method} {req.full_url} - {e}&#34;
                            )
                        handler.prepare_for_next_attempt(
                            state=retry_state,
                            request=retry_request,
                            response=retry_response,
                            error=e,
                        )
                        break

                if retry_state.next_attempt_requested is False:
                    return resp

            except Exception as err:
                last_error = err
                self.logger.error(f&#34;Failed to send a request to Slack API server: {err}&#34;)

                # Try to find a retry handler for this error
                retry_request = RetryHttpRequest.from_urllib_http_request(req)
                for handler in self.retry_handlers:
                    if handler.can_retry(
                        state=retry_state,
                        request=retry_request,
                        response=None,
                        error=err,
                    ):
                        if self.logger.level &lt;= logging.DEBUG:
                            self.logger.info(
                                f&#34;A retry handler found: {type(handler).__name__} for {req.method} {req.full_url} - {err}&#34;
                            )
                        handler.prepare_for_next_attempt(
                            state=retry_state,
                            request=retry_request,
                            response=None,
                            error=err,
                        )
                        self.logger.info(f&#34;Going to retry the same request: {req.method} {req.full_url}&#34;)
                        break

                if retry_state.next_attempt_requested is False:
                    raise err

        if resp is not None:
            return resp
        raise last_error

    def _perform_http_request_internal(self, url: str, req: Request) -&gt; SCIMResponse:
        opener: Optional[OpenerDirector] = None
        # for security (BAN-B310)
        if url.lower().startswith(&#34;http&#34;):
            if self.proxy is not None:
                if isinstance(self.proxy, str):
                    opener = urllib.request.build_opener(
                        ProxyHandler({&#34;http&#34;: self.proxy, &#34;https&#34;: self.proxy}),
                        HTTPSHandler(context=self.ssl),
                    )
                else:
                    raise SlackRequestError(f&#34;Invalid proxy detected: {self.proxy} must be a str value&#34;)
        else:
            raise SlackRequestError(f&#34;Invalid URL detected: {url}&#34;)

        # NOTE: BAN-B310 is already checked above
        http_resp: Optional[HTTPResponse] = None
        if opener:
            http_resp = opener.open(req, timeout=self.timeout)  # skipcq: BAN-B310
        else:
            http_resp = urlopen(req, context=self.ssl, timeout=self.timeout)  # skipcq: BAN-B310
        charset: str = http_resp.headers.get_content_charset() or &#34;utf-8&#34;
        response_body: str = http_resp.read().decode(charset)
        resp = SCIMResponse(
            url=url,
            status_code=http_resp.status,
            raw_body=response_body,
            headers=http_resp.headers,
        )
        _debug_log_response(self.logger, resp)
        return resp</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="slack_sdk.scim.v1.client.SCIMClient.BASE_URL"><code class="name">var <span class="ident">BASE_URL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.scim.v1.client.SCIMClient.base_url"><code class="name">var <span class="ident">base_url</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.scim.v1.client.SCIMClient.default_headers"><code class="name">var <span class="ident">default_headers</span> : Dict[str, str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.scim.v1.client.SCIMClient.logger"><code class="name">var <span class="ident">logger</span> : logging.Logger</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.scim.v1.client.SCIMClient.proxy"><code class="name">var <span class="ident">proxy</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.scim.v1.client.SCIMClient.retry_handlers"><code class="name">var <span class="ident">retry_handlers</span> : List[<a title="slack_sdk.http_retry.handler.RetryHandler" href="../../http_retry/handler.html#slack_sdk.http_retry.handler.RetryHandler">RetryHandler</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.scim.v1.client.SCIMClient.ssl"><code class="name">var <span class="ident">ssl</span> : Optional[ssl.SSLContext]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.scim.v1.client.SCIMClient.timeout"><code class="name">var <span class="ident">timeout</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.scim.v1.client.SCIMClient.token"><code class="name">var <span class="ident">token</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="slack_sdk.scim.v1.client.SCIMClient.api_call"><code class="name flex">
<span>def <span class="ident">api_call</span></span>(<span>self, *, http_verb: str, path: str, query_params: Optional[Dict[str, Any]] = None, body_params: Optional[Dict[str, Any]] = None, headers: Optional[Dict[str, str]] = None) ‑> <a title="slack_sdk.scim.v1.response.SCIMResponse" href="response.html#slack_sdk.scim.v1.response.SCIMResponse">SCIMResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Performs a Slack API request and returns the result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def api_call(
    self,
    *,
    http_verb: str,
    path: str,
    query_params: Optional[Dict[str, Any]] = None,
    body_params: Optional[Dict[str, Any]] = None,
    headers: Optional[Dict[str, str]] = None,
) -&gt; SCIMResponse:
    &#34;&#34;&#34;Performs a Slack API request and returns the result.&#34;&#34;&#34;
    url = f&#34;{self.base_url}{path}&#34;
    query = _build_query(query_params)
    if len(query) &gt; 0:
        url += f&#34;?{query}&#34;

    return self._perform_http_request(
        http_verb=http_verb,
        url=url,
        body=body_params,
        headers=_build_request_headers(
            token=self.token,
            default_headers=self.default_headers,
            additional_headers=headers,
        ),
    )</code></pre>
</details>
</dd>
<dt id="slack_sdk.scim.v1.client.SCIMClient.create_group"><code class="name flex">
<span>def <span class="ident">create_group</span></span>(<span>self, group: Union[Dict[str, Any], <a title="slack_sdk.scim.v1.group.Group" href="group.html#slack_sdk.scim.v1.group.Group">Group</a>]) ‑> <a title="slack_sdk.scim.v1.response.GroupCreateResponse" href="response.html#slack_sdk.scim.v1.response.GroupCreateResponse">GroupCreateResponse</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_group(self, group: Union[Dict[str, Any], Group]) -&gt; GroupCreateResponse:
    return GroupCreateResponse(
        self.api_call(
            http_verb=&#34;POST&#34;,
            path=&#34;Groups&#34;,
            body_params=group.to_dict() if isinstance(group, Group) else _to_dict_without_not_given(group),
        )
    )</code></pre>
</details>
</dd>
<dt id="slack_sdk.scim.v1.client.SCIMClient.create_user"><code class="name flex">
<span>def <span class="ident">create_user</span></span>(<span>self, user: Union[Dict[str, Any], <a title="slack_sdk.scim.v1.user.User" href="user.html#slack_sdk.scim.v1.user.User">User</a>]) ‑> <a title="slack_sdk.scim.v1.response.UserCreateResponse" href="response.html#slack_sdk.scim.v1.response.UserCreateResponse">UserCreateResponse</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_user(self, user: Union[Dict[str, Any], User]) -&gt; UserCreateResponse:
    return UserCreateResponse(
        self.api_call(
            http_verb=&#34;POST&#34;,
            path=&#34;Users&#34;,
            body_params=user.to_dict() if isinstance(user, User) else _to_dict_without_not_given(user),
        )
    )</code></pre>
</details>
</dd>
<dt id="slack_sdk.scim.v1.client.SCIMClient.delete_group"><code class="name flex">
<span>def <span class="ident">delete_group</span></span>(<span>self, id: str) ‑> <a title="slack_sdk.scim.v1.response.GroupDeleteResponse" href="response.html#slack_sdk.scim.v1.response.GroupDeleteResponse">GroupDeleteResponse</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_group(self, id: str) -&gt; GroupDeleteResponse:
    return GroupDeleteResponse(
        self.api_call(
            http_verb=&#34;DELETE&#34;,
            path=f&#34;Groups/{quote(id)}&#34;,
        )
    )</code></pre>
</details>
</dd>
<dt id="slack_sdk.scim.v1.client.SCIMClient.delete_user"><code class="name flex">
<span>def <span class="ident">delete_user</span></span>(<span>self, id: str) ‑> <a title="slack_sdk.scim.v1.response.UserDeleteResponse" href="response.html#slack_sdk.scim.v1.response.UserDeleteResponse">UserDeleteResponse</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_user(self, id: str) -&gt; UserDeleteResponse:
    return UserDeleteResponse(
        self.api_call(
            http_verb=&#34;DELETE&#34;,
            path=f&#34;Users/{quote(id)}&#34;,
        )
    )</code></pre>
</details>
</dd>
<dt id="slack_sdk.scim.v1.client.SCIMClient.patch_group"><code class="name flex">
<span>def <span class="ident">patch_group</span></span>(<span>self, id: str, partial_group: Union[Dict[str, Any], <a title="slack_sdk.scim.v1.group.Group" href="group.html#slack_sdk.scim.v1.group.Group">Group</a>]) ‑> <a title="slack_sdk.scim.v1.response.GroupPatchResponse" href="response.html#slack_sdk.scim.v1.response.GroupPatchResponse">GroupPatchResponse</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def patch_group(self, id: str, partial_group: Union[Dict[str, Any], Group]) -&gt; GroupPatchResponse:
    return GroupPatchResponse(
        self.api_call(
            http_verb=&#34;PATCH&#34;,
            path=f&#34;Groups/{quote(id)}&#34;,
            body_params=partial_group.to_dict()
            if isinstance(partial_group, Group)
            else _to_dict_without_not_given(partial_group),
        )
    )</code></pre>
</details>
</dd>
<dt id="slack_sdk.scim.v1.client.SCIMClient.patch_user"><code class="name flex">
<span>def <span class="ident">patch_user</span></span>(<span>self, id: str, partial_user: Union[Dict[str, Any], <a title="slack_sdk.scim.v1.user.User" href="user.html#slack_sdk.scim.v1.user.User">User</a>]) ‑> <a title="slack_sdk.scim.v1.response.UserPatchResponse" href="response.html#slack_sdk.scim.v1.response.UserPatchResponse">UserPatchResponse</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def patch_user(self, id: str, partial_user: Union[Dict[str, Any], User]) -&gt; UserPatchResponse:
    return UserPatchResponse(
        self.api_call(
            http_verb=&#34;PATCH&#34;,
            path=f&#34;Users/{quote(id)}&#34;,
            body_params=partial_user.to_dict()
            if isinstance(partial_user, User)
            else _to_dict_without_not_given(partial_user),
        )
    )</code></pre>
</details>
</dd>
<dt id="slack_sdk.scim.v1.client.SCIMClient.read_group"><code class="name flex">
<span>def <span class="ident">read_group</span></span>(<span>self, id: str) ‑> <a title="slack_sdk.scim.v1.response.ReadGroupResponse" href="response.html#slack_sdk.scim.v1.response.ReadGroupResponse">ReadGroupResponse</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_group(self, id: str) -&gt; ReadGroupResponse:
    return ReadGroupResponse(self.api_call(http_verb=&#34;GET&#34;, path=f&#34;Groups/{quote(id)}&#34;))</code></pre>
</details>
</dd>
<dt id="slack_sdk.scim.v1.client.SCIMClient.read_user"><code class="name flex">
<span>def <span class="ident">read_user</span></span>(<span>self, id: str) ‑> <a title="slack_sdk.scim.v1.response.ReadUserResponse" href="response.html#slack_sdk.scim.v1.response.ReadUserResponse">ReadUserResponse</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_user(self, id: str) -&gt; ReadUserResponse:
    return ReadUserResponse(self.api_call(http_verb=&#34;GET&#34;, path=f&#34;Users/{quote(id)}&#34;))</code></pre>
</details>
</dd>
<dt id="slack_sdk.scim.v1.client.SCIMClient.search_groups"><code class="name flex">
<span>def <span class="ident">search_groups</span></span>(<span>self, *, count: int, start_index: int, filter: Optional[str] = None) ‑> <a title="slack_sdk.scim.v1.response.SearchGroupsResponse" href="response.html#slack_sdk.scim.v1.response.SearchGroupsResponse">SearchGroupsResponse</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_groups(
    self,
    *,
    # Pagination required as of August 30, 2019.
    count: int,
    start_index: int,
    filter: Optional[str] = None,
) -&gt; SearchGroupsResponse:
    return SearchGroupsResponse(
        self.api_call(
            http_verb=&#34;GET&#34;,
            path=&#34;Groups&#34;,
            query_params={
                &#34;filter&#34;: filter,
                &#34;count&#34;: count,
                &#34;startIndex&#34;: start_index,
            },
        )
    )</code></pre>
</details>
</dd>
<dt id="slack_sdk.scim.v1.client.SCIMClient.search_users"><code class="name flex">
<span>def <span class="ident">search_users</span></span>(<span>self, *, count: int, start_index: int, filter: Optional[str] = None) ‑> <a title="slack_sdk.scim.v1.response.SearchUsersResponse" href="response.html#slack_sdk.scim.v1.response.SearchUsersResponse">SearchUsersResponse</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_users(
    self,
    *,
    # Pagination required as of August 30, 2019.
    count: int,
    start_index: int,
    filter: Optional[str] = None,
) -&gt; SearchUsersResponse:
    return SearchUsersResponse(
        self.api_call(
            http_verb=&#34;GET&#34;,
            path=&#34;Users&#34;,
            query_params={
                &#34;filter&#34;: filter,
                &#34;count&#34;: count,
                &#34;startIndex&#34;: start_index,
            },
        )
    )</code></pre>
</details>
</dd>
<dt id="slack_sdk.scim.v1.client.SCIMClient.update_group"><code class="name flex">
<span>def <span class="ident">update_group</span></span>(<span>self, group: Union[Dict[str, Any], <a title="slack_sdk.scim.v1.group.Group" href="group.html#slack_sdk.scim.v1.group.Group">Group</a>]) ‑> <a title="slack_sdk.scim.v1.response.GroupUpdateResponse" href="response.html#slack_sdk.scim.v1.response.GroupUpdateResponse">GroupUpdateResponse</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_group(self, group: Union[Dict[str, Any], Group]) -&gt; GroupUpdateResponse:
    group_id = group.id if isinstance(group, Group) else group[&#34;id&#34;]
    return GroupUpdateResponse(
        self.api_call(
            http_verb=&#34;PUT&#34;,
            path=f&#34;Groups/{quote(group_id)}&#34;,
            body_params=group.to_dict() if isinstance(group, Group) else _to_dict_without_not_given(group),
        )
    )</code></pre>
</details>
</dd>
<dt id="slack_sdk.scim.v1.client.SCIMClient.update_user"><code class="name flex">
<span>def <span class="ident">update_user</span></span>(<span>self, user: Union[Dict[str, Any], <a title="slack_sdk.scim.v1.user.User" href="user.html#slack_sdk.scim.v1.user.User">User</a>]) ‑> <a title="slack_sdk.scim.v1.response.UserUpdateResponse" href="response.html#slack_sdk.scim.v1.response.UserUpdateResponse">UserUpdateResponse</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_user(self, user: Union[Dict[str, Any], User]) -&gt; UserUpdateResponse:
    user_id = user.id if isinstance(user, User) else user[&#34;id&#34;]
    return UserUpdateResponse(
        self.api_call(
            http_verb=&#34;PUT&#34;,
            path=f&#34;Users/{quote(user_id)}&#34;,
            body_params=user.to_dict() if isinstance(user, User) else _to_dict_without_not_given(user),
        )
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="slack_sdk.scim.v1" href="index.html">slack_sdk.scim.v1</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="slack_sdk.scim.v1.client.SCIMClient" href="#slack_sdk.scim.v1.client.SCIMClient">SCIMClient</a></code></h4>
<ul class="two-column">
<li><code><a title="slack_sdk.scim.v1.client.SCIMClient.BASE_URL" href="#slack_sdk.scim.v1.client.SCIMClient.BASE_URL">BASE_URL</a></code></li>
<li><code><a title="slack_sdk.scim.v1.client.SCIMClient.api_call" href="#slack_sdk.scim.v1.client.SCIMClient.api_call">api_call</a></code></li>
<li><code><a title="slack_sdk.scim.v1.client.SCIMClient.base_url" href="#slack_sdk.scim.v1.client.SCIMClient.base_url">base_url</a></code></li>
<li><code><a title="slack_sdk.scim.v1.client.SCIMClient.create_group" href="#slack_sdk.scim.v1.client.SCIMClient.create_group">create_group</a></code></li>
<li><code><a title="slack_sdk.scim.v1.client.SCIMClient.create_user" href="#slack_sdk.scim.v1.client.SCIMClient.create_user">create_user</a></code></li>
<li><code><a title="slack_sdk.scim.v1.client.SCIMClient.default_headers" href="#slack_sdk.scim.v1.client.SCIMClient.default_headers">default_headers</a></code></li>
<li><code><a title="slack_sdk.scim.v1.client.SCIMClient.delete_group" href="#slack_sdk.scim.v1.client.SCIMClient.delete_group">delete_group</a></code></li>
<li><code><a title="slack_sdk.scim.v1.client.SCIMClient.delete_user" href="#slack_sdk.scim.v1.client.SCIMClient.delete_user">delete_user</a></code></li>
<li><code><a title="slack_sdk.scim.v1.client.SCIMClient.logger" href="#slack_sdk.scim.v1.client.SCIMClient.logger">logger</a></code></li>
<li><code><a title="slack_sdk.scim.v1.client.SCIMClient.patch_group" href="#slack_sdk.scim.v1.client.SCIMClient.patch_group">patch_group</a></code></li>
<li><code><a title="slack_sdk.scim.v1.client.SCIMClient.patch_user" href="#slack_sdk.scim.v1.client.SCIMClient.patch_user">patch_user</a></code></li>
<li><code><a title="slack_sdk.scim.v1.client.SCIMClient.proxy" href="#slack_sdk.scim.v1.client.SCIMClient.proxy">proxy</a></code></li>
<li><code><a title="slack_sdk.scim.v1.client.SCIMClient.read_group" href="#slack_sdk.scim.v1.client.SCIMClient.read_group">read_group</a></code></li>
<li><code><a title="slack_sdk.scim.v1.client.SCIMClient.read_user" href="#slack_sdk.scim.v1.client.SCIMClient.read_user">read_user</a></code></li>
<li><code><a title="slack_sdk.scim.v1.client.SCIMClient.retry_handlers" href="#slack_sdk.scim.v1.client.SCIMClient.retry_handlers">retry_handlers</a></code></li>
<li><code><a title="slack_sdk.scim.v1.client.SCIMClient.search_groups" href="#slack_sdk.scim.v1.client.SCIMClient.search_groups">search_groups</a></code></li>
<li><code><a title="slack_sdk.scim.v1.client.SCIMClient.search_users" href="#slack_sdk.scim.v1.client.SCIMClient.search_users">search_users</a></code></li>
<li><code><a title="slack_sdk.scim.v1.client.SCIMClient.ssl" href="#slack_sdk.scim.v1.client.SCIMClient.ssl">ssl</a></code></li>
<li><code><a title="slack_sdk.scim.v1.client.SCIMClient.timeout" href="#slack_sdk.scim.v1.client.SCIMClient.timeout">timeout</a></code></li>
<li><code><a title="slack_sdk.scim.v1.client.SCIMClient.token" href="#slack_sdk.scim.v1.client.SCIMClient.token">token</a></code></li>
<li><code><a title="slack_sdk.scim.v1.client.SCIMClient.update_group" href="#slack_sdk.scim.v1.client.SCIMClient.update_group">update_group</a></code></li>
<li><code><a title="slack_sdk.scim.v1.client.SCIMClient.update_user" href="#slack_sdk.scim.v1.client.SCIMClient.update_user">update_user</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>