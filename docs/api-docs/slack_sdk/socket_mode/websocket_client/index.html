<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>slack_sdk.socket_mode.websocket_client API documentation</title>
<meta name="description" content="websocket-client bassd Socket Mode client …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>slack_sdk.socket_mode.websocket_client</code></h1>
</header>
<section id="section-intro">
<p>websocket-client bassd Socket Mode client</p>
<ul>
<li><a href="https://api.slack.com/apis/connections/socket">https://api.slack.com/apis/connections/socket</a></li>
<li><a href="https://slack.dev/python-slack-sdk/socket-mode/">https://slack.dev/python-slack-sdk/socket-mode/</a></li>
<li><a href="https://pypi.org/project/websocket-client/">https://pypi.org/project/websocket-client/</a></li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;websocket-client bassd Socket Mode client

* https://api.slack.com/apis/connections/socket
* https://slack.dev/python-slack-sdk/socket-mode/
* https://pypi.org/project/websocket-client/

&#34;&#34;&#34;
import logging
from concurrent.futures.thread import ThreadPoolExecutor
from logging import Logger
from queue import Queue
from threading import Lock
from typing import Union, Optional, List, Callable, Tuple

import websocket
from websocket import WebSocketApp, WebSocketException

from slack_sdk.socket_mode.client import BaseSocketModeClient
from slack_sdk.socket_mode.interval_runner import IntervalRunner
from slack_sdk.socket_mode.listeners import (
    WebSocketMessageListener,
    SocketModeRequestListener,
)
from slack_sdk.socket_mode.request import SocketModeRequest
from slack_sdk.web import WebClient


class SocketModeClient(BaseSocketModeClient):
    logger: Logger
    web_client: WebClient
    app_token: str
    wss_uri: Optional[str]
    message_queue: Queue
    message_listeners: List[
        Union[
            WebSocketMessageListener,
            Callable[[&#34;BaseSocketModeClient&#34;, dict, Optional[str]], None],
        ]
    ]
    socket_mode_request_listeners: List[
        Union[
            SocketModeRequestListener,
            Callable[[&#34;BaseSocketModeClient&#34;, SocketModeRequest], None],
        ]
    ]

    current_app_monitor: IntervalRunner
    current_app_monitor_started: bool
    message_processor: IntervalRunner
    message_workers: ThreadPoolExecutor

    current_session: Optional[WebSocketApp]
    current_session_runner: IntervalRunner

    auto_reconnect_enabled: bool
    default_auto_reconnect_enabled: bool

    close: bool
    connect_operation_lock: Lock

    on_open_listeners: List[Callable[[WebSocketApp], None]]
    on_message_listeners: List[Callable[[WebSocketApp, str], None]]
    on_error_listeners: List[Callable[[WebSocketApp, Exception], None]]
    on_close_listeners: List[Callable[[WebSocketApp], None]]

    def __init__(
        self,
        app_token: str,
        logger: Optional[Logger] = None,
        web_client: Optional[WebClient] = None,
        auto_reconnect_enabled: bool = True,
        ping_interval: float = 10,
        concurrency: int = 10,
        trace_enabled: bool = False,
        http_proxy_host: Optional[str] = None,
        http_proxy_port: Optional[int] = None,
        http_proxy_auth: Optional[Tuple[str, str]] = None,
        proxy_type: Optional[str] = None,
        on_open_listeners: Optional[List[Callable[[WebSocketApp], None]]] = None,
        on_message_listeners: Optional[List[Callable[[WebSocketApp, str], None]]] = None,
        on_error_listeners: Optional[List[Callable[[WebSocketApp, Exception], None]]] = None,
        on_close_listeners: Optional[List[Callable[[WebSocketApp], None]]] = None,
    ):
        &#34;&#34;&#34;

        Args:
            app_token: App-level token
            logger: Custom logger
            web_client: Web API client
            auto_reconnect_enabled: True if automatic reconnection is enabled (default: True)
            ping_interval: interval for ping-pong with Slack servers (seconds)
            concurrency: the size of thread pool (default: 10)
            http_proxy_host: the HTTP proxy host
            http_proxy_port: the HTTP proxy port
            http_proxy_auth: the HTTP proxy username &amp; password
            proxy_type: the HTTP proxy type
            on_open_listeners: listener functions for on_open
            on_message_listeners: listener functions for on_message
            on_error_listeners: listener functions for on_error
            on_close_listeners: listener functions for on_close
        &#34;&#34;&#34;
        self.app_token = app_token
        self.logger = logger or logging.getLogger(__name__)
        self.web_client = web_client or WebClient()
        self.default_auto_reconnect_enabled = auto_reconnect_enabled
        self.auto_reconnect_enabled = self.default_auto_reconnect_enabled
        self.ping_interval = ping_interval
        self.wss_uri = None
        self.message_queue = Queue()
        self.message_listeners = []
        self.socket_mode_request_listeners = []

        self.current_session = None
        self.current_session_runner = IntervalRunner(self._run_current_session, 0.5).start()

        self.current_app_monitor_started = False
        self.current_app_monitor = IntervalRunner(self._monitor_current_session, self.ping_interval)

        self.closed = False
        self.connect_operation_lock = Lock()

        self.message_processor = IntervalRunner(self.process_messages, 0.001).start()
        self.message_workers = ThreadPoolExecutor(max_workers=concurrency)

        # NOTE: only global settings is provided by the library
        websocket.enableTrace(trace_enabled)

        self.http_proxy_host = http_proxy_host
        self.http_proxy_port = http_proxy_port
        self.http_proxy_auth = http_proxy_auth
        self.proxy_type = proxy_type

        self.on_open_listeners = on_open_listeners or []
        self.on_message_listeners = on_message_listeners or []
        self.on_error_listeners = on_error_listeners or []
        self.on_close_listeners = on_close_listeners or []

    def is_connected(self) -&gt; bool:
        return self.current_session is not None and self.current_session.sock is not None

    def connect(self) -&gt; None:
        def on_open(ws: WebSocketApp):
            if self.logger.level &lt;= logging.DEBUG:
                self.logger.debug(&#34;on_open invoked&#34;)
            for listener in self.on_open_listeners:
                listener(ws)

        def on_message(ws: WebSocketApp, message: str):
            if self.logger.level &lt;= logging.DEBUG:
                self.logger.debug(f&#34;on_message invoked: (message: {message})&#34;)
            self.enqueue_message(message)
            for listener in self.on_message_listeners:
                listener(ws, message)

        def on_error(ws: WebSocketApp, error: Exception):
            self.logger.error(f&#34;on_error invoked (error: {type(error).__name__}, message: {error})&#34;)
            for listener in self.on_error_listeners:
                listener(ws, error)

        def on_close(
            ws: WebSocketApp,
            close_status_code: Optional[int] = None,
            close_msg: Optional[str] = None,
        ):
            if self.logger.level &lt;= logging.DEBUG:
                self.logger.debug(f&#34;on_close invoked: (code: {close_status_code}, message: {close_msg})&#34;)
            if self.auto_reconnect_enabled:
                self.logger.info(&#34;Received CLOSE event. Reconnecting...&#34;)
                self.connect_to_new_endpoint()
            for listener in self.on_close_listeners:
                listener(ws)

        old_session: Optional[WebSocketApp] = self.current_session

        if self.wss_uri is None:
            self.wss_uri = self.issue_new_wss_url()

        self.current_session = websocket.WebSocketApp(
            self.wss_uri,
            on_open=on_open,
            on_message=on_message,
            on_error=on_error,
            on_close=on_close,
        )
        self.auto_reconnect_enabled = self.default_auto_reconnect_enabled

        if not self.current_app_monitor_started:
            self.current_app_monitor_started = True
            self.current_app_monitor.start()

        if old_session is not None:
            old_session.close()

        self.logger.info(&#34;A new session has been established&#34;)

    def disconnect(self) -&gt; None:
        if self.current_session is not None:
            self.current_session.close()

    def send_message(self, message: str) -&gt; None:
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;Sending a message: {message}&#34;)
        try:
            self.current_session.send(message)
        except WebSocketException as e:
            # We rarely get this exception while replacing the underlying WebSocket connections.
            # We can do one more try here as the self.current_session should be ready now.
            if self.logger.level &lt;= logging.DEBUG:
                self.logger.debug(
                    f&#34;Failed to send a message (error: {e}, message: {message})&#34;
                    &#34; as the underlying connection was replaced. Retrying the same request only one time...&#34;
                )
            # Although acquiring self.connect_operation_lock also for the first method call is the safest way,
            # we avoid synchronizing a lot for better performance. That&#39;s why we are doing a retry here.
            with self.connect_operation_lock:
                if self.is_connected():
                    self.current_session.send(message)
                else:
                    self.logger.warning(  # type: ignore
                        f&#34;The current session (session id: {self.session_id()}) is no longer active. &#34;  # type: ignore
                        &#34;Failed to send a message&#34;
                    )
                    raise e

    def close(self) -&gt; None:  # type: ignore
        self.closed = True
        self.auto_reconnect_enabled = False
        self.disconnect()
        self.current_app_monitor.shutdown()
        self.message_processor.shutdown()
        self.message_workers.shutdown()

    def _run_current_session(self):
        if self.current_session is not None:
            try:
                self.logger.info(&#34;Starting to receive messages from a new connection&#34;)
                self.current_session.run_forever(
                    ping_interval=self.ping_interval,
                    http_proxy_host=self.http_proxy_host,
                    http_proxy_port=self.http_proxy_port,
                    http_proxy_auth=self.http_proxy_auth,
                    proxy_type=self.proxy_type,
                )
                self.logger.info(&#34;Stopped receiving messages from a connection&#34;)
            except Exception as e:
                self.logger.exception(f&#34;Failed to start or stop the current session: {e}&#34;)
                # To let the monitoring job detect the connection issue, closing this session
                if self.current_session is not None:
                    self.current_session.close()

    def _monitor_current_session(self):
        if self.current_app_monitor_started:
            try:
                if self.auto_reconnect_enabled and (self.current_session is None or self.current_session.sock is None):
                    self.logger.info(&#34;The session seems to be already closed. Reconnecting...&#34;)
                    self.connect_to_new_endpoint()
            except Exception as e:
                self.logger.error(
                    &#34;Failed to check the current session or reconnect to the server &#34;
                    f&#34;(error: {type(e).__name__}, message: {e})&#34;
                )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="slack_sdk.socket_mode.websocket_client.SocketModeClient"><code class="flex name class">
<span>class <span class="ident">SocketModeClient</span></span>
<span>(</span><span>app_token: str, logger: Optional[logging.Logger] = None, web_client: Optional[<a title="slack_sdk.web.client.WebClient" href="../../web/client.html#slack_sdk.web.client.WebClient">WebClient</a>] = None, auto_reconnect_enabled: bool = True, ping_interval: float = 10, concurrency: int = 10, trace_enabled: bool = False, http_proxy_host: Optional[str] = None, http_proxy_port: Optional[int] = None, http_proxy_auth: Optional[Tuple[str, str]] = None, proxy_type: Optional[str] = None, on_open_listeners: Optional[List[Callable[[websocket._app.WebSocketApp], None]]] = None, on_message_listeners: Optional[List[Callable[[websocket._app.WebSocketApp, str], None]]] = None, on_error_listeners: Optional[List[Callable[[websocket._app.WebSocketApp, Exception], None]]] = None, on_close_listeners: Optional[List[Callable[[websocket._app.WebSocketApp], None]]] = None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>app_token</code></strong></dt>
<dd>App-level token</dd>
<dt><strong><code>logger</code></strong></dt>
<dd>Custom logger</dd>
<dt><strong><code>web_client</code></strong></dt>
<dd>Web API client</dd>
<dt><strong><code>auto_reconnect_enabled</code></strong></dt>
<dd>True if automatic reconnection is enabled (default: True)</dd>
<dt><strong><code>ping_interval</code></strong></dt>
<dd>interval for ping-pong with Slack servers (seconds)</dd>
<dt><strong><code>concurrency</code></strong></dt>
<dd>the size of thread pool (default: 10)</dd>
<dt><strong><code>http_proxy_host</code></strong></dt>
<dd>the HTTP proxy host</dd>
<dt><strong><code>http_proxy_port</code></strong></dt>
<dd>the HTTP proxy port</dd>
<dt><strong><code>http_proxy_auth</code></strong></dt>
<dd>the HTTP proxy username &amp; password</dd>
<dt><strong><code>proxy_type</code></strong></dt>
<dd>the HTTP proxy type</dd>
<dt><strong><code>on_open_listeners</code></strong></dt>
<dd>listener functions for on_open</dd>
<dt><strong><code>on_message_listeners</code></strong></dt>
<dd>listener functions for on_message</dd>
<dt><strong><code>on_error_listeners</code></strong></dt>
<dd>listener functions for on_error</dd>
<dt><strong><code>on_close_listeners</code></strong></dt>
<dd>listener functions for on_close</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SocketModeClient(BaseSocketModeClient):
    logger: Logger
    web_client: WebClient
    app_token: str
    wss_uri: Optional[str]
    message_queue: Queue
    message_listeners: List[
        Union[
            WebSocketMessageListener,
            Callable[[&#34;BaseSocketModeClient&#34;, dict, Optional[str]], None],
        ]
    ]
    socket_mode_request_listeners: List[
        Union[
            SocketModeRequestListener,
            Callable[[&#34;BaseSocketModeClient&#34;, SocketModeRequest], None],
        ]
    ]

    current_app_monitor: IntervalRunner
    current_app_monitor_started: bool
    message_processor: IntervalRunner
    message_workers: ThreadPoolExecutor

    current_session: Optional[WebSocketApp]
    current_session_runner: IntervalRunner

    auto_reconnect_enabled: bool
    default_auto_reconnect_enabled: bool

    close: bool
    connect_operation_lock: Lock

    on_open_listeners: List[Callable[[WebSocketApp], None]]
    on_message_listeners: List[Callable[[WebSocketApp, str], None]]
    on_error_listeners: List[Callable[[WebSocketApp, Exception], None]]
    on_close_listeners: List[Callable[[WebSocketApp], None]]

    def __init__(
        self,
        app_token: str,
        logger: Optional[Logger] = None,
        web_client: Optional[WebClient] = None,
        auto_reconnect_enabled: bool = True,
        ping_interval: float = 10,
        concurrency: int = 10,
        trace_enabled: bool = False,
        http_proxy_host: Optional[str] = None,
        http_proxy_port: Optional[int] = None,
        http_proxy_auth: Optional[Tuple[str, str]] = None,
        proxy_type: Optional[str] = None,
        on_open_listeners: Optional[List[Callable[[WebSocketApp], None]]] = None,
        on_message_listeners: Optional[List[Callable[[WebSocketApp, str], None]]] = None,
        on_error_listeners: Optional[List[Callable[[WebSocketApp, Exception], None]]] = None,
        on_close_listeners: Optional[List[Callable[[WebSocketApp], None]]] = None,
    ):
        &#34;&#34;&#34;

        Args:
            app_token: App-level token
            logger: Custom logger
            web_client: Web API client
            auto_reconnect_enabled: True if automatic reconnection is enabled (default: True)
            ping_interval: interval for ping-pong with Slack servers (seconds)
            concurrency: the size of thread pool (default: 10)
            http_proxy_host: the HTTP proxy host
            http_proxy_port: the HTTP proxy port
            http_proxy_auth: the HTTP proxy username &amp; password
            proxy_type: the HTTP proxy type
            on_open_listeners: listener functions for on_open
            on_message_listeners: listener functions for on_message
            on_error_listeners: listener functions for on_error
            on_close_listeners: listener functions for on_close
        &#34;&#34;&#34;
        self.app_token = app_token
        self.logger = logger or logging.getLogger(__name__)
        self.web_client = web_client or WebClient()
        self.default_auto_reconnect_enabled = auto_reconnect_enabled
        self.auto_reconnect_enabled = self.default_auto_reconnect_enabled
        self.ping_interval = ping_interval
        self.wss_uri = None
        self.message_queue = Queue()
        self.message_listeners = []
        self.socket_mode_request_listeners = []

        self.current_session = None
        self.current_session_runner = IntervalRunner(self._run_current_session, 0.5).start()

        self.current_app_monitor_started = False
        self.current_app_monitor = IntervalRunner(self._monitor_current_session, self.ping_interval)

        self.closed = False
        self.connect_operation_lock = Lock()

        self.message_processor = IntervalRunner(self.process_messages, 0.001).start()
        self.message_workers = ThreadPoolExecutor(max_workers=concurrency)

        # NOTE: only global settings is provided by the library
        websocket.enableTrace(trace_enabled)

        self.http_proxy_host = http_proxy_host
        self.http_proxy_port = http_proxy_port
        self.http_proxy_auth = http_proxy_auth
        self.proxy_type = proxy_type

        self.on_open_listeners = on_open_listeners or []
        self.on_message_listeners = on_message_listeners or []
        self.on_error_listeners = on_error_listeners or []
        self.on_close_listeners = on_close_listeners or []

    def is_connected(self) -&gt; bool:
        return self.current_session is not None and self.current_session.sock is not None

    def connect(self) -&gt; None:
        def on_open(ws: WebSocketApp):
            if self.logger.level &lt;= logging.DEBUG:
                self.logger.debug(&#34;on_open invoked&#34;)
            for listener in self.on_open_listeners:
                listener(ws)

        def on_message(ws: WebSocketApp, message: str):
            if self.logger.level &lt;= logging.DEBUG:
                self.logger.debug(f&#34;on_message invoked: (message: {message})&#34;)
            self.enqueue_message(message)
            for listener in self.on_message_listeners:
                listener(ws, message)

        def on_error(ws: WebSocketApp, error: Exception):
            self.logger.error(f&#34;on_error invoked (error: {type(error).__name__}, message: {error})&#34;)
            for listener in self.on_error_listeners:
                listener(ws, error)

        def on_close(
            ws: WebSocketApp,
            close_status_code: Optional[int] = None,
            close_msg: Optional[str] = None,
        ):
            if self.logger.level &lt;= logging.DEBUG:
                self.logger.debug(f&#34;on_close invoked: (code: {close_status_code}, message: {close_msg})&#34;)
            if self.auto_reconnect_enabled:
                self.logger.info(&#34;Received CLOSE event. Reconnecting...&#34;)
                self.connect_to_new_endpoint()
            for listener in self.on_close_listeners:
                listener(ws)

        old_session: Optional[WebSocketApp] = self.current_session

        if self.wss_uri is None:
            self.wss_uri = self.issue_new_wss_url()

        self.current_session = websocket.WebSocketApp(
            self.wss_uri,
            on_open=on_open,
            on_message=on_message,
            on_error=on_error,
            on_close=on_close,
        )
        self.auto_reconnect_enabled = self.default_auto_reconnect_enabled

        if not self.current_app_monitor_started:
            self.current_app_monitor_started = True
            self.current_app_monitor.start()

        if old_session is not None:
            old_session.close()

        self.logger.info(&#34;A new session has been established&#34;)

    def disconnect(self) -&gt; None:
        if self.current_session is not None:
            self.current_session.close()

    def send_message(self, message: str) -&gt; None:
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;Sending a message: {message}&#34;)
        try:
            self.current_session.send(message)
        except WebSocketException as e:
            # We rarely get this exception while replacing the underlying WebSocket connections.
            # We can do one more try here as the self.current_session should be ready now.
            if self.logger.level &lt;= logging.DEBUG:
                self.logger.debug(
                    f&#34;Failed to send a message (error: {e}, message: {message})&#34;
                    &#34; as the underlying connection was replaced. Retrying the same request only one time...&#34;
                )
            # Although acquiring self.connect_operation_lock also for the first method call is the safest way,
            # we avoid synchronizing a lot for better performance. That&#39;s why we are doing a retry here.
            with self.connect_operation_lock:
                if self.is_connected():
                    self.current_session.send(message)
                else:
                    self.logger.warning(  # type: ignore
                        f&#34;The current session (session id: {self.session_id()}) is no longer active. &#34;  # type: ignore
                        &#34;Failed to send a message&#34;
                    )
                    raise e

    def close(self) -&gt; None:  # type: ignore
        self.closed = True
        self.auto_reconnect_enabled = False
        self.disconnect()
        self.current_app_monitor.shutdown()
        self.message_processor.shutdown()
        self.message_workers.shutdown()

    def _run_current_session(self):
        if self.current_session is not None:
            try:
                self.logger.info(&#34;Starting to receive messages from a new connection&#34;)
                self.current_session.run_forever(
                    ping_interval=self.ping_interval,
                    http_proxy_host=self.http_proxy_host,
                    http_proxy_port=self.http_proxy_port,
                    http_proxy_auth=self.http_proxy_auth,
                    proxy_type=self.proxy_type,
                )
                self.logger.info(&#34;Stopped receiving messages from a connection&#34;)
            except Exception as e:
                self.logger.exception(f&#34;Failed to start or stop the current session: {e}&#34;)
                # To let the monitoring job detect the connection issue, closing this session
                if self.current_session is not None:
                    self.current_session.close()

    def _monitor_current_session(self):
        if self.current_app_monitor_started:
            try:
                if self.auto_reconnect_enabled and (self.current_session is None or self.current_session.sock is None):
                    self.logger.info(&#34;The session seems to be already closed. Reconnecting...&#34;)
                    self.connect_to_new_endpoint()
            except Exception as e:
                self.logger.error(
                    &#34;Failed to check the current session or reconnect to the server &#34;
                    f&#34;(error: {type(e).__name__}, message: {e})&#34;
                )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="slack_sdk.socket_mode.client.BaseSocketModeClient" href="../client.html#slack_sdk.socket_mode.client.BaseSocketModeClient">BaseSocketModeClient</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="slack_sdk.socket_mode.websocket_client.SocketModeClient.app_token"><code class="name">var <span class="ident">app_token</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websocket_client.SocketModeClient.auto_reconnect_enabled"><code class="name">var <span class="ident">auto_reconnect_enabled</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websocket_client.SocketModeClient.connect_operation_lock"><code class="name">var <span class="ident">connect_operation_lock</span> : <built-in function allocate_lock></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websocket_client.SocketModeClient.current_app_monitor"><code class="name">var <span class="ident">current_app_monitor</span> : <a title="slack_sdk.socket_mode.interval_runner.IntervalRunner" href="../interval_runner.html#slack_sdk.socket_mode.interval_runner.IntervalRunner">IntervalRunner</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websocket_client.SocketModeClient.current_app_monitor_started"><code class="name">var <span class="ident">current_app_monitor_started</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websocket_client.SocketModeClient.current_session"><code class="name">var <span class="ident">current_session</span> : Optional[websocket._app.WebSocketApp]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websocket_client.SocketModeClient.current_session_runner"><code class="name">var <span class="ident">current_session_runner</span> : <a title="slack_sdk.socket_mode.interval_runner.IntervalRunner" href="../interval_runner.html#slack_sdk.socket_mode.interval_runner.IntervalRunner">IntervalRunner</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websocket_client.SocketModeClient.default_auto_reconnect_enabled"><code class="name">var <span class="ident">default_auto_reconnect_enabled</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websocket_client.SocketModeClient.logger"><code class="name">var <span class="ident">logger</span> : logging.Logger</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websocket_client.SocketModeClient.message_listeners"><code class="name">var <span class="ident">message_listeners</span> : List[Union[<a title="slack_sdk.socket_mode.listeners.WebSocketMessageListener" href="../listeners.html#slack_sdk.socket_mode.listeners.WebSocketMessageListener">WebSocketMessageListener</a>, Callable[[<a title="slack_sdk.socket_mode.client.BaseSocketModeClient" href="../client.html#slack_sdk.socket_mode.client.BaseSocketModeClient">BaseSocketModeClient</a>, dict, Optional[str]], None]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websocket_client.SocketModeClient.message_processor"><code class="name">var <span class="ident">message_processor</span> : <a title="slack_sdk.socket_mode.interval_runner.IntervalRunner" href="../interval_runner.html#slack_sdk.socket_mode.interval_runner.IntervalRunner">IntervalRunner</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websocket_client.SocketModeClient.message_queue"><code class="name">var <span class="ident">message_queue</span> : queue.Queue</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websocket_client.SocketModeClient.message_workers"><code class="name">var <span class="ident">message_workers</span> : concurrent.futures.thread.ThreadPoolExecutor</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websocket_client.SocketModeClient.on_close_listeners"><code class="name">var <span class="ident">on_close_listeners</span> : List[Callable[[websocket._app.WebSocketApp], None]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websocket_client.SocketModeClient.on_error_listeners"><code class="name">var <span class="ident">on_error_listeners</span> : List[Callable[[websocket._app.WebSocketApp, Exception], None]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websocket_client.SocketModeClient.on_message_listeners"><code class="name">var <span class="ident">on_message_listeners</span> : List[Callable[[websocket._app.WebSocketApp, str], None]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websocket_client.SocketModeClient.on_open_listeners"><code class="name">var <span class="ident">on_open_listeners</span> : List[Callable[[websocket._app.WebSocketApp], None]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websocket_client.SocketModeClient.socket_mode_request_listeners"><code class="name">var <span class="ident">socket_mode_request_listeners</span> : List[Union[<a title="slack_sdk.socket_mode.listeners.SocketModeRequestListener" href="../listeners.html#slack_sdk.socket_mode.listeners.SocketModeRequestListener">SocketModeRequestListener</a>, Callable[[<a title="slack_sdk.socket_mode.client.BaseSocketModeClient" href="../client.html#slack_sdk.socket_mode.client.BaseSocketModeClient">BaseSocketModeClient</a>, <a title="slack_sdk.socket_mode.request.SocketModeRequest" href="../request.html#slack_sdk.socket_mode.request.SocketModeRequest">SocketModeRequest</a>], None]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websocket_client.SocketModeClient.web_client"><code class="name">var <span class="ident">web_client</span> : <a title="slack_sdk.web.client.WebClient" href="../../web/client.html#slack_sdk.web.client.WebClient">WebClient</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websocket_client.SocketModeClient.wss_uri"><code class="name">var <span class="ident">wss_uri</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="slack_sdk.socket_mode.websocket_client.SocketModeClient.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self) -&gt; None:  # type: ignore
    self.closed = True
    self.auto_reconnect_enabled = False
    self.disconnect()
    self.current_app_monitor.shutdown()
    self.message_processor.shutdown()
    self.message_workers.shutdown()</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.websocket_client.SocketModeClient.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self) -&gt; None:
    def on_open(ws: WebSocketApp):
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(&#34;on_open invoked&#34;)
        for listener in self.on_open_listeners:
            listener(ws)

    def on_message(ws: WebSocketApp, message: str):
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;on_message invoked: (message: {message})&#34;)
        self.enqueue_message(message)
        for listener in self.on_message_listeners:
            listener(ws, message)

    def on_error(ws: WebSocketApp, error: Exception):
        self.logger.error(f&#34;on_error invoked (error: {type(error).__name__}, message: {error})&#34;)
        for listener in self.on_error_listeners:
            listener(ws, error)

    def on_close(
        ws: WebSocketApp,
        close_status_code: Optional[int] = None,
        close_msg: Optional[str] = None,
    ):
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;on_close invoked: (code: {close_status_code}, message: {close_msg})&#34;)
        if self.auto_reconnect_enabled:
            self.logger.info(&#34;Received CLOSE event. Reconnecting...&#34;)
            self.connect_to_new_endpoint()
        for listener in self.on_close_listeners:
            listener(ws)

    old_session: Optional[WebSocketApp] = self.current_session

    if self.wss_uri is None:
        self.wss_uri = self.issue_new_wss_url()

    self.current_session = websocket.WebSocketApp(
        self.wss_uri,
        on_open=on_open,
        on_message=on_message,
        on_error=on_error,
        on_close=on_close,
    )
    self.auto_reconnect_enabled = self.default_auto_reconnect_enabled

    if not self.current_app_monitor_started:
        self.current_app_monitor_started = True
        self.current_app_monitor.start()

    if old_session is not None:
        old_session.close()

    self.logger.info(&#34;A new session has been established&#34;)</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.websocket_client.SocketModeClient.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self) -&gt; None:
    if self.current_session is not None:
        self.current_session.close()</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.websocket_client.SocketModeClient.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_connected(self) -&gt; bool:
    return self.current_session is not None and self.current_session.sock is not None</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.websocket_client.SocketModeClient.send_message"><code class="name flex">
<span>def <span class="ident">send_message</span></span>(<span>self, message: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_message(self, message: str) -&gt; None:
    if self.logger.level &lt;= logging.DEBUG:
        self.logger.debug(f&#34;Sending a message: {message}&#34;)
    try:
        self.current_session.send(message)
    except WebSocketException as e:
        # We rarely get this exception while replacing the underlying WebSocket connections.
        # We can do one more try here as the self.current_session should be ready now.
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(
                f&#34;Failed to send a message (error: {e}, message: {message})&#34;
                &#34; as the underlying connection was replaced. Retrying the same request only one time...&#34;
            )
        # Although acquiring self.connect_operation_lock also for the first method call is the safest way,
        # we avoid synchronizing a lot for better performance. That&#39;s why we are doing a retry here.
        with self.connect_operation_lock:
            if self.is_connected():
                self.current_session.send(message)
            else:
                self.logger.warning(  # type: ignore
                    f&#34;The current session (session id: {self.session_id()}) is no longer active. &#34;  # type: ignore
                    &#34;Failed to send a message&#34;
                )
                raise e</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="slack_sdk.socket_mode" href="../index.html">slack_sdk.socket_mode</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="slack_sdk.socket_mode.websocket_client.SocketModeClient" href="#slack_sdk.socket_mode.websocket_client.SocketModeClient">SocketModeClient</a></code></h4>
<ul class="">
<li><code><a title="slack_sdk.socket_mode.websocket_client.SocketModeClient.app_token" href="#slack_sdk.socket_mode.websocket_client.SocketModeClient.app_token">app_token</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websocket_client.SocketModeClient.auto_reconnect_enabled" href="#slack_sdk.socket_mode.websocket_client.SocketModeClient.auto_reconnect_enabled">auto_reconnect_enabled</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websocket_client.SocketModeClient.close" href="#slack_sdk.socket_mode.websocket_client.SocketModeClient.close">close</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websocket_client.SocketModeClient.connect" href="#slack_sdk.socket_mode.websocket_client.SocketModeClient.connect">connect</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websocket_client.SocketModeClient.connect_operation_lock" href="#slack_sdk.socket_mode.websocket_client.SocketModeClient.connect_operation_lock">connect_operation_lock</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websocket_client.SocketModeClient.current_app_monitor" href="#slack_sdk.socket_mode.websocket_client.SocketModeClient.current_app_monitor">current_app_monitor</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websocket_client.SocketModeClient.current_app_monitor_started" href="#slack_sdk.socket_mode.websocket_client.SocketModeClient.current_app_monitor_started">current_app_monitor_started</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websocket_client.SocketModeClient.current_session" href="#slack_sdk.socket_mode.websocket_client.SocketModeClient.current_session">current_session</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websocket_client.SocketModeClient.current_session_runner" href="#slack_sdk.socket_mode.websocket_client.SocketModeClient.current_session_runner">current_session_runner</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websocket_client.SocketModeClient.default_auto_reconnect_enabled" href="#slack_sdk.socket_mode.websocket_client.SocketModeClient.default_auto_reconnect_enabled">default_auto_reconnect_enabled</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websocket_client.SocketModeClient.disconnect" href="#slack_sdk.socket_mode.websocket_client.SocketModeClient.disconnect">disconnect</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websocket_client.SocketModeClient.is_connected" href="#slack_sdk.socket_mode.websocket_client.SocketModeClient.is_connected">is_connected</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websocket_client.SocketModeClient.logger" href="#slack_sdk.socket_mode.websocket_client.SocketModeClient.logger">logger</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websocket_client.SocketModeClient.message_listeners" href="#slack_sdk.socket_mode.websocket_client.SocketModeClient.message_listeners">message_listeners</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websocket_client.SocketModeClient.message_processor" href="#slack_sdk.socket_mode.websocket_client.SocketModeClient.message_processor">message_processor</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websocket_client.SocketModeClient.message_queue" href="#slack_sdk.socket_mode.websocket_client.SocketModeClient.message_queue">message_queue</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websocket_client.SocketModeClient.message_workers" href="#slack_sdk.socket_mode.websocket_client.SocketModeClient.message_workers">message_workers</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websocket_client.SocketModeClient.on_close_listeners" href="#slack_sdk.socket_mode.websocket_client.SocketModeClient.on_close_listeners">on_close_listeners</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websocket_client.SocketModeClient.on_error_listeners" href="#slack_sdk.socket_mode.websocket_client.SocketModeClient.on_error_listeners">on_error_listeners</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websocket_client.SocketModeClient.on_message_listeners" href="#slack_sdk.socket_mode.websocket_client.SocketModeClient.on_message_listeners">on_message_listeners</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websocket_client.SocketModeClient.on_open_listeners" href="#slack_sdk.socket_mode.websocket_client.SocketModeClient.on_open_listeners">on_open_listeners</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websocket_client.SocketModeClient.send_message" href="#slack_sdk.socket_mode.websocket_client.SocketModeClient.send_message">send_message</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websocket_client.SocketModeClient.socket_mode_request_listeners" href="#slack_sdk.socket_mode.websocket_client.SocketModeClient.socket_mode_request_listeners">socket_mode_request_listeners</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websocket_client.SocketModeClient.web_client" href="#slack_sdk.socket_mode.websocket_client.SocketModeClient.web_client">web_client</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websocket_client.SocketModeClient.wss_uri" href="#slack_sdk.socket_mode.websocket_client.SocketModeClient.wss_uri">wss_uri</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>