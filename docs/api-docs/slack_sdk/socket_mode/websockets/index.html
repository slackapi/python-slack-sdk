<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>slack_sdk.socket_mode.websockets API documentation</title>
<meta name="description" content="websockets bassd Socket Mode client â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>slack_sdk.socket_mode.websockets</code></h1>
</header>
<section id="section-intro">
<p>websockets bassd Socket Mode client</p>
<ul>
<li><a href="https://api.slack.com/apis/connections/socket">https://api.slack.com/apis/connections/socket</a></li>
<li><a href="https://slack.dev/python-slack-sdk/socket-mode/">https://slack.dev/python-slack-sdk/socket-mode/</a></li>
<li><a href="https://pypi.org/project/websockets/">https://pypi.org/project/websockets/</a></li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;websockets bassd Socket Mode client

* https://api.slack.com/apis/connections/socket
* https://slack.dev/python-slack-sdk/socket-mode/
* https://pypi.org/project/websockets/

&#34;&#34;&#34;
import asyncio
import logging
from asyncio import Future, Lock
from logging import Logger
from asyncio import Queue
from typing import Union, Optional, List, Callable, Awaitable

import websockets
from websockets.client import WebSocketClientProtocol

from slack_sdk.socket_mode.async_client import AsyncBaseSocketModeClient
from slack_sdk.socket_mode.async_listeners import (
    AsyncWebSocketMessageListener,
    AsyncSocketModeRequestListener,
)
from slack_sdk.socket_mode.request import SocketModeRequest
from slack_sdk.web.async_client import AsyncWebClient


class SocketModeClient(AsyncBaseSocketModeClient):
    logger: Logger
    web_client: AsyncWebClient
    app_token: str
    wss_uri: Optional[str]
    auto_reconnect_enabled: bool
    message_queue: Queue
    message_listeners: List[
        Union[
            AsyncWebSocketMessageListener,
            Callable[
                [&#34;AsyncBaseSocketModeClient&#34;, dict, Optional[str]], Awaitable[None]
            ],
        ]
    ]
    socket_mode_request_listeners: List[
        Union[
            AsyncSocketModeRequestListener,
            Callable[[&#34;AsyncBaseSocketModeClient&#34;, SocketModeRequest], Awaitable[None]],
        ]
    ]

    message_receiver: Optional[Future]
    message_processor: Future

    ping_interval: float
    current_session: Optional[WebSocketClientProtocol]
    current_session_monitor: Optional[Future]

    auto_reconnect_enabled: bool
    default_auto_reconnect_enabled: bool
    closed: bool
    connect_operation_lock: Lock

    def __init__(
        self,
        app_token: str,
        logger: Optional[Logger] = None,
        web_client: Optional[AsyncWebClient] = None,
        auto_reconnect_enabled: bool = True,
        ping_interval: float = 10,
    ):
        &#34;&#34;&#34;Socket Mode client

        Args:
            app_token: App-level token
            logger: Custom logger
            web_client: Web API client
            auto_reconnect_enabled: True if automatic reconnection is enabled (default: True)
            ping_interval: interval for ping-pong with Slack servers (seconds)
        &#34;&#34;&#34;
        self.app_token = app_token
        self.logger = logger or logging.getLogger(__name__)
        self.web_client = web_client or AsyncWebClient()
        self.closed = False
        self.connect_operation_lock = Lock()
        self.default_auto_reconnect_enabled = auto_reconnect_enabled
        self.auto_reconnect_enabled = self.default_auto_reconnect_enabled
        self.ping_interval = ping_interval
        self.wss_uri = None
        self.message_queue = Queue()
        self.message_listeners = []
        self.socket_mode_request_listeners = []
        self.current_session = None
        self.current_session_monitor = None

        self.message_receiver = None
        self.message_processor = asyncio.ensure_future(self.process_messages())

    async def monitor_current_session(self) -&gt; None:
        while not self.closed:
            await asyncio.sleep(self.ping_interval)
            try:
                if self.auto_reconnect_enabled and (
                    self.current_session is None or self.current_session.closed
                ):
                    self.logger.info(
                        &#34;The session seems to be already closed. Going to reconnect...&#34;
                    )
                    await self.connect_to_new_endpoint()
            except Exception as e:
                self.logger.error(
                    &#34;Failed to check the current session or reconnect to the server &#34;
                    f&#34;(error: {type(e).__name__}, message: {e})&#34;
                )

    async def receive_messages(self) -&gt; None:
        consecutive_error_count = 0
        while not self.closed:
            try:
                message = await self.current_session.recv()
                if message is not None:
                    if isinstance(message, bytes):
                        message = message.decode(&#34;utf-8&#34;)
                    if self.logger.level &lt;= logging.DEBUG:
                        self.logger.debug(f&#34;Received message: {message}&#34;)
                    await self.enqueue_message(message)
                consecutive_error_count = 0
            except Exception as e:
                consecutive_error_count += 1
                self.logger.error(
                    f&#34;Failed to receive or enqueue a message: {type(e).__name__}, {e}&#34;
                )
                if isinstance(e, websockets.ConnectionClosedError):
                    await asyncio.sleep(self.ping_interval)
                else:
                    await asyncio.sleep(consecutive_error_count)

    async def is_connected(self) -&gt; bool:
        return (
            not self.closed
            and self.current_session is not None
            and not self.current_session.closed
        )

    async def connect(self):
        if self.wss_uri is None:
            self.wss_uri = await self.issue_new_wss_url()
        old_session: Optional[WebSocketClientProtocol] = (
            None if self.current_session is None else self.current_session
        )
        # NOTE: websockets does not support proxy settings
        self.current_session = await websockets.connect(
            uri=self.wss_uri,
            ping_interval=self.ping_interval,
        )
        self.auto_reconnect_enabled = self.default_auto_reconnect_enabled
        self.logger.info(&#34;A new session has been established&#34;)

        if self.current_session_monitor is None:
            self.current_session_monitor = asyncio.ensure_future(
                self.monitor_current_session()
            )

        if self.message_receiver is None:
            self.message_receiver = asyncio.ensure_future(self.receive_messages())

        if old_session is not None:
            await old_session.close()
            self.logger.info(&#34;The old session has been abandoned&#34;)

    async def disconnect(self):
        if self.current_session is not None:
            await self.current_session.close()

    async def send_message(self, message: str):
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;Sending a message: {message}&#34;)
        await self.current_session.send(message)

    async def close(self):
        self.closed = True
        self.auto_reconnect_enabled = False
        await self.disconnect()
        self.message_processor.cancel()
        if self.current_session_monitor is not None:
            self.current_session_monitor.cancel()
        if self.message_receiver is not None:
            self.message_receiver.cancel()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="slack_sdk.socket_mode.websockets.SocketModeClient"><code class="flex name class">
<span>class <span class="ident">SocketModeClient</span></span>
<span>(</span><span>app_token:Â str, logger:Â Optional[logging.Logger]Â =Â None, web_client:Â Optional[<a title="slack_sdk.web.async_client.AsyncWebClient" href="../../web/async_client.html#slack_sdk.web.async_client.AsyncWebClient">AsyncWebClient</a>]Â =Â None, auto_reconnect_enabled:Â boolÂ =Â True, ping_interval:Â floatÂ =Â 10)</span>
</code></dt>
<dd>
<div class="desc"><p>Socket Mode client</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>app_token</code></strong></dt>
<dd>App-level token</dd>
<dt><strong><code>logger</code></strong></dt>
<dd>Custom logger</dd>
<dt><strong><code>web_client</code></strong></dt>
<dd>Web API client</dd>
<dt><strong><code>auto_reconnect_enabled</code></strong></dt>
<dd>True if automatic reconnection is enabled (default: True)</dd>
<dt><strong><code>ping_interval</code></strong></dt>
<dd>interval for ping-pong with Slack servers (seconds)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SocketModeClient(AsyncBaseSocketModeClient):
    logger: Logger
    web_client: AsyncWebClient
    app_token: str
    wss_uri: Optional[str]
    auto_reconnect_enabled: bool
    message_queue: Queue
    message_listeners: List[
        Union[
            AsyncWebSocketMessageListener,
            Callable[
                [&#34;AsyncBaseSocketModeClient&#34;, dict, Optional[str]], Awaitable[None]
            ],
        ]
    ]
    socket_mode_request_listeners: List[
        Union[
            AsyncSocketModeRequestListener,
            Callable[[&#34;AsyncBaseSocketModeClient&#34;, SocketModeRequest], Awaitable[None]],
        ]
    ]

    message_receiver: Optional[Future]
    message_processor: Future

    ping_interval: float
    current_session: Optional[WebSocketClientProtocol]
    current_session_monitor: Optional[Future]

    auto_reconnect_enabled: bool
    default_auto_reconnect_enabled: bool
    closed: bool
    connect_operation_lock: Lock

    def __init__(
        self,
        app_token: str,
        logger: Optional[Logger] = None,
        web_client: Optional[AsyncWebClient] = None,
        auto_reconnect_enabled: bool = True,
        ping_interval: float = 10,
    ):
        &#34;&#34;&#34;Socket Mode client

        Args:
            app_token: App-level token
            logger: Custom logger
            web_client: Web API client
            auto_reconnect_enabled: True if automatic reconnection is enabled (default: True)
            ping_interval: interval for ping-pong with Slack servers (seconds)
        &#34;&#34;&#34;
        self.app_token = app_token
        self.logger = logger or logging.getLogger(__name__)
        self.web_client = web_client or AsyncWebClient()
        self.closed = False
        self.connect_operation_lock = Lock()
        self.default_auto_reconnect_enabled = auto_reconnect_enabled
        self.auto_reconnect_enabled = self.default_auto_reconnect_enabled
        self.ping_interval = ping_interval
        self.wss_uri = None
        self.message_queue = Queue()
        self.message_listeners = []
        self.socket_mode_request_listeners = []
        self.current_session = None
        self.current_session_monitor = None

        self.message_receiver = None
        self.message_processor = asyncio.ensure_future(self.process_messages())

    async def monitor_current_session(self) -&gt; None:
        while not self.closed:
            await asyncio.sleep(self.ping_interval)
            try:
                if self.auto_reconnect_enabled and (
                    self.current_session is None or self.current_session.closed
                ):
                    self.logger.info(
                        &#34;The session seems to be already closed. Going to reconnect...&#34;
                    )
                    await self.connect_to_new_endpoint()
            except Exception as e:
                self.logger.error(
                    &#34;Failed to check the current session or reconnect to the server &#34;
                    f&#34;(error: {type(e).__name__}, message: {e})&#34;
                )

    async def receive_messages(self) -&gt; None:
        consecutive_error_count = 0
        while not self.closed:
            try:
                message = await self.current_session.recv()
                if message is not None:
                    if isinstance(message, bytes):
                        message = message.decode(&#34;utf-8&#34;)
                    if self.logger.level &lt;= logging.DEBUG:
                        self.logger.debug(f&#34;Received message: {message}&#34;)
                    await self.enqueue_message(message)
                consecutive_error_count = 0
            except Exception as e:
                consecutive_error_count += 1
                self.logger.error(
                    f&#34;Failed to receive or enqueue a message: {type(e).__name__}, {e}&#34;
                )
                if isinstance(e, websockets.ConnectionClosedError):
                    await asyncio.sleep(self.ping_interval)
                else:
                    await asyncio.sleep(consecutive_error_count)

    async def is_connected(self) -&gt; bool:
        return (
            not self.closed
            and self.current_session is not None
            and not self.current_session.closed
        )

    async def connect(self):
        if self.wss_uri is None:
            self.wss_uri = await self.issue_new_wss_url()
        old_session: Optional[WebSocketClientProtocol] = (
            None if self.current_session is None else self.current_session
        )
        # NOTE: websockets does not support proxy settings
        self.current_session = await websockets.connect(
            uri=self.wss_uri,
            ping_interval=self.ping_interval,
        )
        self.auto_reconnect_enabled = self.default_auto_reconnect_enabled
        self.logger.info(&#34;A new session has been established&#34;)

        if self.current_session_monitor is None:
            self.current_session_monitor = asyncio.ensure_future(
                self.monitor_current_session()
            )

        if self.message_receiver is None:
            self.message_receiver = asyncio.ensure_future(self.receive_messages())

        if old_session is not None:
            await old_session.close()
            self.logger.info(&#34;The old session has been abandoned&#34;)

    async def disconnect(self):
        if self.current_session is not None:
            await self.current_session.close()

    async def send_message(self, message: str):
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;Sending a message: {message}&#34;)
        await self.current_session.send(message)

    async def close(self):
        self.closed = True
        self.auto_reconnect_enabled = False
        await self.disconnect()
        self.message_processor.cancel()
        if self.current_session_monitor is not None:
            self.current_session_monitor.cancel()
        if self.message_receiver is not None:
            self.message_receiver.cancel()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="slack_sdk.socket_mode.async_client.AsyncBaseSocketModeClient" href="../async_client.html#slack_sdk.socket_mode.async_client.AsyncBaseSocketModeClient">AsyncBaseSocketModeClient</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="slack_sdk.socket_mode.websockets.SocketModeClient.app_token"><code class="name">var <span class="ident">app_token</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websockets.SocketModeClient.auto_reconnect_enabled"><code class="name">var <span class="ident">auto_reconnect_enabled</span> :Â bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websockets.SocketModeClient.closed"><code class="name">var <span class="ident">closed</span> :Â bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websockets.SocketModeClient.connect_operation_lock"><code class="name">var <span class="ident">connect_operation_lock</span> :Â asyncio.locks.Lock</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websockets.SocketModeClient.current_session"><code class="name">var <span class="ident">current_session</span> :Â Optional[websockets.legacy.client.WebSocketClientProtocol]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websockets.SocketModeClient.current_session_monitor"><code class="name">var <span class="ident">current_session_monitor</span> :Â Optional[_asyncio.Future]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websockets.SocketModeClient.default_auto_reconnect_enabled"><code class="name">var <span class="ident">default_auto_reconnect_enabled</span> :Â bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websockets.SocketModeClient.logger"><code class="name">var <span class="ident">logger</span> :Â logging.Logger</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websockets.SocketModeClient.message_listeners"><code class="name">var <span class="ident">message_listeners</span> :Â List[Union[<a title="slack_sdk.socket_mode.async_listeners.AsyncWebSocketMessageListener" href="../async_listeners.html#slack_sdk.socket_mode.async_listeners.AsyncWebSocketMessageListener">AsyncWebSocketMessageListener</a>,Â Callable[[<a title="slack_sdk.socket_mode.async_client.AsyncBaseSocketModeClient" href="../async_client.html#slack_sdk.socket_mode.async_client.AsyncBaseSocketModeClient">AsyncBaseSocketModeClient</a>,Â dict,Â Optional[str]],Â Awaitable[NoneType]]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websockets.SocketModeClient.message_processor"><code class="name">var <span class="ident">message_processor</span> :Â _asyncio.Future</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websockets.SocketModeClient.message_queue"><code class="name">var <span class="ident">message_queue</span> :Â asyncio.queues.Queue</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websockets.SocketModeClient.message_receiver"><code class="name">var <span class="ident">message_receiver</span> :Â Optional[_asyncio.Future]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websockets.SocketModeClient.ping_interval"><code class="name">var <span class="ident">ping_interval</span> :Â float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websockets.SocketModeClient.socket_mode_request_listeners"><code class="name">var <span class="ident">socket_mode_request_listeners</span> :Â List[Union[<a title="slack_sdk.socket_mode.async_listeners.AsyncSocketModeRequestListener" href="../async_listeners.html#slack_sdk.socket_mode.async_listeners.AsyncSocketModeRequestListener">AsyncSocketModeRequestListener</a>,Â Callable[[<a title="slack_sdk.socket_mode.async_client.AsyncBaseSocketModeClient" href="../async_client.html#slack_sdk.socket_mode.async_client.AsyncBaseSocketModeClient">AsyncBaseSocketModeClient</a>,Â <a title="slack_sdk.socket_mode.request.SocketModeRequest" href="../request.html#slack_sdk.socket_mode.request.SocketModeRequest">SocketModeRequest</a>],Â Awaitable[NoneType]]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websockets.SocketModeClient.web_client"><code class="name">var <span class="ident">web_client</span> :Â <a title="slack_sdk.web.async_client.AsyncWebClient" href="../../web/async_client.html#slack_sdk.web.async_client.AsyncWebClient">AsyncWebClient</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.websockets.SocketModeClient.wss_uri"><code class="name">var <span class="ident">wss_uri</span> :Â Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="slack_sdk.socket_mode.websockets.SocketModeClient.close"><code class="name flex">
<span>async def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def close(self):
    self.closed = True
    self.auto_reconnect_enabled = False
    await self.disconnect()
    self.message_processor.cancel()
    if self.current_session_monitor is not None:
        self.current_session_monitor.cancel()
    if self.message_receiver is not None:
        self.message_receiver.cancel()</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.websockets.SocketModeClient.connect"><code class="name flex">
<span>async def <span class="ident">connect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def connect(self):
    if self.wss_uri is None:
        self.wss_uri = await self.issue_new_wss_url()
    old_session: Optional[WebSocketClientProtocol] = (
        None if self.current_session is None else self.current_session
    )
    # NOTE: websockets does not support proxy settings
    self.current_session = await websockets.connect(
        uri=self.wss_uri,
        ping_interval=self.ping_interval,
    )
    self.auto_reconnect_enabled = self.default_auto_reconnect_enabled
    self.logger.info(&#34;A new session has been established&#34;)

    if self.current_session_monitor is None:
        self.current_session_monitor = asyncio.ensure_future(
            self.monitor_current_session()
        )

    if self.message_receiver is None:
        self.message_receiver = asyncio.ensure_future(self.receive_messages())

    if old_session is not None:
        await old_session.close()
        self.logger.info(&#34;The old session has been abandoned&#34;)</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.websockets.SocketModeClient.disconnect"><code class="name flex">
<span>async def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def disconnect(self):
    if self.current_session is not None:
        await self.current_session.close()</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.websockets.SocketModeClient.is_connected"><code class="name flex">
<span>async def <span class="ident">is_connected</span></span>(<span>self) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def is_connected(self) -&gt; bool:
    return (
        not self.closed
        and self.current_session is not None
        and not self.current_session.closed
    )</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.websockets.SocketModeClient.monitor_current_session"><code class="name flex">
<span>async def <span class="ident">monitor_current_session</span></span>(<span>self) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def monitor_current_session(self) -&gt; None:
    while not self.closed:
        await asyncio.sleep(self.ping_interval)
        try:
            if self.auto_reconnect_enabled and (
                self.current_session is None or self.current_session.closed
            ):
                self.logger.info(
                    &#34;The session seems to be already closed. Going to reconnect...&#34;
                )
                await self.connect_to_new_endpoint()
        except Exception as e:
            self.logger.error(
                &#34;Failed to check the current session or reconnect to the server &#34;
                f&#34;(error: {type(e).__name__}, message: {e})&#34;
            )</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.websockets.SocketModeClient.receive_messages"><code class="name flex">
<span>async def <span class="ident">receive_messages</span></span>(<span>self) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def receive_messages(self) -&gt; None:
    consecutive_error_count = 0
    while not self.closed:
        try:
            message = await self.current_session.recv()
            if message is not None:
                if isinstance(message, bytes):
                    message = message.decode(&#34;utf-8&#34;)
                if self.logger.level &lt;= logging.DEBUG:
                    self.logger.debug(f&#34;Received message: {message}&#34;)
                await self.enqueue_message(message)
            consecutive_error_count = 0
        except Exception as e:
            consecutive_error_count += 1
            self.logger.error(
                f&#34;Failed to receive or enqueue a message: {type(e).__name__}, {e}&#34;
            )
            if isinstance(e, websockets.ConnectionClosedError):
                await asyncio.sleep(self.ping_interval)
            else:
                await asyncio.sleep(consecutive_error_count)</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.websockets.SocketModeClient.send_message"><code class="name flex">
<span>async def <span class="ident">send_message</span></span>(<span>self, message:Â str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_message(self, message: str):
    if self.logger.level &lt;= logging.DEBUG:
        self.logger.debug(f&#34;Sending a message: {message}&#34;)
    await self.current_session.send(message)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="slack_sdk.socket_mode" href="../index.html">slack_sdk.socket_mode</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="slack_sdk.socket_mode.websockets.SocketModeClient" href="#slack_sdk.socket_mode.websockets.SocketModeClient">SocketModeClient</a></code></h4>
<ul class="">
<li><code><a title="slack_sdk.socket_mode.websockets.SocketModeClient.app_token" href="#slack_sdk.socket_mode.websockets.SocketModeClient.app_token">app_token</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websockets.SocketModeClient.auto_reconnect_enabled" href="#slack_sdk.socket_mode.websockets.SocketModeClient.auto_reconnect_enabled">auto_reconnect_enabled</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websockets.SocketModeClient.close" href="#slack_sdk.socket_mode.websockets.SocketModeClient.close">close</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websockets.SocketModeClient.closed" href="#slack_sdk.socket_mode.websockets.SocketModeClient.closed">closed</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websockets.SocketModeClient.connect" href="#slack_sdk.socket_mode.websockets.SocketModeClient.connect">connect</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websockets.SocketModeClient.connect_operation_lock" href="#slack_sdk.socket_mode.websockets.SocketModeClient.connect_operation_lock">connect_operation_lock</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websockets.SocketModeClient.current_session" href="#slack_sdk.socket_mode.websockets.SocketModeClient.current_session">current_session</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websockets.SocketModeClient.current_session_monitor" href="#slack_sdk.socket_mode.websockets.SocketModeClient.current_session_monitor">current_session_monitor</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websockets.SocketModeClient.default_auto_reconnect_enabled" href="#slack_sdk.socket_mode.websockets.SocketModeClient.default_auto_reconnect_enabled">default_auto_reconnect_enabled</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websockets.SocketModeClient.disconnect" href="#slack_sdk.socket_mode.websockets.SocketModeClient.disconnect">disconnect</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websockets.SocketModeClient.is_connected" href="#slack_sdk.socket_mode.websockets.SocketModeClient.is_connected">is_connected</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websockets.SocketModeClient.logger" href="#slack_sdk.socket_mode.websockets.SocketModeClient.logger">logger</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websockets.SocketModeClient.message_listeners" href="#slack_sdk.socket_mode.websockets.SocketModeClient.message_listeners">message_listeners</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websockets.SocketModeClient.message_processor" href="#slack_sdk.socket_mode.websockets.SocketModeClient.message_processor">message_processor</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websockets.SocketModeClient.message_queue" href="#slack_sdk.socket_mode.websockets.SocketModeClient.message_queue">message_queue</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websockets.SocketModeClient.message_receiver" href="#slack_sdk.socket_mode.websockets.SocketModeClient.message_receiver">message_receiver</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websockets.SocketModeClient.monitor_current_session" href="#slack_sdk.socket_mode.websockets.SocketModeClient.monitor_current_session">monitor_current_session</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websockets.SocketModeClient.ping_interval" href="#slack_sdk.socket_mode.websockets.SocketModeClient.ping_interval">ping_interval</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websockets.SocketModeClient.receive_messages" href="#slack_sdk.socket_mode.websockets.SocketModeClient.receive_messages">receive_messages</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websockets.SocketModeClient.send_message" href="#slack_sdk.socket_mode.websockets.SocketModeClient.send_message">send_message</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websockets.SocketModeClient.socket_mode_request_listeners" href="#slack_sdk.socket_mode.websockets.SocketModeClient.socket_mode_request_listeners">socket_mode_request_listeners</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websockets.SocketModeClient.web_client" href="#slack_sdk.socket_mode.websockets.SocketModeClient.web_client">web_client</a></code></li>
<li><code><a title="slack_sdk.socket_mode.websockets.SocketModeClient.wss_uri" href="#slack_sdk.socket_mode.websockets.SocketModeClient.wss_uri">wss_uri</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>