<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>slack_sdk.socket_mode.aiohttp API documentation</title>
<meta name="description" content="aiohttp bassd Socket Mode client …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>slack_sdk.socket_mode.aiohttp</code></h1>
</header>
<section id="section-intro">
<p>aiohttp bassd Socket Mode client</p>
<ul>
<li><a href="https://api.slack.com/apis/connections/socket">https://api.slack.com/apis/connections/socket</a></li>
<li><a href="https://slack.dev/python-slack-sdk/socket-mode/">https://slack.dev/python-slack-sdk/socket-mode/</a></li>
<li><a href="https://pypi.org/project/aiohttp/">https://pypi.org/project/aiohttp/</a></li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;aiohttp bassd Socket Mode client

* https://api.slack.com/apis/connections/socket
* https://slack.dev/python-slack-sdk/socket-mode/
* https://pypi.org/project/aiohttp/

&#34;&#34;&#34;
import asyncio
import logging
from asyncio import Future
from asyncio import Queue
from logging import Logger
from typing import Union, Optional, List, Callable, Awaitable

import aiohttp
from aiohttp import ClientWebSocketResponse, WSMessage, WSMsgType, ClientConnectionError

from slack_sdk.proxy_env_variable_loader import load_http_proxy_from_env
from slack_sdk.socket_mode.async_client import AsyncBaseSocketModeClient
from slack_sdk.socket_mode.async_listeners import (
    AsyncWebSocketMessageListener,
    AsyncSocketModeRequestListener,
)
from slack_sdk.socket_mode.request import SocketModeRequest
from slack_sdk.web.async_client import AsyncWebClient


class SocketModeClient(AsyncBaseSocketModeClient):
    logger: Logger
    web_client: AsyncWebClient
    app_token: str
    wss_uri: Optional[str]
    auto_reconnect_enabled: bool
    message_queue: Queue
    message_listeners: List[
        Union[
            AsyncWebSocketMessageListener,
            Callable[
                [&#34;AsyncBaseSocketModeClient&#34;, dict, Optional[str]], Awaitable[None]
            ],
        ]
    ]
    socket_mode_request_listeners: List[
        Union[
            AsyncSocketModeRequestListener,
            Callable[[&#34;AsyncBaseSocketModeClient&#34;, SocketModeRequest], Awaitable[None]],
        ]
    ]

    message_receiver: Optional[Future]
    message_processor: Future

    proxy: Optional[str]
    ping_interval: float
    current_session: Optional[ClientWebSocketResponse]
    current_session_monitor: Optional[Future]

    auto_reconnect_enabled: bool
    default_auto_reconnect_enabled: bool
    closed: bool

    on_message_listeners: List[Callable[[WSMessage], Awaitable[None]]]
    on_error_listeners: List[Callable[[WSMessage], Awaitable[None]]]
    on_close_listeners: List[Callable[[WSMessage], Awaitable[None]]]

    def __init__(
        self,
        app_token: str,
        logger: Optional[Logger] = None,
        web_client: Optional[AsyncWebClient] = None,
        proxy: Optional[str] = None,
        auto_reconnect_enabled: bool = True,
        ping_interval: float = 10,
        on_message_listeners: Optional[List[Callable[[WSMessage], None]]] = None,
        on_error_listeners: Optional[List[Callable[[WSMessage], None]]] = None,
        on_close_listeners: Optional[List[Callable[[WSMessage], None]]] = None,
    ):
        &#34;&#34;&#34;Socket Mode client

        Args:
            app_token: App-level token
            logger: Custom logger
            web_client: Web API client
            auto_reconnect_enabled: True if automatic reconnection is enabled (default: True)
            ping_interval: interval for ping-pong with Slack servers (seconds)
            proxy: the HTTP proxy URL
            on_message_listeners: listener functions for on_message
            on_error_listeners: listener functions for on_error
            on_close_listeners: listener functions for on_close
        &#34;&#34;&#34;
        self.app_token = app_token
        self.logger = logger or logging.getLogger(__name__)
        self.web_client = web_client or AsyncWebClient()
        self.closed = False
        self.proxy = proxy
        if self.proxy is None or len(self.proxy.strip()) == 0:
            env_variable = load_http_proxy_from_env(self.logger)
            if env_variable is not None:
                self.proxy = env_variable

        self.default_auto_reconnect_enabled = auto_reconnect_enabled
        self.auto_reconnect_enabled = self.default_auto_reconnect_enabled
        self.ping_interval = ping_interval

        self.wss_uri = None
        self.message_queue = Queue()
        self.message_listeners = []
        self.socket_mode_request_listeners = []
        self.current_session = None
        self.current_session_monitor = None

        # https://docs.aiohttp.org/en/stable/client_reference.html
        # Unless you are connecting to a large, unknown number of different servers
        # over the lifetime of your application,
        # it is suggested you use a single session for the lifetime of your application
        # to benefit from connection pooling.
        self.aiohttp_client_session = aiohttp.ClientSession()

        self.on_message_listeners = on_message_listeners or []
        self.on_error_listeners = on_error_listeners or []
        self.on_close_listeners = on_close_listeners or []

        self.message_receiver = None
        self.message_processor = asyncio.ensure_future(self.process_messages())

    async def monitor_current_session(self) -&gt; None:
        while not self.closed:
            await asyncio.sleep(self.ping_interval)
            try:
                if self.auto_reconnect_enabled and (
                    self.current_session is None or self.current_session.closed
                ):
                    self.logger.info(
                        &#34;The session seems to be already closed. Going to reconnect...&#34;
                    )
                    await self.connect_to_new_endpoint()
            except Exception as e:
                self.logger.error(
                    &#34;Failed to check the current session or reconnect to the server &#34;
                    f&#34;(error: {type(e).__name__}, message: {e})&#34;
                )

    async def receive_messages(self) -&gt; None:
        consecutive_error_count = 0
        while not self.closed:
            try:
                message: WSMessage = await self.current_session.receive()
                if self.logger.level &lt;= logging.DEBUG:
                    type = WSMsgType(message.type)
                    message_type = type.name if type is not None else message.type
                    message_data = message.data
                    if isinstance(message_data, bytes):
                        message_data = message_data.decode(&#34;utf-8&#34;)
                    self.logger.debug(
                        f&#34;Received message (type: {message_type}, data: {message_data}, extra: {message.extra})&#34;
                    )
                if message is not None:
                    if message.type == WSMsgType.TEXT:
                        message_data = message.data
                        await self.enqueue_message(message_data)
                        for listener in self.on_message_listeners:
                            await listener(message)
                    elif message.type == WSMsgType.CLOSE:
                        if self.auto_reconnect_enabled:
                            self.logger.info(
                                &#34;Received CLOSE event. Going to reconnect...&#34;
                            )
                            await self.connect_to_new_endpoint()
                        for listener in self.on_close_listeners:
                            await listener(message)
                    elif message.type == WSMsgType.ERROR:
                        for listener in self.on_error_listeners:
                            await listener(message)
                    elif message.type == WSMsgType.CLOSED:
                        await asyncio.sleep(self.ping_interval)
                        continue
                consecutive_error_count = 0
            except Exception as e:
                consecutive_error_count += 1
                self.logger.error(
                    f&#34;Failed to receive or enqueue a message: {type(e).__name__}, {e}&#34;
                )
                if isinstance(e, ClientConnectionError):
                    await asyncio.sleep(self.ping_interval)
                else:
                    await asyncio.sleep(consecutive_error_count)

    async def connect(self):
        old_session = None if self.current_session is None else self.current_session
        if self.wss_uri is None:
            self.wss_uri = await self.issue_new_wss_url()
        self.current_session = await self.aiohttp_client_session.ws_connect(
            self.wss_uri,
            heartbeat=self.ping_interval,
            proxy=self.proxy,
        )
        self.auto_reconnect_enabled = self.default_auto_reconnect_enabled
        self.logger.info(&#34;A new session has been established&#34;)

        if self.current_session_monitor is None:
            self.current_session_monitor = asyncio.ensure_future(
                self.monitor_current_session()
            )

        if self.message_receiver is None:
            self.message_receiver = asyncio.ensure_future(self.receive_messages())

        if old_session is not None:
            await old_session.close()
            self.logger.info(&#34;The old session has been abandoned&#34;)

    async def disconnect(self):
        if self.current_session is not None:
            await self.current_session.close()
        self.logger.info(&#34;The session has been abandoned&#34;)

    async def send_message(self, message: str):
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;Sending a message: {message}&#34;)
        await self.current_session.send_str(message)

    async def close(self):
        self.closed = True
        self.auto_reconnect_enabled = False
        await self.disconnect()
        self.message_processor.cancel()
        if self.current_session_monitor is not None:
            self.current_session_monitor.cancel()
        if self.message_receiver is not None:
            self.message_receiver.cancel()
        if self.aiohttp_client_session is not None:
            await self.aiohttp_client_session.close()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient"><code class="flex name class">
<span>class <span class="ident">SocketModeClient</span></span>
<span>(</span><span>app_token: str, logger: Optional[logging.Logger] = None, web_client: Optional[<a title="slack_sdk.web.async_client.AsyncWebClient" href="../../web/async_client.html#slack_sdk.web.async_client.AsyncWebClient">AsyncWebClient</a>] = None, proxy: Optional[str] = None, auto_reconnect_enabled: bool = True, ping_interval: float = 10, on_message_listeners: Optional[List[Callable[[aiohttp.http_websocket.WSMessage], NoneType]]] = None, on_error_listeners: Optional[List[Callable[[aiohttp.http_websocket.WSMessage], NoneType]]] = None, on_close_listeners: Optional[List[Callable[[aiohttp.http_websocket.WSMessage], NoneType]]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Socket Mode client</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>app_token</code></strong></dt>
<dd>App-level token</dd>
<dt><strong><code>logger</code></strong></dt>
<dd>Custom logger</dd>
<dt><strong><code>web_client</code></strong></dt>
<dd>Web API client</dd>
<dt><strong><code>auto_reconnect_enabled</code></strong></dt>
<dd>True if automatic reconnection is enabled (default: True)</dd>
<dt><strong><code>ping_interval</code></strong></dt>
<dd>interval for ping-pong with Slack servers (seconds)</dd>
<dt><strong><code>proxy</code></strong></dt>
<dd>the HTTP proxy URL</dd>
<dt><strong><code>on_message_listeners</code></strong></dt>
<dd>listener functions for on_message</dd>
<dt><strong><code>on_error_listeners</code></strong></dt>
<dd>listener functions for on_error</dd>
<dt><strong><code>on_close_listeners</code></strong></dt>
<dd>listener functions for on_close</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SocketModeClient(AsyncBaseSocketModeClient):
    logger: Logger
    web_client: AsyncWebClient
    app_token: str
    wss_uri: Optional[str]
    auto_reconnect_enabled: bool
    message_queue: Queue
    message_listeners: List[
        Union[
            AsyncWebSocketMessageListener,
            Callable[
                [&#34;AsyncBaseSocketModeClient&#34;, dict, Optional[str]], Awaitable[None]
            ],
        ]
    ]
    socket_mode_request_listeners: List[
        Union[
            AsyncSocketModeRequestListener,
            Callable[[&#34;AsyncBaseSocketModeClient&#34;, SocketModeRequest], Awaitable[None]],
        ]
    ]

    message_receiver: Optional[Future]
    message_processor: Future

    proxy: Optional[str]
    ping_interval: float
    current_session: Optional[ClientWebSocketResponse]
    current_session_monitor: Optional[Future]

    auto_reconnect_enabled: bool
    default_auto_reconnect_enabled: bool
    closed: bool

    on_message_listeners: List[Callable[[WSMessage], Awaitable[None]]]
    on_error_listeners: List[Callable[[WSMessage], Awaitable[None]]]
    on_close_listeners: List[Callable[[WSMessage], Awaitable[None]]]

    def __init__(
        self,
        app_token: str,
        logger: Optional[Logger] = None,
        web_client: Optional[AsyncWebClient] = None,
        proxy: Optional[str] = None,
        auto_reconnect_enabled: bool = True,
        ping_interval: float = 10,
        on_message_listeners: Optional[List[Callable[[WSMessage], None]]] = None,
        on_error_listeners: Optional[List[Callable[[WSMessage], None]]] = None,
        on_close_listeners: Optional[List[Callable[[WSMessage], None]]] = None,
    ):
        &#34;&#34;&#34;Socket Mode client

        Args:
            app_token: App-level token
            logger: Custom logger
            web_client: Web API client
            auto_reconnect_enabled: True if automatic reconnection is enabled (default: True)
            ping_interval: interval for ping-pong with Slack servers (seconds)
            proxy: the HTTP proxy URL
            on_message_listeners: listener functions for on_message
            on_error_listeners: listener functions for on_error
            on_close_listeners: listener functions for on_close
        &#34;&#34;&#34;
        self.app_token = app_token
        self.logger = logger or logging.getLogger(__name__)
        self.web_client = web_client or AsyncWebClient()
        self.closed = False
        self.proxy = proxy
        if self.proxy is None or len(self.proxy.strip()) == 0:
            env_variable = load_http_proxy_from_env(self.logger)
            if env_variable is not None:
                self.proxy = env_variable

        self.default_auto_reconnect_enabled = auto_reconnect_enabled
        self.auto_reconnect_enabled = self.default_auto_reconnect_enabled
        self.ping_interval = ping_interval

        self.wss_uri = None
        self.message_queue = Queue()
        self.message_listeners = []
        self.socket_mode_request_listeners = []
        self.current_session = None
        self.current_session_monitor = None

        # https://docs.aiohttp.org/en/stable/client_reference.html
        # Unless you are connecting to a large, unknown number of different servers
        # over the lifetime of your application,
        # it is suggested you use a single session for the lifetime of your application
        # to benefit from connection pooling.
        self.aiohttp_client_session = aiohttp.ClientSession()

        self.on_message_listeners = on_message_listeners or []
        self.on_error_listeners = on_error_listeners or []
        self.on_close_listeners = on_close_listeners or []

        self.message_receiver = None
        self.message_processor = asyncio.ensure_future(self.process_messages())

    async def monitor_current_session(self) -&gt; None:
        while not self.closed:
            await asyncio.sleep(self.ping_interval)
            try:
                if self.auto_reconnect_enabled and (
                    self.current_session is None or self.current_session.closed
                ):
                    self.logger.info(
                        &#34;The session seems to be already closed. Going to reconnect...&#34;
                    )
                    await self.connect_to_new_endpoint()
            except Exception as e:
                self.logger.error(
                    &#34;Failed to check the current session or reconnect to the server &#34;
                    f&#34;(error: {type(e).__name__}, message: {e})&#34;
                )

    async def receive_messages(self) -&gt; None:
        consecutive_error_count = 0
        while not self.closed:
            try:
                message: WSMessage = await self.current_session.receive()
                if self.logger.level &lt;= logging.DEBUG:
                    type = WSMsgType(message.type)
                    message_type = type.name if type is not None else message.type
                    message_data = message.data
                    if isinstance(message_data, bytes):
                        message_data = message_data.decode(&#34;utf-8&#34;)
                    self.logger.debug(
                        f&#34;Received message (type: {message_type}, data: {message_data}, extra: {message.extra})&#34;
                    )
                if message is not None:
                    if message.type == WSMsgType.TEXT:
                        message_data = message.data
                        await self.enqueue_message(message_data)
                        for listener in self.on_message_listeners:
                            await listener(message)
                    elif message.type == WSMsgType.CLOSE:
                        if self.auto_reconnect_enabled:
                            self.logger.info(
                                &#34;Received CLOSE event. Going to reconnect...&#34;
                            )
                            await self.connect_to_new_endpoint()
                        for listener in self.on_close_listeners:
                            await listener(message)
                    elif message.type == WSMsgType.ERROR:
                        for listener in self.on_error_listeners:
                            await listener(message)
                    elif message.type == WSMsgType.CLOSED:
                        await asyncio.sleep(self.ping_interval)
                        continue
                consecutive_error_count = 0
            except Exception as e:
                consecutive_error_count += 1
                self.logger.error(
                    f&#34;Failed to receive or enqueue a message: {type(e).__name__}, {e}&#34;
                )
                if isinstance(e, ClientConnectionError):
                    await asyncio.sleep(self.ping_interval)
                else:
                    await asyncio.sleep(consecutive_error_count)

    async def connect(self):
        old_session = None if self.current_session is None else self.current_session
        if self.wss_uri is None:
            self.wss_uri = await self.issue_new_wss_url()
        self.current_session = await self.aiohttp_client_session.ws_connect(
            self.wss_uri,
            heartbeat=self.ping_interval,
            proxy=self.proxy,
        )
        self.auto_reconnect_enabled = self.default_auto_reconnect_enabled
        self.logger.info(&#34;A new session has been established&#34;)

        if self.current_session_monitor is None:
            self.current_session_monitor = asyncio.ensure_future(
                self.monitor_current_session()
            )

        if self.message_receiver is None:
            self.message_receiver = asyncio.ensure_future(self.receive_messages())

        if old_session is not None:
            await old_session.close()
            self.logger.info(&#34;The old session has been abandoned&#34;)

    async def disconnect(self):
        if self.current_session is not None:
            await self.current_session.close()
        self.logger.info(&#34;The session has been abandoned&#34;)

    async def send_message(self, message: str):
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;Sending a message: {message}&#34;)
        await self.current_session.send_str(message)

    async def close(self):
        self.closed = True
        self.auto_reconnect_enabled = False
        await self.disconnect()
        self.message_processor.cancel()
        if self.current_session_monitor is not None:
            self.current_session_monitor.cancel()
        if self.message_receiver is not None:
            self.message_receiver.cancel()
        if self.aiohttp_client_session is not None:
            await self.aiohttp_client_session.close()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="slack_sdk.socket_mode.async_client.AsyncBaseSocketModeClient" href="../async_client.html#slack_sdk.socket_mode.async_client.AsyncBaseSocketModeClient">AsyncBaseSocketModeClient</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.app_token"><code class="name">var <span class="ident">app_token</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.auto_reconnect_enabled"><code class="name">var <span class="ident">auto_reconnect_enabled</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.closed"><code class="name">var <span class="ident">closed</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.current_session"><code class="name">var <span class="ident">current_session</span> : Optional[aiohttp.client_ws.ClientWebSocketResponse]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.current_session_monitor"><code class="name">var <span class="ident">current_session_monitor</span> : Optional[_asyncio.Future]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.default_auto_reconnect_enabled"><code class="name">var <span class="ident">default_auto_reconnect_enabled</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.logger"><code class="name">var <span class="ident">logger</span> : logging.Logger</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.message_listeners"><code class="name">var <span class="ident">message_listeners</span> : List[Union[<a title="slack_sdk.socket_mode.async_listeners.AsyncWebSocketMessageListener" href="../async_listeners.html#slack_sdk.socket_mode.async_listeners.AsyncWebSocketMessageListener">AsyncWebSocketMessageListener</a>, Callable[[<a title="slack_sdk.socket_mode.async_client.AsyncBaseSocketModeClient" href="../async_client.html#slack_sdk.socket_mode.async_client.AsyncBaseSocketModeClient">AsyncBaseSocketModeClient</a>, dict, Optional[str]], Awaitable[NoneType]]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.message_processor"><code class="name">var <span class="ident">message_processor</span> : _asyncio.Future</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.message_queue"><code class="name">var <span class="ident">message_queue</span> : asyncio.queues.Queue</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.message_receiver"><code class="name">var <span class="ident">message_receiver</span> : Optional[_asyncio.Future]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.on_close_listeners"><code class="name">var <span class="ident">on_close_listeners</span> : List[Callable[[aiohttp.http_websocket.WSMessage], Awaitable[NoneType]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.on_error_listeners"><code class="name">var <span class="ident">on_error_listeners</span> : List[Callable[[aiohttp.http_websocket.WSMessage], Awaitable[NoneType]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.on_message_listeners"><code class="name">var <span class="ident">on_message_listeners</span> : List[Callable[[aiohttp.http_websocket.WSMessage], Awaitable[NoneType]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.ping_interval"><code class="name">var <span class="ident">ping_interval</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.proxy"><code class="name">var <span class="ident">proxy</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.socket_mode_request_listeners"><code class="name">var <span class="ident">socket_mode_request_listeners</span> : List[Union[<a title="slack_sdk.socket_mode.async_listeners.AsyncSocketModeRequestListener" href="../async_listeners.html#slack_sdk.socket_mode.async_listeners.AsyncSocketModeRequestListener">AsyncSocketModeRequestListener</a>, Callable[[<a title="slack_sdk.socket_mode.async_client.AsyncBaseSocketModeClient" href="../async_client.html#slack_sdk.socket_mode.async_client.AsyncBaseSocketModeClient">AsyncBaseSocketModeClient</a>, <a title="slack_sdk.socket_mode.request.SocketModeRequest" href="../request.html#slack_sdk.socket_mode.request.SocketModeRequest">SocketModeRequest</a>], Awaitable[NoneType]]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.web_client"><code class="name">var <span class="ident">web_client</span> : <a title="slack_sdk.web.async_client.AsyncWebClient" href="../../web/async_client.html#slack_sdk.web.async_client.AsyncWebClient">AsyncWebClient</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.wss_uri"><code class="name">var <span class="ident">wss_uri</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.close"><code class="name flex">
<span>async def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def close(self):
    self.closed = True
    self.auto_reconnect_enabled = False
    await self.disconnect()
    self.message_processor.cancel()
    if self.current_session_monitor is not None:
        self.current_session_monitor.cancel()
    if self.message_receiver is not None:
        self.message_receiver.cancel()
    if self.aiohttp_client_session is not None:
        await self.aiohttp_client_session.close()</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.connect"><code class="name flex">
<span>async def <span class="ident">connect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def connect(self):
    old_session = None if self.current_session is None else self.current_session
    if self.wss_uri is None:
        self.wss_uri = await self.issue_new_wss_url()
    self.current_session = await self.aiohttp_client_session.ws_connect(
        self.wss_uri,
        heartbeat=self.ping_interval,
        proxy=self.proxy,
    )
    self.auto_reconnect_enabled = self.default_auto_reconnect_enabled
    self.logger.info(&#34;A new session has been established&#34;)

    if self.current_session_monitor is None:
        self.current_session_monitor = asyncio.ensure_future(
            self.monitor_current_session()
        )

    if self.message_receiver is None:
        self.message_receiver = asyncio.ensure_future(self.receive_messages())

    if old_session is not None:
        await old_session.close()
        self.logger.info(&#34;The old session has been abandoned&#34;)</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.disconnect"><code class="name flex">
<span>async def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def disconnect(self):
    if self.current_session is not None:
        await self.current_session.close()
    self.logger.info(&#34;The session has been abandoned&#34;)</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.monitor_current_session"><code class="name flex">
<span>async def <span class="ident">monitor_current_session</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def monitor_current_session(self) -&gt; None:
    while not self.closed:
        await asyncio.sleep(self.ping_interval)
        try:
            if self.auto_reconnect_enabled and (
                self.current_session is None or self.current_session.closed
            ):
                self.logger.info(
                    &#34;The session seems to be already closed. Going to reconnect...&#34;
                )
                await self.connect_to_new_endpoint()
        except Exception as e:
            self.logger.error(
                &#34;Failed to check the current session or reconnect to the server &#34;
                f&#34;(error: {type(e).__name__}, message: {e})&#34;
            )</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.receive_messages"><code class="name flex">
<span>async def <span class="ident">receive_messages</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def receive_messages(self) -&gt; None:
    consecutive_error_count = 0
    while not self.closed:
        try:
            message: WSMessage = await self.current_session.receive()
            if self.logger.level &lt;= logging.DEBUG:
                type = WSMsgType(message.type)
                message_type = type.name if type is not None else message.type
                message_data = message.data
                if isinstance(message_data, bytes):
                    message_data = message_data.decode(&#34;utf-8&#34;)
                self.logger.debug(
                    f&#34;Received message (type: {message_type}, data: {message_data}, extra: {message.extra})&#34;
                )
            if message is not None:
                if message.type == WSMsgType.TEXT:
                    message_data = message.data
                    await self.enqueue_message(message_data)
                    for listener in self.on_message_listeners:
                        await listener(message)
                elif message.type == WSMsgType.CLOSE:
                    if self.auto_reconnect_enabled:
                        self.logger.info(
                            &#34;Received CLOSE event. Going to reconnect...&#34;
                        )
                        await self.connect_to_new_endpoint()
                    for listener in self.on_close_listeners:
                        await listener(message)
                elif message.type == WSMsgType.ERROR:
                    for listener in self.on_error_listeners:
                        await listener(message)
                elif message.type == WSMsgType.CLOSED:
                    await asyncio.sleep(self.ping_interval)
                    continue
            consecutive_error_count = 0
        except Exception as e:
            consecutive_error_count += 1
            self.logger.error(
                f&#34;Failed to receive or enqueue a message: {type(e).__name__}, {e}&#34;
            )
            if isinstance(e, ClientConnectionError):
                await asyncio.sleep(self.ping_interval)
            else:
                await asyncio.sleep(consecutive_error_count)</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.send_message"><code class="name flex">
<span>async def <span class="ident">send_message</span></span>(<span>self, message: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_message(self, message: str):
    if self.logger.level &lt;= logging.DEBUG:
        self.logger.debug(f&#34;Sending a message: {message}&#34;)
    await self.current_session.send_str(message)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="slack_sdk.socket_mode" href="../index.html">slack_sdk.socket_mode</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient">SocketModeClient</a></code></h4>
<ul class="">
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.app_token" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.app_token">app_token</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.auto_reconnect_enabled" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.auto_reconnect_enabled">auto_reconnect_enabled</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.close" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.close">close</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.closed" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.closed">closed</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.connect" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.connect">connect</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.current_session" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.current_session">current_session</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.current_session_monitor" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.current_session_monitor">current_session_monitor</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.default_auto_reconnect_enabled" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.default_auto_reconnect_enabled">default_auto_reconnect_enabled</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.disconnect" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.disconnect">disconnect</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.logger" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.logger">logger</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.message_listeners" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.message_listeners">message_listeners</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.message_processor" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.message_processor">message_processor</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.message_queue" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.message_queue">message_queue</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.message_receiver" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.message_receiver">message_receiver</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.monitor_current_session" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.monitor_current_session">monitor_current_session</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.on_close_listeners" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.on_close_listeners">on_close_listeners</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.on_error_listeners" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.on_error_listeners">on_error_listeners</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.on_message_listeners" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.on_message_listeners">on_message_listeners</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.ping_interval" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.ping_interval">ping_interval</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.proxy" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.proxy">proxy</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.receive_messages" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.receive_messages">receive_messages</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.send_message" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.send_message">send_message</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.socket_mode_request_listeners" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.socket_mode_request_listeners">socket_mode_request_listeners</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.web_client" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.web_client">web_client</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.wss_uri" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.wss_uri">wss_uri</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>