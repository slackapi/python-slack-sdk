<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>slack_sdk.socket_mode.aiohttp API documentation</title>
<meta name="description" content="aiohttp based Socket Mode client â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>slack_sdk.socket_mode.aiohttp</code></h1>
</header>
<section id="section-intro">
<p>aiohttp based Socket Mode client</p>
<ul>
<li><a href="https://api.slack.com/apis/connections/socket">https://api.slack.com/apis/connections/socket</a></li>
<li><a href="https://slack.dev/python-slack-sdk/socket-mode/">https://slack.dev/python-slack-sdk/socket-mode/</a></li>
<li><a href="https://pypi.org/project/aiohttp/">https://pypi.org/project/aiohttp/</a></li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;aiohttp based Socket Mode client

* https://api.slack.com/apis/connections/socket
* https://slack.dev/python-slack-sdk/socket-mode/
* https://pypi.org/project/aiohttp/

&#34;&#34;&#34;
import asyncio
import logging
import time
from asyncio import Future, Lock
from asyncio import Queue
from logging import Logger
from typing import Union, Optional, List, Callable, Awaitable

import aiohttp
from aiohttp import ClientWebSocketResponse, WSMessage, WSMsgType, ClientConnectionError

from slack_sdk.proxy_env_variable_loader import load_http_proxy_from_env
from slack_sdk.socket_mode.async_client import AsyncBaseSocketModeClient
from slack_sdk.socket_mode.async_listeners import (
    AsyncWebSocketMessageListener,
    AsyncSocketModeRequestListener,
)
from slack_sdk.socket_mode.request import SocketModeRequest
from slack_sdk.web.async_client import AsyncWebClient


class SocketModeClient(AsyncBaseSocketModeClient):
    logger: Logger
    web_client: AsyncWebClient
    app_token: str
    wss_uri: Optional[str]
    auto_reconnect_enabled: bool
    message_queue: Queue
    message_listeners: List[
        Union[
            AsyncWebSocketMessageListener,
            Callable[[&#34;AsyncBaseSocketModeClient&#34;, dict, Optional[str]], Awaitable[None]],
        ]
    ]
    socket_mode_request_listeners: List[
        Union[
            AsyncSocketModeRequestListener,
            Callable[[&#34;AsyncBaseSocketModeClient&#34;, SocketModeRequest], Awaitable[None]],
        ]
    ]

    message_receiver: Optional[Future]
    message_processor: Future

    proxy: Optional[str]
    ping_interval: float
    trace_enabled: bool

    last_ping_pong_time: Optional[float]
    current_session: Optional[ClientWebSocketResponse]
    current_session_monitor: Optional[Future]

    auto_reconnect_enabled: bool
    default_auto_reconnect_enabled: bool
    closed: bool
    stale: bool
    connect_operation_lock: Lock

    on_message_listeners: List[Callable[[WSMessage], Awaitable[None]]]
    on_error_listeners: List[Callable[[WSMessage], Awaitable[None]]]
    on_close_listeners: List[Callable[[WSMessage], Awaitable[None]]]

    def __init__(
        self,
        app_token: str,
        logger: Optional[Logger] = None,
        web_client: Optional[AsyncWebClient] = None,
        proxy: Optional[str] = None,
        auto_reconnect_enabled: bool = True,
        ping_interval: float = 5,
        trace_enabled: bool = False,
        on_message_listeners: Optional[List[Callable[[WSMessage], Awaitable[None]]]] = None,
        on_error_listeners: Optional[List[Callable[[WSMessage], Awaitable[None]]]] = None,
        on_close_listeners: Optional[List[Callable[[WSMessage], Awaitable[None]]]] = None,
    ):
        &#34;&#34;&#34;Socket Mode client

        Args:
            app_token: App-level token
            logger: Custom logger
            web_client: Web API client
            auto_reconnect_enabled: True if automatic reconnection is enabled (default: True)
            ping_interval: interval for ping-pong with Slack servers (seconds)
            trace_enabled: True if more verbose logs to see what&#39;s happening under the hood
            proxy: the HTTP proxy URL
            on_message_listeners: listener functions for on_message
            on_error_listeners: listener functions for on_error
            on_close_listeners: listener functions for on_close
        &#34;&#34;&#34;
        self.app_token = app_token
        self.logger = logger or logging.getLogger(__name__)
        self.web_client = web_client or AsyncWebClient()
        self.closed = False
        self.stale = False
        self.connect_operation_lock = Lock()
        self.proxy = proxy
        if self.proxy is None or len(self.proxy.strip()) == 0:
            env_variable = load_http_proxy_from_env(self.logger)
            if env_variable is not None:
                self.proxy = env_variable

        self.default_auto_reconnect_enabled = auto_reconnect_enabled
        self.auto_reconnect_enabled = self.default_auto_reconnect_enabled
        self.ping_interval = ping_interval
        self.trace_enabled = trace_enabled
        self.last_ping_pong_time = None

        self.wss_uri = None
        self.message_queue = Queue()
        self.message_listeners = []
        self.socket_mode_request_listeners = []
        self.current_session = None
        self.current_session_monitor = None

        # https://docs.aiohttp.org/en/stable/client_reference.html
        # Unless you are connecting to a large, unknown number of different servers
        # over the lifetime of your application,
        # it is suggested you use a single session for the lifetime of your application
        # to benefit from connection pooling.
        self.aiohttp_client_session = aiohttp.ClientSession()

        self.on_message_listeners = on_message_listeners or []
        self.on_error_listeners = on_error_listeners or []
        self.on_close_listeners = on_close_listeners or []

        self.message_receiver = None
        self.message_processor = asyncio.ensure_future(self.process_messages())

    async def monitor_current_session(self) -&gt; None:
        # In the asyncio runtime, accessing a shared object (self.current_session here) from
        # multiple tasks can cause race conditions and errors.
        # To avoid such, we access only the session that is active when this loop starts.
        session: ClientWebSocketResponse = self.current_session
        session_id: str = self.build_session_id(session)

        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;A new monitor_current_session() execution loop for {session_id} started&#34;)
        try:
            logging_interval = 100
            counter_for_logging = 0

            while not self.closed:
                if session != self.current_session:
                    if self.logger.level &lt;= logging.DEBUG:
                        self.logger.debug(f&#34;The monitor_current_session task for {session_id} is now cancelled&#34;)
                    break
                try:
                    if self.trace_enabled and self.logger.level &lt;= logging.DEBUG:
                        # The logging here is for detailed investigation on potential issues in this client.
                        # If you don&#39;t see this log for a while, it means that
                        # this receive_messages execution is no longer working for some reason.
                        counter_for_logging += 1
                        if counter_for_logging &gt;= logging_interval:
                            counter_for_logging = 0
                            log_message = (
                                &#34;#monitor_current_session method has been verifying if this session is active &#34;
                                f&#34;(session: {session_id}, logging interval: {logging_interval})&#34;
                            )
                            self.logger.debug(log_message)

                    await asyncio.sleep(self.ping_interval)

                    if session is not None and session.closed is False:
                        t = time.time()
                        if self.last_ping_pong_time is None:
                            self.last_ping_pong_time = float(t)
                        try:
                            await session.ping(f&#34;sdk-ping-pong:{t}&#34;)
                        except Exception as e:
                            # The ping() method can fail for some reason.
                            # To establish a new connection even in this scenario,
                            # we ignore the exception here.
                            self.logger.warning(f&#34;Failed to send a ping message ({session_id}): {e}&#34;)

                    if self.auto_reconnect_enabled:
                        should_reconnect = False
                        if session is None or session.closed:
                            self.logger.info(f&#34;The session ({session_id}) seems to be already closed. Reconnecting...&#34;)
                            should_reconnect = True

                        if await self.is_ping_pong_failing():
                            disconnected_seconds = int(time.time() - self.last_ping_pong_time)
                            self.logger.info(
                                f&#34;The session ({session_id}) seems to be stale. Reconnecting...&#34;
                                f&#34; reason: disconnected for {disconnected_seconds}+ seconds)&#34;
                            )
                            self.stale = True
                            self.last_ping_pong_time = None
                            should_reconnect = True

                        if should_reconnect is True or not await self.is_connected():
                            await self.connect_to_new_endpoint()

                except Exception as e:
                    self.logger.error(
                        f&#34;Failed to check the current session ({session_id}) or reconnect to the server &#34;
                        f&#34;(error: {type(e).__name__}, message: {e})&#34;
                    )
        except asyncio.CancelledError:
            if self.logger.level &lt;= logging.DEBUG:
                self.logger.debug(f&#34;The monitor_current_session task for {session_id} is now cancelled&#34;)
            raise

    async def receive_messages(self) -&gt; None:
        # In the asyncio runtime, accessing a shared object (self.current_session here) from
        # multiple tasks can cause race conditions and errors.
        # To avoid such, we access only the session that is active when this loop starts.
        session = self.current_session
        session_id = self.build_session_id(session)
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;A new receive_messages() execution loop with {session_id} started&#34;)
        try:
            consecutive_error_count = 0
            logging_interval = 100
            counter_for_logging = 0

            while not self.closed:
                if session != self.current_session:
                    if self.logger.level &lt;= logging.DEBUG:
                        self.logger.debug(f&#34;The running receive_messages task for {session_id} is now cancelled&#34;)
                    break
                try:
                    message: WSMessage = await session.receive()
                    # just in case, checking if the value is not None
                    if message is not None:
                        if self.logger.level &lt;= logging.DEBUG:
                            # The following logging prints every single received message
                            # except empty message data ones.
                            m_type = WSMsgType(message.type)
                            message_type = m_type.name if m_type is not None else message.type
                            message_data = message.data
                            if isinstance(message_data, bytes):
                                message_data = message_data.decode(&#34;utf-8&#34;)
                            if message_data is not None and len(message_data) &gt; 0:
                                # To skip the empty message that Slack server-side often sends
                                self.logger.debug(
                                    f&#34;Received message &#34;
                                    f&#34;(type: {message_type}, &#34;
                                    f&#34;data: {message_data}, &#34;
                                    f&#34;extra: {message.extra}, &#34;
                                    f&#34;session: {session_id})&#34;
                                )

                            if self.trace_enabled:
                                # The logging here is for detailed trouble shooting of potential issues in this client.
                                # If you don&#39;t see this log for a while, it can mean that
                                # this receive_messages execution is no longer working for some reason.
                                counter_for_logging += 1
                                if counter_for_logging &gt;= logging_interval:
                                    counter_for_logging = 0
                                    log_message = (
                                        &#34;#receive_messages method has been working without any issues &#34;
                                        f&#34;(session: {session_id}, logging interval: {logging_interval})&#34;
                                    )
                                    self.logger.debug(log_message)

                        if message.type == WSMsgType.TEXT:
                            message_data = message.data
                            await self.enqueue_message(message_data)
                            for listener in self.on_message_listeners:
                                await listener(message)
                        elif message.type == WSMsgType.CLOSE:
                            if self.auto_reconnect_enabled:
                                self.logger.info(f&#34;Received CLOSE event from {session_id}. Reconnecting...&#34;)
                                await self.connect_to_new_endpoint()
                            for listener in self.on_close_listeners:
                                await listener(message)
                        elif message.type == WSMsgType.ERROR:
                            for listener in self.on_error_listeners:
                                await listener(message)
                        elif message.type == WSMsgType.CLOSED:
                            await asyncio.sleep(self.ping_interval)
                            continue
                        elif message.type == WSMsgType.PING:
                            await session.pong(message.data)
                            continue
                        elif message.type == WSMsgType.PONG:
                            if message.data is not None:
                                str_message_data = message.data.decode(&#34;utf-8&#34;)
                                elements = str_message_data.split(&#34;:&#34;)
                                if len(elements) == 2 and elements[0] == &#34;sdk-ping-pong&#34;:
                                    try:
                                        self.last_ping_pong_time = float(elements[1])
                                    except Exception as e:
                                        self.logger.warning(
                                            f&#34;Failed to parse the last_ping_pong_time value from {str_message_data}&#34;
                                            f&#34; - error : {e}, session: {session_id}&#34;
                                        )
                            continue

                    consecutive_error_count = 0

                except Exception as e:
                    consecutive_error_count += 1
                    self.logger.error(f&#34;Failed to receive or enqueue a message: {type(e).__name__}, {e} ({session_id})&#34;)
                    if isinstance(e, ClientConnectionError):
                        await asyncio.sleep(self.ping_interval)
                    else:
                        await asyncio.sleep(consecutive_error_count)
        except asyncio.CancelledError:
            if self.logger.level &lt;= logging.DEBUG:
                self.logger.debug(f&#34;The running receive_messages task for {session_id} is now cancelled&#34;)
            raise

    async def is_ping_pong_failing(self) -&gt; bool:
        if self.last_ping_pong_time is None:
            return False
        disconnected_seconds = int(time.time() - self.last_ping_pong_time)
        return disconnected_seconds &gt;= (self.ping_interval * 4)

    async def is_connected(self) -&gt; bool:
        connected: bool = (
            not self.closed
            and not self.stale
            and self.current_session is not None
            and not self.current_session.closed
            and not await self.is_ping_pong_failing()
        )
        if self.logger.level &lt;= logging.DEBUG and connected is False:
            # Prints more detailed information about the inactive connection
            is_ping_pong_failing = await self.is_ping_pong_failing()
            session_id = await self.session_id()
            self.logger.debug(
                &#34;Inactive connection detected (&#34;
                f&#34;session_id: {session_id}, &#34;
                f&#34;closed: {self.closed}, &#34;
                f&#34;stale: {self.stale}, &#34;
                f&#34;current_session.closed: {self.current_session and self.current_session.closed}, &#34;
                f&#34;is_ping_pong_failing: {is_ping_pong_failing}&#34;
                &#34;)&#34;
            )
        return connected

    async def session_id(self) -&gt; str:
        return self.build_session_id(self.current_session)

    async def connect(self):
        # This loop is used to ensure when a new session is created,
        # a new monitor and a new message receiver are also created.
        # If a new session is created but we failed to create the new
        # monitor or the new message, we should try it.
        while True:
            try:
                old_session: Optional[ClientWebSocketResponse] = (
                    None if self.current_session is None else self.current_session
                )

                # If the old session is broken (e.g. reset by peer), it might fail to close it.
                # We don&#39;t want to retry when this kind of cases happen.
                try:
                    # We should close old session before create a new one. Because when disconnect
                    # reason is `too_many_websockets`, we need to close the old one first to
                    # to decrease the number of connections.
                    self.auto_reconnect_enabled = False
                    if old_session is not None:
                        await old_session.close()
                        old_session_id = self.build_session_id(old_session)
                        self.logger.info(f&#34;The old session ({old_session_id}) has been abandoned&#34;)
                except Exception as e:
                    self.logger.exception(f&#34;Failed to close the old session : {e}&#34;)

                if self.wss_uri is None:
                    # If the underlying WSS URL does not exist,
                    # acquiring a new active WSS URL from the server-side first
                    self.wss_uri = await self.issue_new_wss_url()

                self.current_session = await self.aiohttp_client_session.ws_connect(
                    self.wss_uri,
                    autoping=False,
                    heartbeat=self.ping_interval,
                    proxy=self.proxy,
                    ssl=self.web_client.ssl,
                )
                session_id: str = await self.session_id()
                self.auto_reconnect_enabled = self.default_auto_reconnect_enabled
                self.stale = False
                self.logger.info(f&#34;A new session ({session_id}) has been established&#34;)

                # The first ping from the new connection
                if self.logger.level &lt;= logging.DEBUG:
                    self.logger.debug(f&#34;Sending a ping message with the newly established connection ({session_id})...&#34;)
                t = time.time()
                await self.current_session.ping(f&#34;sdk-ping-pong:{t}&#34;)

                if self.current_session_monitor is not None:
                    self.current_session_monitor.cancel()
                self.current_session_monitor = asyncio.ensure_future(self.monitor_current_session())
                if self.logger.level &lt;= logging.DEBUG:
                    self.logger.debug(f&#34;A new monitor_current_session() executor has been recreated for {session_id}&#34;)

                if self.message_receiver is not None:
                    self.message_receiver.cancel()
                self.message_receiver = asyncio.ensure_future(self.receive_messages())
                if self.logger.level &lt;= logging.DEBUG:
                    self.logger.debug(f&#34;A new receive_messages() executor has been recreated for {session_id}&#34;)
                break
            except Exception as e:
                self.logger.exception(f&#34;Failed to connect (error: {e}); Retrying...&#34;)
                await asyncio.sleep(self.ping_interval)

    async def disconnect(self):
        if self.current_session is not None:
            await self.current_session.close()
        session_id = await self.session_id()
        self.logger.info(f&#34;The current session ({session_id}) has been abandoned by disconnect() method call&#34;)

    async def send_message(self, message: str):
        session_id = await self.session_id()
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;Sending a message: {message} from session: {session_id}&#34;)
        try:
            await self.current_session.send_str(message)
        except ConnectionError as e:
            # We rarely get this exception while replacing the underlying WebSocket connections.
            # We can do one more try here as the self.current_session should be ready now.
            if self.logger.level &lt;= logging.DEBUG:
                self.logger.debug(
                    f&#34;Failed to send a message (error: {e}, message: {message}, session: {session_id})&#34;
                    &#34; as the underlying connection was replaced. Retrying the same request only one time...&#34;
                )
            # Although acquiring self.connect_operation_lock also for the first method call is the safest way,
            # we avoid synchronizing a lot for better performance. That&#39;s why we are doing a retry here.
            try:
                await self.connect_operation_lock.acquire()
                if await self.is_connected():
                    await self.current_session.send_str(message)
                else:
                    self.logger.warning(
                        f&#34;The current session ({session_id}) is no longer active. &#34; &#34;Failed to send a message&#34;
                    )
                    raise e
            finally:
                if self.connect_operation_lock.locked() is True:
                    self.connect_operation_lock.release()

    async def close(self):
        self.closed = True
        self.auto_reconnect_enabled = False
        await self.disconnect()
        if self.message_processor is not None:
            self.message_processor.cancel()
        if self.current_session_monitor is not None:
            self.current_session_monitor.cancel()
        if self.message_receiver is not None:
            self.message_receiver.cancel()
        if self.aiohttp_client_session is not None:
            await self.aiohttp_client_session.close()

    @classmethod
    def build_session_id(cls, session: ClientWebSocketResponse) -&gt; str:
        if session is None:
            return &#34;&#34;
        return &#34;s_&#34; + str(hash(session))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient"><code class="flex name class">
<span>class <span class="ident">SocketModeClient</span></span>
<span>(</span><span>app_token:Â str, logger:Â Optional[logging.Logger]Â =Â None, web_client:Â Optional[<a title="slack_sdk.web.async_client.AsyncWebClient" href="../../web/async_client.html#slack_sdk.web.async_client.AsyncWebClient">AsyncWebClient</a>]Â =Â None, proxy:Â Optional[str]Â =Â None, auto_reconnect_enabled:Â boolÂ =Â True, ping_interval:Â floatÂ =Â 5, trace_enabled:Â boolÂ =Â False, on_message_listeners:Â Optional[List[Callable[[aiohttp.http_websocket.WSMessage],Â Awaitable[None]]]]Â =Â None, on_error_listeners:Â Optional[List[Callable[[aiohttp.http_websocket.WSMessage],Â Awaitable[None]]]]Â =Â None, on_close_listeners:Â Optional[List[Callable[[aiohttp.http_websocket.WSMessage],Â Awaitable[None]]]]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Socket Mode client</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>app_token</code></strong></dt>
<dd>App-level token</dd>
<dt><strong><code>logger</code></strong></dt>
<dd>Custom logger</dd>
<dt><strong><code>web_client</code></strong></dt>
<dd>Web API client</dd>
<dt><strong><code>auto_reconnect_enabled</code></strong></dt>
<dd>True if automatic reconnection is enabled (default: True)</dd>
<dt><strong><code>ping_interval</code></strong></dt>
<dd>interval for ping-pong with Slack servers (seconds)</dd>
<dt><strong><code>trace_enabled</code></strong></dt>
<dd>True if more verbose logs to see what's happening under the hood</dd>
<dt><strong><code>proxy</code></strong></dt>
<dd>the HTTP proxy URL</dd>
<dt><strong><code>on_message_listeners</code></strong></dt>
<dd>listener functions for on_message</dd>
<dt><strong><code>on_error_listeners</code></strong></dt>
<dd>listener functions for on_error</dd>
<dt><strong><code>on_close_listeners</code></strong></dt>
<dd>listener functions for on_close</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SocketModeClient(AsyncBaseSocketModeClient):
    logger: Logger
    web_client: AsyncWebClient
    app_token: str
    wss_uri: Optional[str]
    auto_reconnect_enabled: bool
    message_queue: Queue
    message_listeners: List[
        Union[
            AsyncWebSocketMessageListener,
            Callable[[&#34;AsyncBaseSocketModeClient&#34;, dict, Optional[str]], Awaitable[None]],
        ]
    ]
    socket_mode_request_listeners: List[
        Union[
            AsyncSocketModeRequestListener,
            Callable[[&#34;AsyncBaseSocketModeClient&#34;, SocketModeRequest], Awaitable[None]],
        ]
    ]

    message_receiver: Optional[Future]
    message_processor: Future

    proxy: Optional[str]
    ping_interval: float
    trace_enabled: bool

    last_ping_pong_time: Optional[float]
    current_session: Optional[ClientWebSocketResponse]
    current_session_monitor: Optional[Future]

    auto_reconnect_enabled: bool
    default_auto_reconnect_enabled: bool
    closed: bool
    stale: bool
    connect_operation_lock: Lock

    on_message_listeners: List[Callable[[WSMessage], Awaitable[None]]]
    on_error_listeners: List[Callable[[WSMessage], Awaitable[None]]]
    on_close_listeners: List[Callable[[WSMessage], Awaitable[None]]]

    def __init__(
        self,
        app_token: str,
        logger: Optional[Logger] = None,
        web_client: Optional[AsyncWebClient] = None,
        proxy: Optional[str] = None,
        auto_reconnect_enabled: bool = True,
        ping_interval: float = 5,
        trace_enabled: bool = False,
        on_message_listeners: Optional[List[Callable[[WSMessage], Awaitable[None]]]] = None,
        on_error_listeners: Optional[List[Callable[[WSMessage], Awaitable[None]]]] = None,
        on_close_listeners: Optional[List[Callable[[WSMessage], Awaitable[None]]]] = None,
    ):
        &#34;&#34;&#34;Socket Mode client

        Args:
            app_token: App-level token
            logger: Custom logger
            web_client: Web API client
            auto_reconnect_enabled: True if automatic reconnection is enabled (default: True)
            ping_interval: interval for ping-pong with Slack servers (seconds)
            trace_enabled: True if more verbose logs to see what&#39;s happening under the hood
            proxy: the HTTP proxy URL
            on_message_listeners: listener functions for on_message
            on_error_listeners: listener functions for on_error
            on_close_listeners: listener functions for on_close
        &#34;&#34;&#34;
        self.app_token = app_token
        self.logger = logger or logging.getLogger(__name__)
        self.web_client = web_client or AsyncWebClient()
        self.closed = False
        self.stale = False
        self.connect_operation_lock = Lock()
        self.proxy = proxy
        if self.proxy is None or len(self.proxy.strip()) == 0:
            env_variable = load_http_proxy_from_env(self.logger)
            if env_variable is not None:
                self.proxy = env_variable

        self.default_auto_reconnect_enabled = auto_reconnect_enabled
        self.auto_reconnect_enabled = self.default_auto_reconnect_enabled
        self.ping_interval = ping_interval
        self.trace_enabled = trace_enabled
        self.last_ping_pong_time = None

        self.wss_uri = None
        self.message_queue = Queue()
        self.message_listeners = []
        self.socket_mode_request_listeners = []
        self.current_session = None
        self.current_session_monitor = None

        # https://docs.aiohttp.org/en/stable/client_reference.html
        # Unless you are connecting to a large, unknown number of different servers
        # over the lifetime of your application,
        # it is suggested you use a single session for the lifetime of your application
        # to benefit from connection pooling.
        self.aiohttp_client_session = aiohttp.ClientSession()

        self.on_message_listeners = on_message_listeners or []
        self.on_error_listeners = on_error_listeners or []
        self.on_close_listeners = on_close_listeners or []

        self.message_receiver = None
        self.message_processor = asyncio.ensure_future(self.process_messages())

    async def monitor_current_session(self) -&gt; None:
        # In the asyncio runtime, accessing a shared object (self.current_session here) from
        # multiple tasks can cause race conditions and errors.
        # To avoid such, we access only the session that is active when this loop starts.
        session: ClientWebSocketResponse = self.current_session
        session_id: str = self.build_session_id(session)

        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;A new monitor_current_session() execution loop for {session_id} started&#34;)
        try:
            logging_interval = 100
            counter_for_logging = 0

            while not self.closed:
                if session != self.current_session:
                    if self.logger.level &lt;= logging.DEBUG:
                        self.logger.debug(f&#34;The monitor_current_session task for {session_id} is now cancelled&#34;)
                    break
                try:
                    if self.trace_enabled and self.logger.level &lt;= logging.DEBUG:
                        # The logging here is for detailed investigation on potential issues in this client.
                        # If you don&#39;t see this log for a while, it means that
                        # this receive_messages execution is no longer working for some reason.
                        counter_for_logging += 1
                        if counter_for_logging &gt;= logging_interval:
                            counter_for_logging = 0
                            log_message = (
                                &#34;#monitor_current_session method has been verifying if this session is active &#34;
                                f&#34;(session: {session_id}, logging interval: {logging_interval})&#34;
                            )
                            self.logger.debug(log_message)

                    await asyncio.sleep(self.ping_interval)

                    if session is not None and session.closed is False:
                        t = time.time()
                        if self.last_ping_pong_time is None:
                            self.last_ping_pong_time = float(t)
                        try:
                            await session.ping(f&#34;sdk-ping-pong:{t}&#34;)
                        except Exception as e:
                            # The ping() method can fail for some reason.
                            # To establish a new connection even in this scenario,
                            # we ignore the exception here.
                            self.logger.warning(f&#34;Failed to send a ping message ({session_id}): {e}&#34;)

                    if self.auto_reconnect_enabled:
                        should_reconnect = False
                        if session is None or session.closed:
                            self.logger.info(f&#34;The session ({session_id}) seems to be already closed. Reconnecting...&#34;)
                            should_reconnect = True

                        if await self.is_ping_pong_failing():
                            disconnected_seconds = int(time.time() - self.last_ping_pong_time)
                            self.logger.info(
                                f&#34;The session ({session_id}) seems to be stale. Reconnecting...&#34;
                                f&#34; reason: disconnected for {disconnected_seconds}+ seconds)&#34;
                            )
                            self.stale = True
                            self.last_ping_pong_time = None
                            should_reconnect = True

                        if should_reconnect is True or not await self.is_connected():
                            await self.connect_to_new_endpoint()

                except Exception as e:
                    self.logger.error(
                        f&#34;Failed to check the current session ({session_id}) or reconnect to the server &#34;
                        f&#34;(error: {type(e).__name__}, message: {e})&#34;
                    )
        except asyncio.CancelledError:
            if self.logger.level &lt;= logging.DEBUG:
                self.logger.debug(f&#34;The monitor_current_session task for {session_id} is now cancelled&#34;)
            raise

    async def receive_messages(self) -&gt; None:
        # In the asyncio runtime, accessing a shared object (self.current_session here) from
        # multiple tasks can cause race conditions and errors.
        # To avoid such, we access only the session that is active when this loop starts.
        session = self.current_session
        session_id = self.build_session_id(session)
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;A new receive_messages() execution loop with {session_id} started&#34;)
        try:
            consecutive_error_count = 0
            logging_interval = 100
            counter_for_logging = 0

            while not self.closed:
                if session != self.current_session:
                    if self.logger.level &lt;= logging.DEBUG:
                        self.logger.debug(f&#34;The running receive_messages task for {session_id} is now cancelled&#34;)
                    break
                try:
                    message: WSMessage = await session.receive()
                    # just in case, checking if the value is not None
                    if message is not None:
                        if self.logger.level &lt;= logging.DEBUG:
                            # The following logging prints every single received message
                            # except empty message data ones.
                            m_type = WSMsgType(message.type)
                            message_type = m_type.name if m_type is not None else message.type
                            message_data = message.data
                            if isinstance(message_data, bytes):
                                message_data = message_data.decode(&#34;utf-8&#34;)
                            if message_data is not None and len(message_data) &gt; 0:
                                # To skip the empty message that Slack server-side often sends
                                self.logger.debug(
                                    f&#34;Received message &#34;
                                    f&#34;(type: {message_type}, &#34;
                                    f&#34;data: {message_data}, &#34;
                                    f&#34;extra: {message.extra}, &#34;
                                    f&#34;session: {session_id})&#34;
                                )

                            if self.trace_enabled:
                                # The logging here is for detailed trouble shooting of potential issues in this client.
                                # If you don&#39;t see this log for a while, it can mean that
                                # this receive_messages execution is no longer working for some reason.
                                counter_for_logging += 1
                                if counter_for_logging &gt;= logging_interval:
                                    counter_for_logging = 0
                                    log_message = (
                                        &#34;#receive_messages method has been working without any issues &#34;
                                        f&#34;(session: {session_id}, logging interval: {logging_interval})&#34;
                                    )
                                    self.logger.debug(log_message)

                        if message.type == WSMsgType.TEXT:
                            message_data = message.data
                            await self.enqueue_message(message_data)
                            for listener in self.on_message_listeners:
                                await listener(message)
                        elif message.type == WSMsgType.CLOSE:
                            if self.auto_reconnect_enabled:
                                self.logger.info(f&#34;Received CLOSE event from {session_id}. Reconnecting...&#34;)
                                await self.connect_to_new_endpoint()
                            for listener in self.on_close_listeners:
                                await listener(message)
                        elif message.type == WSMsgType.ERROR:
                            for listener in self.on_error_listeners:
                                await listener(message)
                        elif message.type == WSMsgType.CLOSED:
                            await asyncio.sleep(self.ping_interval)
                            continue
                        elif message.type == WSMsgType.PING:
                            await session.pong(message.data)
                            continue
                        elif message.type == WSMsgType.PONG:
                            if message.data is not None:
                                str_message_data = message.data.decode(&#34;utf-8&#34;)
                                elements = str_message_data.split(&#34;:&#34;)
                                if len(elements) == 2 and elements[0] == &#34;sdk-ping-pong&#34;:
                                    try:
                                        self.last_ping_pong_time = float(elements[1])
                                    except Exception as e:
                                        self.logger.warning(
                                            f&#34;Failed to parse the last_ping_pong_time value from {str_message_data}&#34;
                                            f&#34; - error : {e}, session: {session_id}&#34;
                                        )
                            continue

                    consecutive_error_count = 0

                except Exception as e:
                    consecutive_error_count += 1
                    self.logger.error(f&#34;Failed to receive or enqueue a message: {type(e).__name__}, {e} ({session_id})&#34;)
                    if isinstance(e, ClientConnectionError):
                        await asyncio.sleep(self.ping_interval)
                    else:
                        await asyncio.sleep(consecutive_error_count)
        except asyncio.CancelledError:
            if self.logger.level &lt;= logging.DEBUG:
                self.logger.debug(f&#34;The running receive_messages task for {session_id} is now cancelled&#34;)
            raise

    async def is_ping_pong_failing(self) -&gt; bool:
        if self.last_ping_pong_time is None:
            return False
        disconnected_seconds = int(time.time() - self.last_ping_pong_time)
        return disconnected_seconds &gt;= (self.ping_interval * 4)

    async def is_connected(self) -&gt; bool:
        connected: bool = (
            not self.closed
            and not self.stale
            and self.current_session is not None
            and not self.current_session.closed
            and not await self.is_ping_pong_failing()
        )
        if self.logger.level &lt;= logging.DEBUG and connected is False:
            # Prints more detailed information about the inactive connection
            is_ping_pong_failing = await self.is_ping_pong_failing()
            session_id = await self.session_id()
            self.logger.debug(
                &#34;Inactive connection detected (&#34;
                f&#34;session_id: {session_id}, &#34;
                f&#34;closed: {self.closed}, &#34;
                f&#34;stale: {self.stale}, &#34;
                f&#34;current_session.closed: {self.current_session and self.current_session.closed}, &#34;
                f&#34;is_ping_pong_failing: {is_ping_pong_failing}&#34;
                &#34;)&#34;
            )
        return connected

    async def session_id(self) -&gt; str:
        return self.build_session_id(self.current_session)

    async def connect(self):
        # This loop is used to ensure when a new session is created,
        # a new monitor and a new message receiver are also created.
        # If a new session is created but we failed to create the new
        # monitor or the new message, we should try it.
        while True:
            try:
                old_session: Optional[ClientWebSocketResponse] = (
                    None if self.current_session is None else self.current_session
                )

                # If the old session is broken (e.g. reset by peer), it might fail to close it.
                # We don&#39;t want to retry when this kind of cases happen.
                try:
                    # We should close old session before create a new one. Because when disconnect
                    # reason is `too_many_websockets`, we need to close the old one first to
                    # to decrease the number of connections.
                    self.auto_reconnect_enabled = False
                    if old_session is not None:
                        await old_session.close()
                        old_session_id = self.build_session_id(old_session)
                        self.logger.info(f&#34;The old session ({old_session_id}) has been abandoned&#34;)
                except Exception as e:
                    self.logger.exception(f&#34;Failed to close the old session : {e}&#34;)

                if self.wss_uri is None:
                    # If the underlying WSS URL does not exist,
                    # acquiring a new active WSS URL from the server-side first
                    self.wss_uri = await self.issue_new_wss_url()

                self.current_session = await self.aiohttp_client_session.ws_connect(
                    self.wss_uri,
                    autoping=False,
                    heartbeat=self.ping_interval,
                    proxy=self.proxy,
                    ssl=self.web_client.ssl,
                )
                session_id: str = await self.session_id()
                self.auto_reconnect_enabled = self.default_auto_reconnect_enabled
                self.stale = False
                self.logger.info(f&#34;A new session ({session_id}) has been established&#34;)

                # The first ping from the new connection
                if self.logger.level &lt;= logging.DEBUG:
                    self.logger.debug(f&#34;Sending a ping message with the newly established connection ({session_id})...&#34;)
                t = time.time()
                await self.current_session.ping(f&#34;sdk-ping-pong:{t}&#34;)

                if self.current_session_monitor is not None:
                    self.current_session_monitor.cancel()
                self.current_session_monitor = asyncio.ensure_future(self.monitor_current_session())
                if self.logger.level &lt;= logging.DEBUG:
                    self.logger.debug(f&#34;A new monitor_current_session() executor has been recreated for {session_id}&#34;)

                if self.message_receiver is not None:
                    self.message_receiver.cancel()
                self.message_receiver = asyncio.ensure_future(self.receive_messages())
                if self.logger.level &lt;= logging.DEBUG:
                    self.logger.debug(f&#34;A new receive_messages() executor has been recreated for {session_id}&#34;)
                break
            except Exception as e:
                self.logger.exception(f&#34;Failed to connect (error: {e}); Retrying...&#34;)
                await asyncio.sleep(self.ping_interval)

    async def disconnect(self):
        if self.current_session is not None:
            await self.current_session.close()
        session_id = await self.session_id()
        self.logger.info(f&#34;The current session ({session_id}) has been abandoned by disconnect() method call&#34;)

    async def send_message(self, message: str):
        session_id = await self.session_id()
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;Sending a message: {message} from session: {session_id}&#34;)
        try:
            await self.current_session.send_str(message)
        except ConnectionError as e:
            # We rarely get this exception while replacing the underlying WebSocket connections.
            # We can do one more try here as the self.current_session should be ready now.
            if self.logger.level &lt;= logging.DEBUG:
                self.logger.debug(
                    f&#34;Failed to send a message (error: {e}, message: {message}, session: {session_id})&#34;
                    &#34; as the underlying connection was replaced. Retrying the same request only one time...&#34;
                )
            # Although acquiring self.connect_operation_lock also for the first method call is the safest way,
            # we avoid synchronizing a lot for better performance. That&#39;s why we are doing a retry here.
            try:
                await self.connect_operation_lock.acquire()
                if await self.is_connected():
                    await self.current_session.send_str(message)
                else:
                    self.logger.warning(
                        f&#34;The current session ({session_id}) is no longer active. &#34; &#34;Failed to send a message&#34;
                    )
                    raise e
            finally:
                if self.connect_operation_lock.locked() is True:
                    self.connect_operation_lock.release()

    async def close(self):
        self.closed = True
        self.auto_reconnect_enabled = False
        await self.disconnect()
        if self.message_processor is not None:
            self.message_processor.cancel()
        if self.current_session_monitor is not None:
            self.current_session_monitor.cancel()
        if self.message_receiver is not None:
            self.message_receiver.cancel()
        if self.aiohttp_client_session is not None:
            await self.aiohttp_client_session.close()

    @classmethod
    def build_session_id(cls, session: ClientWebSocketResponse) -&gt; str:
        if session is None:
            return &#34;&#34;
        return &#34;s_&#34; + str(hash(session))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="slack_sdk.socket_mode.async_client.AsyncBaseSocketModeClient" href="../async_client.html#slack_sdk.socket_mode.async_client.AsyncBaseSocketModeClient">AsyncBaseSocketModeClient</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.app_token"><code class="name">var <span class="ident">app_token</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.auto_reconnect_enabled"><code class="name">var <span class="ident">auto_reconnect_enabled</span> :Â bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.closed"><code class="name">var <span class="ident">closed</span> :Â bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.connect_operation_lock"><code class="name">var <span class="ident">connect_operation_lock</span> :Â asyncio.locks.Lock</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.current_session"><code class="name">var <span class="ident">current_session</span> :Â Optional[aiohttp.client_ws.ClientWebSocketResponse]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.current_session_monitor"><code class="name">var <span class="ident">current_session_monitor</span> :Â Optional[_asyncio.Future]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.default_auto_reconnect_enabled"><code class="name">var <span class="ident">default_auto_reconnect_enabled</span> :Â bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.last_ping_pong_time"><code class="name">var <span class="ident">last_ping_pong_time</span> :Â Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.logger"><code class="name">var <span class="ident">logger</span> :Â logging.Logger</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.message_listeners"><code class="name">var <span class="ident">message_listeners</span> :Â List[Union[<a title="slack_sdk.socket_mode.async_listeners.AsyncWebSocketMessageListener" href="../async_listeners.html#slack_sdk.socket_mode.async_listeners.AsyncWebSocketMessageListener">AsyncWebSocketMessageListener</a>,Â Callable[[<a title="slack_sdk.socket_mode.async_client.AsyncBaseSocketModeClient" href="../async_client.html#slack_sdk.socket_mode.async_client.AsyncBaseSocketModeClient">AsyncBaseSocketModeClient</a>,Â dict,Â Optional[str]],Â Awaitable[None]]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.message_processor"><code class="name">var <span class="ident">message_processor</span> :Â _asyncio.Future</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.message_queue"><code class="name">var <span class="ident">message_queue</span> :Â asyncio.queues.Queue</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.message_receiver"><code class="name">var <span class="ident">message_receiver</span> :Â Optional[_asyncio.Future]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.on_close_listeners"><code class="name">var <span class="ident">on_close_listeners</span> :Â List[Callable[[aiohttp.http_websocket.WSMessage],Â Awaitable[None]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.on_error_listeners"><code class="name">var <span class="ident">on_error_listeners</span> :Â List[Callable[[aiohttp.http_websocket.WSMessage],Â Awaitable[None]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.on_message_listeners"><code class="name">var <span class="ident">on_message_listeners</span> :Â List[Callable[[aiohttp.http_websocket.WSMessage],Â Awaitable[None]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.ping_interval"><code class="name">var <span class="ident">ping_interval</span> :Â float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.proxy"><code class="name">var <span class="ident">proxy</span> :Â Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.socket_mode_request_listeners"><code class="name">var <span class="ident">socket_mode_request_listeners</span> :Â List[Union[<a title="slack_sdk.socket_mode.async_listeners.AsyncSocketModeRequestListener" href="../async_listeners.html#slack_sdk.socket_mode.async_listeners.AsyncSocketModeRequestListener">AsyncSocketModeRequestListener</a>,Â Callable[[<a title="slack_sdk.socket_mode.async_client.AsyncBaseSocketModeClient" href="../async_client.html#slack_sdk.socket_mode.async_client.AsyncBaseSocketModeClient">AsyncBaseSocketModeClient</a>,Â <a title="slack_sdk.socket_mode.request.SocketModeRequest" href="../request.html#slack_sdk.socket_mode.request.SocketModeRequest">SocketModeRequest</a>],Â Awaitable[None]]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.stale"><code class="name">var <span class="ident">stale</span> :Â bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.trace_enabled"><code class="name">var <span class="ident">trace_enabled</span> :Â bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.web_client"><code class="name">var <span class="ident">web_client</span> :Â <a title="slack_sdk.web.async_client.AsyncWebClient" href="../../web/async_client.html#slack_sdk.web.async_client.AsyncWebClient">AsyncWebClient</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.wss_uri"><code class="name">var <span class="ident">wss_uri</span> :Â Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.build_session_id"><code class="name flex">
<span>def <span class="ident">build_session_id</span></span>(<span>session:Â aiohttp.client_ws.ClientWebSocketResponse) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def build_session_id(cls, session: ClientWebSocketResponse) -&gt; str:
    if session is None:
        return &#34;&#34;
    return &#34;s_&#34; + str(hash(session))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.close"><code class="name flex">
<span>async def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def close(self):
    self.closed = True
    self.auto_reconnect_enabled = False
    await self.disconnect()
    if self.message_processor is not None:
        self.message_processor.cancel()
    if self.current_session_monitor is not None:
        self.current_session_monitor.cancel()
    if self.message_receiver is not None:
        self.message_receiver.cancel()
    if self.aiohttp_client_session is not None:
        await self.aiohttp_client_session.close()</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.connect"><code class="name flex">
<span>async def <span class="ident">connect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def connect(self):
    # This loop is used to ensure when a new session is created,
    # a new monitor and a new message receiver are also created.
    # If a new session is created but we failed to create the new
    # monitor or the new message, we should try it.
    while True:
        try:
            old_session: Optional[ClientWebSocketResponse] = (
                None if self.current_session is None else self.current_session
            )

            # If the old session is broken (e.g. reset by peer), it might fail to close it.
            # We don&#39;t want to retry when this kind of cases happen.
            try:
                # We should close old session before create a new one. Because when disconnect
                # reason is `too_many_websockets`, we need to close the old one first to
                # to decrease the number of connections.
                self.auto_reconnect_enabled = False
                if old_session is not None:
                    await old_session.close()
                    old_session_id = self.build_session_id(old_session)
                    self.logger.info(f&#34;The old session ({old_session_id}) has been abandoned&#34;)
            except Exception as e:
                self.logger.exception(f&#34;Failed to close the old session : {e}&#34;)

            if self.wss_uri is None:
                # If the underlying WSS URL does not exist,
                # acquiring a new active WSS URL from the server-side first
                self.wss_uri = await self.issue_new_wss_url()

            self.current_session = await self.aiohttp_client_session.ws_connect(
                self.wss_uri,
                autoping=False,
                heartbeat=self.ping_interval,
                proxy=self.proxy,
                ssl=self.web_client.ssl,
            )
            session_id: str = await self.session_id()
            self.auto_reconnect_enabled = self.default_auto_reconnect_enabled
            self.stale = False
            self.logger.info(f&#34;A new session ({session_id}) has been established&#34;)

            # The first ping from the new connection
            if self.logger.level &lt;= logging.DEBUG:
                self.logger.debug(f&#34;Sending a ping message with the newly established connection ({session_id})...&#34;)
            t = time.time()
            await self.current_session.ping(f&#34;sdk-ping-pong:{t}&#34;)

            if self.current_session_monitor is not None:
                self.current_session_monitor.cancel()
            self.current_session_monitor = asyncio.ensure_future(self.monitor_current_session())
            if self.logger.level &lt;= logging.DEBUG:
                self.logger.debug(f&#34;A new monitor_current_session() executor has been recreated for {session_id}&#34;)

            if self.message_receiver is not None:
                self.message_receiver.cancel()
            self.message_receiver = asyncio.ensure_future(self.receive_messages())
            if self.logger.level &lt;= logging.DEBUG:
                self.logger.debug(f&#34;A new receive_messages() executor has been recreated for {session_id}&#34;)
            break
        except Exception as e:
            self.logger.exception(f&#34;Failed to connect (error: {e}); Retrying...&#34;)
            await asyncio.sleep(self.ping_interval)</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.disconnect"><code class="name flex">
<span>async def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def disconnect(self):
    if self.current_session is not None:
        await self.current_session.close()
    session_id = await self.session_id()
    self.logger.info(f&#34;The current session ({session_id}) has been abandoned by disconnect() method call&#34;)</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.is_connected"><code class="name flex">
<span>async def <span class="ident">is_connected</span></span>(<span>self) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def is_connected(self) -&gt; bool:
    connected: bool = (
        not self.closed
        and not self.stale
        and self.current_session is not None
        and not self.current_session.closed
        and not await self.is_ping_pong_failing()
    )
    if self.logger.level &lt;= logging.DEBUG and connected is False:
        # Prints more detailed information about the inactive connection
        is_ping_pong_failing = await self.is_ping_pong_failing()
        session_id = await self.session_id()
        self.logger.debug(
            &#34;Inactive connection detected (&#34;
            f&#34;session_id: {session_id}, &#34;
            f&#34;closed: {self.closed}, &#34;
            f&#34;stale: {self.stale}, &#34;
            f&#34;current_session.closed: {self.current_session and self.current_session.closed}, &#34;
            f&#34;is_ping_pong_failing: {is_ping_pong_failing}&#34;
            &#34;)&#34;
        )
    return connected</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.is_ping_pong_failing"><code class="name flex">
<span>async def <span class="ident">is_ping_pong_failing</span></span>(<span>self) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def is_ping_pong_failing(self) -&gt; bool:
    if self.last_ping_pong_time is None:
        return False
    disconnected_seconds = int(time.time() - self.last_ping_pong_time)
    return disconnected_seconds &gt;= (self.ping_interval * 4)</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.monitor_current_session"><code class="name flex">
<span>async def <span class="ident">monitor_current_session</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def monitor_current_session(self) -&gt; None:
    # In the asyncio runtime, accessing a shared object (self.current_session here) from
    # multiple tasks can cause race conditions and errors.
    # To avoid such, we access only the session that is active when this loop starts.
    session: ClientWebSocketResponse = self.current_session
    session_id: str = self.build_session_id(session)

    if self.logger.level &lt;= logging.DEBUG:
        self.logger.debug(f&#34;A new monitor_current_session() execution loop for {session_id} started&#34;)
    try:
        logging_interval = 100
        counter_for_logging = 0

        while not self.closed:
            if session != self.current_session:
                if self.logger.level &lt;= logging.DEBUG:
                    self.logger.debug(f&#34;The monitor_current_session task for {session_id} is now cancelled&#34;)
                break
            try:
                if self.trace_enabled and self.logger.level &lt;= logging.DEBUG:
                    # The logging here is for detailed investigation on potential issues in this client.
                    # If you don&#39;t see this log for a while, it means that
                    # this receive_messages execution is no longer working for some reason.
                    counter_for_logging += 1
                    if counter_for_logging &gt;= logging_interval:
                        counter_for_logging = 0
                        log_message = (
                            &#34;#monitor_current_session method has been verifying if this session is active &#34;
                            f&#34;(session: {session_id}, logging interval: {logging_interval})&#34;
                        )
                        self.logger.debug(log_message)

                await asyncio.sleep(self.ping_interval)

                if session is not None and session.closed is False:
                    t = time.time()
                    if self.last_ping_pong_time is None:
                        self.last_ping_pong_time = float(t)
                    try:
                        await session.ping(f&#34;sdk-ping-pong:{t}&#34;)
                    except Exception as e:
                        # The ping() method can fail for some reason.
                        # To establish a new connection even in this scenario,
                        # we ignore the exception here.
                        self.logger.warning(f&#34;Failed to send a ping message ({session_id}): {e}&#34;)

                if self.auto_reconnect_enabled:
                    should_reconnect = False
                    if session is None or session.closed:
                        self.logger.info(f&#34;The session ({session_id}) seems to be already closed. Reconnecting...&#34;)
                        should_reconnect = True

                    if await self.is_ping_pong_failing():
                        disconnected_seconds = int(time.time() - self.last_ping_pong_time)
                        self.logger.info(
                            f&#34;The session ({session_id}) seems to be stale. Reconnecting...&#34;
                            f&#34; reason: disconnected for {disconnected_seconds}+ seconds)&#34;
                        )
                        self.stale = True
                        self.last_ping_pong_time = None
                        should_reconnect = True

                    if should_reconnect is True or not await self.is_connected():
                        await self.connect_to_new_endpoint()

            except Exception as e:
                self.logger.error(
                    f&#34;Failed to check the current session ({session_id}) or reconnect to the server &#34;
                    f&#34;(error: {type(e).__name__}, message: {e})&#34;
                )
    except asyncio.CancelledError:
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;The monitor_current_session task for {session_id} is now cancelled&#34;)
        raise</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.receive_messages"><code class="name flex">
<span>async def <span class="ident">receive_messages</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def receive_messages(self) -&gt; None:
    # In the asyncio runtime, accessing a shared object (self.current_session here) from
    # multiple tasks can cause race conditions and errors.
    # To avoid such, we access only the session that is active when this loop starts.
    session = self.current_session
    session_id = self.build_session_id(session)
    if self.logger.level &lt;= logging.DEBUG:
        self.logger.debug(f&#34;A new receive_messages() execution loop with {session_id} started&#34;)
    try:
        consecutive_error_count = 0
        logging_interval = 100
        counter_for_logging = 0

        while not self.closed:
            if session != self.current_session:
                if self.logger.level &lt;= logging.DEBUG:
                    self.logger.debug(f&#34;The running receive_messages task for {session_id} is now cancelled&#34;)
                break
            try:
                message: WSMessage = await session.receive()
                # just in case, checking if the value is not None
                if message is not None:
                    if self.logger.level &lt;= logging.DEBUG:
                        # The following logging prints every single received message
                        # except empty message data ones.
                        m_type = WSMsgType(message.type)
                        message_type = m_type.name if m_type is not None else message.type
                        message_data = message.data
                        if isinstance(message_data, bytes):
                            message_data = message_data.decode(&#34;utf-8&#34;)
                        if message_data is not None and len(message_data) &gt; 0:
                            # To skip the empty message that Slack server-side often sends
                            self.logger.debug(
                                f&#34;Received message &#34;
                                f&#34;(type: {message_type}, &#34;
                                f&#34;data: {message_data}, &#34;
                                f&#34;extra: {message.extra}, &#34;
                                f&#34;session: {session_id})&#34;
                            )

                        if self.trace_enabled:
                            # The logging here is for detailed trouble shooting of potential issues in this client.
                            # If you don&#39;t see this log for a while, it can mean that
                            # this receive_messages execution is no longer working for some reason.
                            counter_for_logging += 1
                            if counter_for_logging &gt;= logging_interval:
                                counter_for_logging = 0
                                log_message = (
                                    &#34;#receive_messages method has been working without any issues &#34;
                                    f&#34;(session: {session_id}, logging interval: {logging_interval})&#34;
                                )
                                self.logger.debug(log_message)

                    if message.type == WSMsgType.TEXT:
                        message_data = message.data
                        await self.enqueue_message(message_data)
                        for listener in self.on_message_listeners:
                            await listener(message)
                    elif message.type == WSMsgType.CLOSE:
                        if self.auto_reconnect_enabled:
                            self.logger.info(f&#34;Received CLOSE event from {session_id}. Reconnecting...&#34;)
                            await self.connect_to_new_endpoint()
                        for listener in self.on_close_listeners:
                            await listener(message)
                    elif message.type == WSMsgType.ERROR:
                        for listener in self.on_error_listeners:
                            await listener(message)
                    elif message.type == WSMsgType.CLOSED:
                        await asyncio.sleep(self.ping_interval)
                        continue
                    elif message.type == WSMsgType.PING:
                        await session.pong(message.data)
                        continue
                    elif message.type == WSMsgType.PONG:
                        if message.data is not None:
                            str_message_data = message.data.decode(&#34;utf-8&#34;)
                            elements = str_message_data.split(&#34;:&#34;)
                            if len(elements) == 2 and elements[0] == &#34;sdk-ping-pong&#34;:
                                try:
                                    self.last_ping_pong_time = float(elements[1])
                                except Exception as e:
                                    self.logger.warning(
                                        f&#34;Failed to parse the last_ping_pong_time value from {str_message_data}&#34;
                                        f&#34; - error : {e}, session: {session_id}&#34;
                                    )
                        continue

                consecutive_error_count = 0

            except Exception as e:
                consecutive_error_count += 1
                self.logger.error(f&#34;Failed to receive or enqueue a message: {type(e).__name__}, {e} ({session_id})&#34;)
                if isinstance(e, ClientConnectionError):
                    await asyncio.sleep(self.ping_interval)
                else:
                    await asyncio.sleep(consecutive_error_count)
    except asyncio.CancelledError:
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;The running receive_messages task for {session_id} is now cancelled&#34;)
        raise</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.send_message"><code class="name flex">
<span>async def <span class="ident">send_message</span></span>(<span>self, message:Â str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_message(self, message: str):
    session_id = await self.session_id()
    if self.logger.level &lt;= logging.DEBUG:
        self.logger.debug(f&#34;Sending a message: {message} from session: {session_id}&#34;)
    try:
        await self.current_session.send_str(message)
    except ConnectionError as e:
        # We rarely get this exception while replacing the underlying WebSocket connections.
        # We can do one more try here as the self.current_session should be ready now.
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(
                f&#34;Failed to send a message (error: {e}, message: {message}, session: {session_id})&#34;
                &#34; as the underlying connection was replaced. Retrying the same request only one time...&#34;
            )
        # Although acquiring self.connect_operation_lock also for the first method call is the safest way,
        # we avoid synchronizing a lot for better performance. That&#39;s why we are doing a retry here.
        try:
            await self.connect_operation_lock.acquire()
            if await self.is_connected():
                await self.current_session.send_str(message)
            else:
                self.logger.warning(
                    f&#34;The current session ({session_id}) is no longer active. &#34; &#34;Failed to send a message&#34;
                )
                raise e
        finally:
            if self.connect_operation_lock.locked() is True:
                self.connect_operation_lock.release()</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.aiohttp.SocketModeClient.session_id"><code class="name flex">
<span>async def <span class="ident">session_id</span></span>(<span>self) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def session_id(self) -&gt; str:
    return self.build_session_id(self.current_session)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="slack_sdk.socket_mode" href="../index.html">slack_sdk.socket_mode</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient">SocketModeClient</a></code></h4>
<ul class="">
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.app_token" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.app_token">app_token</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.auto_reconnect_enabled" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.auto_reconnect_enabled">auto_reconnect_enabled</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.build_session_id" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.build_session_id">build_session_id</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.close" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.close">close</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.closed" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.closed">closed</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.connect" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.connect">connect</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.connect_operation_lock" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.connect_operation_lock">connect_operation_lock</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.current_session" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.current_session">current_session</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.current_session_monitor" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.current_session_monitor">current_session_monitor</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.default_auto_reconnect_enabled" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.default_auto_reconnect_enabled">default_auto_reconnect_enabled</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.disconnect" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.disconnect">disconnect</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.is_connected" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.is_connected">is_connected</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.is_ping_pong_failing" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.is_ping_pong_failing">is_ping_pong_failing</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.last_ping_pong_time" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.last_ping_pong_time">last_ping_pong_time</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.logger" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.logger">logger</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.message_listeners" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.message_listeners">message_listeners</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.message_processor" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.message_processor">message_processor</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.message_queue" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.message_queue">message_queue</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.message_receiver" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.message_receiver">message_receiver</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.monitor_current_session" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.monitor_current_session">monitor_current_session</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.on_close_listeners" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.on_close_listeners">on_close_listeners</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.on_error_listeners" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.on_error_listeners">on_error_listeners</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.on_message_listeners" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.on_message_listeners">on_message_listeners</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.ping_interval" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.ping_interval">ping_interval</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.proxy" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.proxy">proxy</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.receive_messages" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.receive_messages">receive_messages</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.send_message" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.send_message">send_message</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.session_id" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.session_id">session_id</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.socket_mode_request_listeners" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.socket_mode_request_listeners">socket_mode_request_listeners</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.stale" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.stale">stale</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.trace_enabled" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.trace_enabled">trace_enabled</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.web_client" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.web_client">web_client</a></code></li>
<li><code><a title="slack_sdk.socket_mode.aiohttp.SocketModeClient.wss_uri" href="#slack_sdk.socket_mode.aiohttp.SocketModeClient.wss_uri">wss_uri</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>