<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>slack_sdk.socket_mode.client API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>slack_sdk.socket_mode.client</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json
import logging
import time
from queue import Queue, Empty
from concurrent.futures.thread import ThreadPoolExecutor
from logging import Logger
from threading import Lock
from typing import Dict, Union, Any, Optional, List, Callable

from slack_sdk.errors import SlackApiError
from slack_sdk.socket_mode.interval_runner import IntervalRunner
from slack_sdk.socket_mode.listeners import (
    WebSocketMessageListener,
    SocketModeRequestListener,
)
from slack_sdk.socket_mode.request import SocketModeRequest
from slack_sdk.socket_mode.response import SocketModeResponse
from slack_sdk.web import WebClient


class BaseSocketModeClient:
    logger: Logger
    web_client: WebClient
    app_token: str
    wss_uri: str
    message_queue: Queue
    message_listeners: List[
        Union[
            WebSocketMessageListener,
            Callable[[&#34;BaseSocketModeClient&#34;, dict, Optional[str]], None],
        ]
    ]
    socket_mode_request_listeners: List[
        Union[
            SocketModeRequestListener,
            Callable[[&#34;BaseSocketModeClient&#34;, SocketModeRequest], None],
        ]
    ]

    message_processor: IntervalRunner
    message_workers: ThreadPoolExecutor

    closed: bool
    connect_operation_lock: Lock

    def issue_new_wss_url(self) -&gt; str:
        try:
            response = self.web_client.apps_connections_open(app_token=self.app_token)
            return response[&#34;url&#34;]
        except SlackApiError as e:
            if e.response[&#34;error&#34;] == &#34;ratelimited&#34;:
                # NOTE: ratelimited errors rarely occur with this endpoint
                delay = int(e.response.headers.get(&#34;Retry-After&#34;, &#34;30&#34;))  # Tier1
                self.logger.info(f&#34;Rate limited. Retrying in {delay} seconds...&#34;)
                time.sleep(delay)
                # Retry to issue a new WSS URL
                return self.issue_new_wss_url()
            else:
                # other errors
                self.logger.error(f&#34;Failed to retrieve WSS URL: {e}&#34;)
                raise e

    def is_connected(self) -&gt; bool:
        return False

    def connect(self) -&gt; None:
        raise NotImplementedError()

    def disconnect(self) -&gt; None:
        raise NotImplementedError()

    def connect_to_new_endpoint(self, force: bool = False):
        try:
            self.connect_operation_lock.acquire(blocking=True, timeout=5)
            if force or not self.is_connected():
                self.logger.info(&#34;Connecting to a new endpoint...&#34;)
                self.wss_uri = self.issue_new_wss_url()
                self.connect()
                self.logger.info(&#34;Connected to a new endpoint...&#34;)
        finally:
            self.connect_operation_lock.release()

    def close(self) -&gt; None:
        self.closed = True
        self.disconnect()

    def send_message(self, message: str) -&gt; None:
        raise NotImplementedError()

    def send_socket_mode_response(self, response: Union[Dict[str, Any], SocketModeResponse]) -&gt; None:
        if isinstance(response, SocketModeResponse):
            self.send_message(json.dumps(response.to_dict()))
        else:
            self.send_message(json.dumps(response))

    def enqueue_message(self, message: str):
        self.message_queue.put(message)
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;A new message enqueued (current queue size: {self.message_queue.qsize()})&#34;)

    def process_message(self):
        try:
            raw_message = self.message_queue.get(timeout=1)
            if self.logger.level &lt;= logging.DEBUG:
                self.logger.debug(f&#34;A message dequeued (current queue size: {self.message_queue.qsize()})&#34;)

            if raw_message is not None:
                message: dict = {}
                if raw_message.startswith(&#34;{&#34;):
                    message = json.loads(raw_message)
                if message.get(&#34;type&#34;) == &#34;disconnect&#34;:
                    self.connect_to_new_endpoint(force=True)
                else:

                    def _run_message_listeners():
                        self.run_message_listeners(message, raw_message)

                    self.message_workers.submit(_run_message_listeners)
        except Empty:
            pass

    def run_message_listeners(self, message: dict, raw_message: str) -&gt; None:
        type, envelope_id = message.get(&#34;type&#34;), message.get(&#34;envelope_id&#34;)
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;Message processing started (type: {type}, envelope_id: {envelope_id})&#34;)
        try:
            # just in case, adding the same logic to reconnect here
            if message.get(&#34;type&#34;) == &#34;disconnect&#34;:
                self.connect_to_new_endpoint(force=True)
                return

            for listener in self.message_listeners:
                try:
                    listener(self, message, raw_message)  # type: ignore
                except Exception as e:
                    self.logger.exception(f&#34;Failed to run a message listener: {e}&#34;)

            if len(self.socket_mode_request_listeners) &gt; 0:
                request = SocketModeRequest.from_dict(message)
                if request is not None:
                    for listener in self.socket_mode_request_listeners:
                        try:
                            listener(self, request)  # type: ignore
                        except Exception as e:
                            self.logger.exception(f&#34;Failed to run a request listener: {e}&#34;)
        except Exception as e:
            self.logger.exception(f&#34;Failed to run message listeners: {e}&#34;)
        finally:
            if self.logger.level &lt;= logging.DEBUG:
                self.logger.debug(f&#34;Message processing completed (type: {type}, envelope_id: {envelope_id})&#34;)

    def process_messages(self) -&gt; None:
        while not self.closed:
            try:
                self.process_message()
            except Exception as e:
                self.logger.exception(f&#34;Failed to process a message: {e}&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="slack_sdk.socket_mode.client.BaseSocketModeClient"><code class="flex name class">
<span>class <span class="ident">BaseSocketModeClient</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseSocketModeClient:
    logger: Logger
    web_client: WebClient
    app_token: str
    wss_uri: str
    message_queue: Queue
    message_listeners: List[
        Union[
            WebSocketMessageListener,
            Callable[[&#34;BaseSocketModeClient&#34;, dict, Optional[str]], None],
        ]
    ]
    socket_mode_request_listeners: List[
        Union[
            SocketModeRequestListener,
            Callable[[&#34;BaseSocketModeClient&#34;, SocketModeRequest], None],
        ]
    ]

    message_processor: IntervalRunner
    message_workers: ThreadPoolExecutor

    closed: bool
    connect_operation_lock: Lock

    def issue_new_wss_url(self) -&gt; str:
        try:
            response = self.web_client.apps_connections_open(app_token=self.app_token)
            return response[&#34;url&#34;]
        except SlackApiError as e:
            if e.response[&#34;error&#34;] == &#34;ratelimited&#34;:
                # NOTE: ratelimited errors rarely occur with this endpoint
                delay = int(e.response.headers.get(&#34;Retry-After&#34;, &#34;30&#34;))  # Tier1
                self.logger.info(f&#34;Rate limited. Retrying in {delay} seconds...&#34;)
                time.sleep(delay)
                # Retry to issue a new WSS URL
                return self.issue_new_wss_url()
            else:
                # other errors
                self.logger.error(f&#34;Failed to retrieve WSS URL: {e}&#34;)
                raise e

    def is_connected(self) -&gt; bool:
        return False

    def connect(self) -&gt; None:
        raise NotImplementedError()

    def disconnect(self) -&gt; None:
        raise NotImplementedError()

    def connect_to_new_endpoint(self, force: bool = False):
        try:
            self.connect_operation_lock.acquire(blocking=True, timeout=5)
            if force or not self.is_connected():
                self.logger.info(&#34;Connecting to a new endpoint...&#34;)
                self.wss_uri = self.issue_new_wss_url()
                self.connect()
                self.logger.info(&#34;Connected to a new endpoint...&#34;)
        finally:
            self.connect_operation_lock.release()

    def close(self) -&gt; None:
        self.closed = True
        self.disconnect()

    def send_message(self, message: str) -&gt; None:
        raise NotImplementedError()

    def send_socket_mode_response(self, response: Union[Dict[str, Any], SocketModeResponse]) -&gt; None:
        if isinstance(response, SocketModeResponse):
            self.send_message(json.dumps(response.to_dict()))
        else:
            self.send_message(json.dumps(response))

    def enqueue_message(self, message: str):
        self.message_queue.put(message)
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;A new message enqueued (current queue size: {self.message_queue.qsize()})&#34;)

    def process_message(self):
        try:
            raw_message = self.message_queue.get(timeout=1)
            if self.logger.level &lt;= logging.DEBUG:
                self.logger.debug(f&#34;A message dequeued (current queue size: {self.message_queue.qsize()})&#34;)

            if raw_message is not None:
                message: dict = {}
                if raw_message.startswith(&#34;{&#34;):
                    message = json.loads(raw_message)
                if message.get(&#34;type&#34;) == &#34;disconnect&#34;:
                    self.connect_to_new_endpoint(force=True)
                else:

                    def _run_message_listeners():
                        self.run_message_listeners(message, raw_message)

                    self.message_workers.submit(_run_message_listeners)
        except Empty:
            pass

    def run_message_listeners(self, message: dict, raw_message: str) -&gt; None:
        type, envelope_id = message.get(&#34;type&#34;), message.get(&#34;envelope_id&#34;)
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;Message processing started (type: {type}, envelope_id: {envelope_id})&#34;)
        try:
            # just in case, adding the same logic to reconnect here
            if message.get(&#34;type&#34;) == &#34;disconnect&#34;:
                self.connect_to_new_endpoint(force=True)
                return

            for listener in self.message_listeners:
                try:
                    listener(self, message, raw_message)  # type: ignore
                except Exception as e:
                    self.logger.exception(f&#34;Failed to run a message listener: {e}&#34;)

            if len(self.socket_mode_request_listeners) &gt; 0:
                request = SocketModeRequest.from_dict(message)
                if request is not None:
                    for listener in self.socket_mode_request_listeners:
                        try:
                            listener(self, request)  # type: ignore
                        except Exception as e:
                            self.logger.exception(f&#34;Failed to run a request listener: {e}&#34;)
        except Exception as e:
            self.logger.exception(f&#34;Failed to run message listeners: {e}&#34;)
        finally:
            if self.logger.level &lt;= logging.DEBUG:
                self.logger.debug(f&#34;Message processing completed (type: {type}, envelope_id: {envelope_id})&#34;)

    def process_messages(self) -&gt; None:
        while not self.closed:
            try:
                self.process_message()
            except Exception as e:
                self.logger.exception(f&#34;Failed to process a message: {e}&#34;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="slack_sdk.socket_mode.builtin.client.SocketModeClient" href="builtin/client.html#slack_sdk.socket_mode.builtin.client.SocketModeClient">SocketModeClient</a></li>
<li><a title="slack_sdk.socket_mode.websocket_client.SocketModeClient" href="websocket_client/index.html#slack_sdk.socket_mode.websocket_client.SocketModeClient">SocketModeClient</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="slack_sdk.socket_mode.client.BaseSocketModeClient.app_token"><code class="name">var <span class="ident">app_token</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.client.BaseSocketModeClient.closed"><code class="name">var <span class="ident">closed</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.client.BaseSocketModeClient.connect_operation_lock"><code class="name">var <span class="ident">connect_operation_lock</span> : <built-in function allocate_lock></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.client.BaseSocketModeClient.logger"><code class="name">var <span class="ident">logger</span> : logging.Logger</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.client.BaseSocketModeClient.message_listeners"><code class="name">var <span class="ident">message_listeners</span> : List[Union[<a title="slack_sdk.socket_mode.listeners.WebSocketMessageListener" href="listeners.html#slack_sdk.socket_mode.listeners.WebSocketMessageListener">WebSocketMessageListener</a>, Callable[[<a title="slack_sdk.socket_mode.client.BaseSocketModeClient" href="#slack_sdk.socket_mode.client.BaseSocketModeClient">BaseSocketModeClient</a>, dict, Optional[str]], None]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.client.BaseSocketModeClient.message_processor"><code class="name">var <span class="ident">message_processor</span> : <a title="slack_sdk.socket_mode.interval_runner.IntervalRunner" href="interval_runner.html#slack_sdk.socket_mode.interval_runner.IntervalRunner">IntervalRunner</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.client.BaseSocketModeClient.message_queue"><code class="name">var <span class="ident">message_queue</span> : queue.Queue</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.client.BaseSocketModeClient.message_workers"><code class="name">var <span class="ident">message_workers</span> : concurrent.futures.thread.ThreadPoolExecutor</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.client.BaseSocketModeClient.socket_mode_request_listeners"><code class="name">var <span class="ident">socket_mode_request_listeners</span> : List[Union[<a title="slack_sdk.socket_mode.listeners.SocketModeRequestListener" href="listeners.html#slack_sdk.socket_mode.listeners.SocketModeRequestListener">SocketModeRequestListener</a>, Callable[[<a title="slack_sdk.socket_mode.client.BaseSocketModeClient" href="#slack_sdk.socket_mode.client.BaseSocketModeClient">BaseSocketModeClient</a>, <a title="slack_sdk.socket_mode.request.SocketModeRequest" href="request.html#slack_sdk.socket_mode.request.SocketModeRequest">SocketModeRequest</a>], None]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.client.BaseSocketModeClient.web_client"><code class="name">var <span class="ident">web_client</span> : <a title="slack_sdk.web.client.WebClient" href="../web/client.html#slack_sdk.web.client.WebClient">WebClient</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.socket_mode.client.BaseSocketModeClient.wss_uri"><code class="name">var <span class="ident">wss_uri</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="slack_sdk.socket_mode.client.BaseSocketModeClient.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self) -&gt; None:
    self.closed = True
    self.disconnect()</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.client.BaseSocketModeClient.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self) -&gt; None:
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.client.BaseSocketModeClient.connect_to_new_endpoint"><code class="name flex">
<span>def <span class="ident">connect_to_new_endpoint</span></span>(<span>self, force: bool = False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect_to_new_endpoint(self, force: bool = False):
    try:
        self.connect_operation_lock.acquire(blocking=True, timeout=5)
        if force or not self.is_connected():
            self.logger.info(&#34;Connecting to a new endpoint...&#34;)
            self.wss_uri = self.issue_new_wss_url()
            self.connect()
            self.logger.info(&#34;Connected to a new endpoint...&#34;)
    finally:
        self.connect_operation_lock.release()</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.client.BaseSocketModeClient.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self) -&gt; None:
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.client.BaseSocketModeClient.enqueue_message"><code class="name flex">
<span>def <span class="ident">enqueue_message</span></span>(<span>self, message: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enqueue_message(self, message: str):
    self.message_queue.put(message)
    if self.logger.level &lt;= logging.DEBUG:
        self.logger.debug(f&#34;A new message enqueued (current queue size: {self.message_queue.qsize()})&#34;)</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.client.BaseSocketModeClient.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_connected(self) -&gt; bool:
    return False</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.client.BaseSocketModeClient.issue_new_wss_url"><code class="name flex">
<span>def <span class="ident">issue_new_wss_url</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def issue_new_wss_url(self) -&gt; str:
    try:
        response = self.web_client.apps_connections_open(app_token=self.app_token)
        return response[&#34;url&#34;]
    except SlackApiError as e:
        if e.response[&#34;error&#34;] == &#34;ratelimited&#34;:
            # NOTE: ratelimited errors rarely occur with this endpoint
            delay = int(e.response.headers.get(&#34;Retry-After&#34;, &#34;30&#34;))  # Tier1
            self.logger.info(f&#34;Rate limited. Retrying in {delay} seconds...&#34;)
            time.sleep(delay)
            # Retry to issue a new WSS URL
            return self.issue_new_wss_url()
        else:
            # other errors
            self.logger.error(f&#34;Failed to retrieve WSS URL: {e}&#34;)
            raise e</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.client.BaseSocketModeClient.process_message"><code class="name flex">
<span>def <span class="ident">process_message</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_message(self):
    try:
        raw_message = self.message_queue.get(timeout=1)
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;A message dequeued (current queue size: {self.message_queue.qsize()})&#34;)

        if raw_message is not None:
            message: dict = {}
            if raw_message.startswith(&#34;{&#34;):
                message = json.loads(raw_message)
            if message.get(&#34;type&#34;) == &#34;disconnect&#34;:
                self.connect_to_new_endpoint(force=True)
            else:

                def _run_message_listeners():
                    self.run_message_listeners(message, raw_message)

                self.message_workers.submit(_run_message_listeners)
    except Empty:
        pass</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.client.BaseSocketModeClient.process_messages"><code class="name flex">
<span>def <span class="ident">process_messages</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_messages(self) -&gt; None:
    while not self.closed:
        try:
            self.process_message()
        except Exception as e:
            self.logger.exception(f&#34;Failed to process a message: {e}&#34;)</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.client.BaseSocketModeClient.run_message_listeners"><code class="name flex">
<span>def <span class="ident">run_message_listeners</span></span>(<span>self, message: dict, raw_message: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_message_listeners(self, message: dict, raw_message: str) -&gt; None:
    type, envelope_id = message.get(&#34;type&#34;), message.get(&#34;envelope_id&#34;)
    if self.logger.level &lt;= logging.DEBUG:
        self.logger.debug(f&#34;Message processing started (type: {type}, envelope_id: {envelope_id})&#34;)
    try:
        # just in case, adding the same logic to reconnect here
        if message.get(&#34;type&#34;) == &#34;disconnect&#34;:
            self.connect_to_new_endpoint(force=True)
            return

        for listener in self.message_listeners:
            try:
                listener(self, message, raw_message)  # type: ignore
            except Exception as e:
                self.logger.exception(f&#34;Failed to run a message listener: {e}&#34;)

        if len(self.socket_mode_request_listeners) &gt; 0:
            request = SocketModeRequest.from_dict(message)
            if request is not None:
                for listener in self.socket_mode_request_listeners:
                    try:
                        listener(self, request)  # type: ignore
                    except Exception as e:
                        self.logger.exception(f&#34;Failed to run a request listener: {e}&#34;)
    except Exception as e:
        self.logger.exception(f&#34;Failed to run message listeners: {e}&#34;)
    finally:
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;Message processing completed (type: {type}, envelope_id: {envelope_id})&#34;)</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.client.BaseSocketModeClient.send_message"><code class="name flex">
<span>def <span class="ident">send_message</span></span>(<span>self, message: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_message(self, message: str) -&gt; None:
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="slack_sdk.socket_mode.client.BaseSocketModeClient.send_socket_mode_response"><code class="name flex">
<span>def <span class="ident">send_socket_mode_response</span></span>(<span>self, response: Union[Dict[str, Any], <a title="slack_sdk.socket_mode.response.SocketModeResponse" href="response.html#slack_sdk.socket_mode.response.SocketModeResponse">SocketModeResponse</a>]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_socket_mode_response(self, response: Union[Dict[str, Any], SocketModeResponse]) -&gt; None:
    if isinstance(response, SocketModeResponse):
        self.send_message(json.dumps(response.to_dict()))
    else:
        self.send_message(json.dumps(response))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="slack_sdk.socket_mode" href="index.html">slack_sdk.socket_mode</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="slack_sdk.socket_mode.client.BaseSocketModeClient" href="#slack_sdk.socket_mode.client.BaseSocketModeClient">BaseSocketModeClient</a></code></h4>
<ul class="">
<li><code><a title="slack_sdk.socket_mode.client.BaseSocketModeClient.app_token" href="#slack_sdk.socket_mode.client.BaseSocketModeClient.app_token">app_token</a></code></li>
<li><code><a title="slack_sdk.socket_mode.client.BaseSocketModeClient.close" href="#slack_sdk.socket_mode.client.BaseSocketModeClient.close">close</a></code></li>
<li><code><a title="slack_sdk.socket_mode.client.BaseSocketModeClient.closed" href="#slack_sdk.socket_mode.client.BaseSocketModeClient.closed">closed</a></code></li>
<li><code><a title="slack_sdk.socket_mode.client.BaseSocketModeClient.connect" href="#slack_sdk.socket_mode.client.BaseSocketModeClient.connect">connect</a></code></li>
<li><code><a title="slack_sdk.socket_mode.client.BaseSocketModeClient.connect_operation_lock" href="#slack_sdk.socket_mode.client.BaseSocketModeClient.connect_operation_lock">connect_operation_lock</a></code></li>
<li><code><a title="slack_sdk.socket_mode.client.BaseSocketModeClient.connect_to_new_endpoint" href="#slack_sdk.socket_mode.client.BaseSocketModeClient.connect_to_new_endpoint">connect_to_new_endpoint</a></code></li>
<li><code><a title="slack_sdk.socket_mode.client.BaseSocketModeClient.disconnect" href="#slack_sdk.socket_mode.client.BaseSocketModeClient.disconnect">disconnect</a></code></li>
<li><code><a title="slack_sdk.socket_mode.client.BaseSocketModeClient.enqueue_message" href="#slack_sdk.socket_mode.client.BaseSocketModeClient.enqueue_message">enqueue_message</a></code></li>
<li><code><a title="slack_sdk.socket_mode.client.BaseSocketModeClient.is_connected" href="#slack_sdk.socket_mode.client.BaseSocketModeClient.is_connected">is_connected</a></code></li>
<li><code><a title="slack_sdk.socket_mode.client.BaseSocketModeClient.issue_new_wss_url" href="#slack_sdk.socket_mode.client.BaseSocketModeClient.issue_new_wss_url">issue_new_wss_url</a></code></li>
<li><code><a title="slack_sdk.socket_mode.client.BaseSocketModeClient.logger" href="#slack_sdk.socket_mode.client.BaseSocketModeClient.logger">logger</a></code></li>
<li><code><a title="slack_sdk.socket_mode.client.BaseSocketModeClient.message_listeners" href="#slack_sdk.socket_mode.client.BaseSocketModeClient.message_listeners">message_listeners</a></code></li>
<li><code><a title="slack_sdk.socket_mode.client.BaseSocketModeClient.message_processor" href="#slack_sdk.socket_mode.client.BaseSocketModeClient.message_processor">message_processor</a></code></li>
<li><code><a title="slack_sdk.socket_mode.client.BaseSocketModeClient.message_queue" href="#slack_sdk.socket_mode.client.BaseSocketModeClient.message_queue">message_queue</a></code></li>
<li><code><a title="slack_sdk.socket_mode.client.BaseSocketModeClient.message_workers" href="#slack_sdk.socket_mode.client.BaseSocketModeClient.message_workers">message_workers</a></code></li>
<li><code><a title="slack_sdk.socket_mode.client.BaseSocketModeClient.process_message" href="#slack_sdk.socket_mode.client.BaseSocketModeClient.process_message">process_message</a></code></li>
<li><code><a title="slack_sdk.socket_mode.client.BaseSocketModeClient.process_messages" href="#slack_sdk.socket_mode.client.BaseSocketModeClient.process_messages">process_messages</a></code></li>
<li><code><a title="slack_sdk.socket_mode.client.BaseSocketModeClient.run_message_listeners" href="#slack_sdk.socket_mode.client.BaseSocketModeClient.run_message_listeners">run_message_listeners</a></code></li>
<li><code><a title="slack_sdk.socket_mode.client.BaseSocketModeClient.send_message" href="#slack_sdk.socket_mode.client.BaseSocketModeClient.send_message">send_message</a></code></li>
<li><code><a title="slack_sdk.socket_mode.client.BaseSocketModeClient.send_socket_mode_response" href="#slack_sdk.socket_mode.client.BaseSocketModeClient.send_socket_mode_response">send_socket_mode_response</a></code></li>
<li><code><a title="slack_sdk.socket_mode.client.BaseSocketModeClient.socket_mode_request_listeners" href="#slack_sdk.socket_mode.client.BaseSocketModeClient.socket_mode_request_listeners">socket_mode_request_listeners</a></code></li>
<li><code><a title="slack_sdk.socket_mode.client.BaseSocketModeClient.web_client" href="#slack_sdk.socket_mode.client.BaseSocketModeClient.web_client">web_client</a></code></li>
<li><code><a title="slack_sdk.socket_mode.client.BaseSocketModeClient.wss_uri" href="#slack_sdk.socket_mode.client.BaseSocketModeClient.wss_uri">wss_uri</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>