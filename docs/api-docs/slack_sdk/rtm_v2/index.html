<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>slack_sdk.rtm_v2 API documentation</title>
<meta name="description" content="A Python module for interacting with Slack&#39;s RTM API." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>slack_sdk.rtm_v2</code></h1>
</header>
<section id="section-intro">
<p>A Python module for interacting with Slack's RTM API.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A Python module for interacting with Slack&#39;s RTM API.&#34;&#34;&#34;
import inspect
import json
import logging
import time
from concurrent.futures.thread import ThreadPoolExecutor
from logging import Logger
from queue import Queue, Empty
from ssl import SSLContext
from threading import Lock, Event
from typing import Optional, Callable, List, Union

from slack_sdk.errors import SlackApiError, SlackClientError
from slack_sdk.proxy_env_variable_loader import load_http_proxy_from_env
from slack_sdk.socket_mode.builtin.connection import Connection, ConnectionState
from slack_sdk.socket_mode.interval_runner import IntervalRunner
from slack_sdk.web import WebClient


class RTMClient:
    token: Optional[str]
    bot_id: Optional[str]
    default_auto_reconnect_enabled: bool
    auto_reconnect_enabled: bool
    ssl: Optional[SSLContext]
    proxy: Optional[str]
    timeout: int
    base_url: str
    ping_interval: int
    logger: Logger
    web_client: WebClient

    current_session: Optional[Connection]
    current_session_state: Optional[ConnectionState]
    wss_uri: Optional[str]

    message_queue: Queue
    message_listeners: List[Callable[[&#34;RTMClient&#34;, dict], None]]
    message_processor: IntervalRunner
    message_workers: ThreadPoolExecutor

    closed: bool
    connect_operation_lock: Lock

    on_message_listeners: List[Callable[[str], None]]
    on_error_listeners: List[Callable[[Exception], None]]
    on_close_listeners: List[Callable[[int, Optional[str]], None]]

    def __init__(
        self,
        *,
        token: Optional[str] = None,
        web_client: Optional[WebClient] = None,
        auto_reconnect_enabled: bool = True,
        ssl: Optional[SSLContext] = None,
        proxy: Optional[str] = None,
        timeout: int = 30,
        base_url: str = WebClient.BASE_URL,
        headers: Optional[dict] = None,
        ping_interval: int = 5,
        concurrency: int = 10,
        logger: Optional[logging.Logger] = None,
        on_message_listeners: Optional[List[Callable[[str], None]]] = None,
        on_error_listeners: Optional[List[Callable[[Exception], None]]] = None,
        on_close_listeners: Optional[List[Callable[[int, Optional[str]], None]]] = None,
        trace_enabled: bool = False,
        all_message_trace_enabled: bool = False,
        ping_pong_trace_enabled: bool = False,
    ):
        self.token = token.strip() if token is not None else None
        self.bot_id = None
        self.default_auto_reconnect_enabled = auto_reconnect_enabled
        # You may want temporarily turn off the auto_reconnect as necessary
        self.auto_reconnect_enabled = self.default_auto_reconnect_enabled
        self.ssl = ssl
        self.proxy = proxy
        self.timeout = timeout
        self.base_url = base_url
        self.headers = headers
        self.ping_interval = ping_interval
        self.logger = logger or logging.getLogger(__name__)
        if self.proxy is None or len(self.proxy.strip()) == 0:
            env_variable = load_http_proxy_from_env(self.logger)
            if env_variable is not None:
                self.proxy = env_variable

        self.web_client = web_client or WebClient(
            token=self.token,
            base_url=self.base_url,
            timeout=self.timeout,
            ssl=self.ssl,
            proxy=self.proxy,
            headers=self.headers,
            logger=logger,
        )

        self.on_message_listeners = on_message_listeners or []

        self.on_error_listeners = on_error_listeners or []
        self.on_close_listeners = on_close_listeners or []

        self.trace_enabled = trace_enabled
        self.all_message_trace_enabled = all_message_trace_enabled
        self.ping_pong_trace_enabled = ping_pong_trace_enabled

        self.message_queue = Queue()

        def goodbye_listener(_self, event: dict):
            if event.get(&#34;type&#34;) == &#34;goodbye&#34;:
                message = &#34;Got a goodbye message. Reconnecting to the server ...&#34;
                self.logger.info(message)
                self.connect_to_new_endpoint(force=True)

        self.message_listeners = [goodbye_listener]
        self.socket_mode_request_listeners = []

        self.current_session = None
        self.current_session_state = ConnectionState()
        self.current_session_runner = IntervalRunner(self._run_current_session, 0.1).start()
        self.wss_uri = None

        self.current_app_monitor_started = False
        self.current_app_monitor = IntervalRunner(
            self._monitor_current_session,
            self.ping_interval,
        )

        self.closed = False
        self.connect_operation_lock = Lock()

        self.message_processor = IntervalRunner(self.process_messages, 0.001).start()
        self.message_workers = ThreadPoolExecutor(max_workers=concurrency)

    # --------------------------------------------------------------
    # Decorator to register listeners
    # --------------------------------------------------------------

    def on(self, event_type: str) -&gt; Callable:
        &#34;&#34;&#34;Registers a new event listener.

        Args:
            event_type: str representing an event&#39;s type (e.g., message, reaction_added)
        &#34;&#34;&#34;

        def __call__(*args, **kwargs):
            func = args[0]
            if func is not None:
                if isinstance(func, Callable):
                    name = (
                        func.__name__
                        if hasattr(func, &#34;__name__&#34;)
                        else f&#34;{func.__class__.__module__}.{func.__class__.__name__}&#34;
                    )
                    inspect_result: inspect.FullArgSpec = inspect.getfullargspec(func)
                    if inspect_result is not None and len(inspect_result.args) != 2:
                        actual_args = &#34;, &#34;.join(inspect_result.args)
                        error = f&#34;The listener &#39;{name}&#39; must accept two args: client, event (actual: {actual_args})&#34;
                        raise SlackClientError(error)

                    def new_message_listener(_self, event: dict):
                        actual_event_type = event.get(&#34;type&#34;)
                        if event.get(&#34;bot_id&#34;) == self.bot_id:
                            # SKip the events generated by this bot user
                            return
                        # https://github.com/slackapi/python-slack-sdk/issues/533
                        if event_type == &#34;*&#34; or (actual_event_type is not None and actual_event_type == event_type):
                            func(_self, event)

                    self.message_listeners.append(new_message_listener)
                else:
                    error = f&#34;The listener &#39;{func}&#39; is not a Callable (actual: {type(func).__name__})&#34;
                    raise SlackClientError(error)
            # Not to cause modification to the decorated method
            return func

        return __call__

    # --------------------------------------------------------------
    # Connections
    # --------------------------------------------------------------

    def is_connected(self) -&gt; bool:
        &#34;&#34;&#34;Returns True if this client is connected.&#34;&#34;&#34;
        return self.current_session is not None and self.current_session.is_active()

    def issue_new_wss_url(self) -&gt; str:
        &#34;&#34;&#34;Acquires a new WSS URL using rtm.connect API method&#34;&#34;&#34;
        try:
            api_response = self.web_client.rtm_connect()
            return api_response[&#34;url&#34;]
        except SlackApiError as e:
            if e.response[&#34;error&#34;] == &#34;ratelimited&#34;:
                delay = int(e.response.headers.get(&#34;Retry-After&#34;, &#34;30&#34;))  # Tier1
                self.logger.info(f&#34;Rate limited. Retrying in {delay} seconds...&#34;)
                time.sleep(delay)
                # Retry to issue a new WSS URL
                return self.issue_new_wss_url()
            else:
                # other errors
                self.logger.error(f&#34;Failed to retrieve WSS URL: {e}&#34;)
                raise e

    def connect_to_new_endpoint(self, force: bool = False):
        &#34;&#34;&#34;Acquires a new WSS URL and tries to connect to the endpoint.&#34;&#34;&#34;
        with self.connect_operation_lock:
            if force or not self.is_connected():
                self.logger.info(&#34;Connecting to a new endpoint...&#34;)
                self.wss_uri = self.issue_new_wss_url()
                self.connect()
                self.logger.info(&#34;Connected to a new endpoint...&#34;)

    def connect(self):
        &#34;&#34;&#34;Starts talking to the RTM server through a WebSocket connection&#34;&#34;&#34;
        if self.bot_id is None:
            self.bot_id = self.web_client.auth_test()[&#34;bot_id&#34;]

        old_session: Optional[Connection] = self.current_session
        old_current_session_state: ConnectionState = self.current_session_state

        if self.wss_uri is None:
            self.wss_uri = self.issue_new_wss_url()

        current_session = Connection(
            url=self.wss_uri,
            logger=self.logger,
            ping_interval=self.ping_interval,
            trace_enabled=self.trace_enabled,
            all_message_trace_enabled=self.all_message_trace_enabled,
            ping_pong_trace_enabled=self.ping_pong_trace_enabled,
            receive_buffer_size=1024,
            proxy=self.proxy,
            on_message_listener=self.run_all_message_listeners,
            on_error_listener=self.run_all_error_listeners,
            on_close_listener=self.run_all_close_listeners,
            connection_type_name=&#34;RTM&#34;,
        )
        current_session.connect()

        if old_current_session_state is not None:
            old_current_session_state.terminated = True
        if old_session is not None:
            old_session.close()

        self.current_session = current_session
        self.current_session_state = ConnectionState()
        self.auto_reconnect_enabled = self.default_auto_reconnect_enabled

        if not self.current_app_monitor_started:
            self.current_app_monitor_started = True
            self.current_app_monitor.start()

        self.logger.info(f&#34;A new session has been established (session id: {self.session_id()})&#34;)

    def disconnect(self):
        &#34;&#34;&#34;Disconnects the current session.&#34;&#34;&#34;
        self.current_session.disconnect()

    def close(self) -&gt; None:
        &#34;&#34;&#34;
        Closes this instance and cleans up underlying resources.
        After calling this method, this instance is no longer usable.
        &#34;&#34;&#34;
        self.closed = True
        self.disconnect()
        self.current_session.close()

    def start(self) -&gt; None:
        &#34;&#34;&#34;Establishes an RTM connection and blocks the current thread.&#34;&#34;&#34;
        self.connect()
        Event().wait()

    def send(self, payload: Union[dict, str]) -&gt; None:
        if payload is None:
            return
        if self.current_session is None or not self.current_session.is_active():
            raise SlackClientError(&#34;The RTM client is not connected to the Slack servers&#34;)
        if isinstance(payload, str):
            self.current_session.send(payload)
        else:
            self.current_session.send(json.dumps(payload))

    # --------------------------------------------------------------
    # WS Message Processor
    # --------------------------------------------------------------

    def enqueue_message(self, message: str):
        self.message_queue.put(message)
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;A new message enqueued (current queue size: {self.message_queue.qsize()})&#34;)

    def process_message(self):
        try:
            raw_message = self.message_queue.get(timeout=1)
            if self.logger.level &lt;= logging.DEBUG:
                self.logger.debug(f&#34;A message dequeued (current queue size: {self.message_queue.qsize()})&#34;)

            if raw_message is not None:
                message: dict = {}
                if raw_message.startswith(&#34;{&#34;):
                    message = json.loads(raw_message)

                def _run_message_listeners():
                    self.run_message_listeners(message)

                self.message_workers.submit(_run_message_listeners)
        except Empty:
            pass

    def process_messages(self) -&gt; None:
        while not self.closed:
            try:
                self.process_message()
            except Exception as e:
                self.logger.exception(f&#34;Failed to process a message: {e}&#34;)

    def run_message_listeners(self, message: dict) -&gt; None:
        type = message.get(&#34;type&#34;)
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;Message processing started (type: {type})&#34;)
        try:
            for listener in self.message_listeners:
                try:
                    listener(self, message)
                except Exception as e:
                    self.logger.exception(f&#34;Failed to run a message listener: {e}&#34;)
        except Exception as e:
            self.logger.exception(f&#34;Failed to run message listeners: {e}&#34;)
        finally:
            if self.logger.level &lt;= logging.DEBUG:
                self.logger.debug(f&#34;Message processing completed (type: {type})&#34;)

    # --------------------------------------------------------------
    # Internals
    # --------------------------------------------------------------

    def session_id(self) -&gt; Optional[str]:
        if self.current_session is not None:
            return self.current_session.session_id
        return None

    def run_all_message_listeners(self, message: str):
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;on_message invoked: (message: {message})&#34;)
        self.enqueue_message(message)
        for listener in self.on_message_listeners:
            listener(message)

    def run_all_error_listeners(self, error: Exception):
        self.logger.exception(
            f&#34;on_error invoked (session id: {self.session_id()}, &#34; f&#34;error: {type(error).__name__}, message: {error})&#34;
        )
        for listener in self.on_error_listeners:
            listener(error)

    def run_all_close_listeners(self, code: int, reason: Optional[str] = None):
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;on_close invoked (session id: {self.session_id()})&#34;)
        if self.auto_reconnect_enabled:
            self.logger.info(&#34;Received CLOSE event. Going to reconnect... &#34; f&#34;(session id: {self.session_id()})&#34;)
            self.connect_to_new_endpoint()
        for listener in self.on_close_listeners:
            listener(code, reason)

    def _run_current_session(self):
        if self.current_session is not None and self.current_session.is_active():
            session_id = self.session_id()
            try:
                self.logger.info(&#34;Starting to receive messages from a new connection&#34; f&#34; (session id: {session_id})&#34;)
                self.current_session_state.terminated = False
                self.current_session.run_until_completion(self.current_session_state)
                self.logger.info(&#34;Stopped receiving messages from a connection&#34; f&#34; (session id: {session_id})&#34;)
            except Exception as e:
                self.logger.exception(
                    &#34;Failed to start or stop the current session&#34; f&#34; (session id: {session_id}, error: {e})&#34;
                )

    def _monitor_current_session(self):
        if self.current_app_monitor_started:
            try:
                self.current_session.check_state()

                if self.auto_reconnect_enabled and (self.current_session is None or not self.current_session.is_active()):
                    self.logger.info(
                        &#34;The session seems to be already closed. Going to reconnect... &#34; f&#34;(session id: {self.session_id()})&#34;
                    )
                    self.connect_to_new_endpoint()
            except Exception as e:
                self.logger.error(
                    &#34;Failed to check the current session or reconnect to the server &#34;
                    f&#34;(session id: {self.session_id()}, error: {type(e).__name__}, message: {e})&#34;
                )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="slack_sdk.rtm_v2.RTMClient"><code class="flex name class">
<span>class <span class="ident">RTMClient</span></span>
<span>(</span><span>*, token: Optional[str] = None, web_client: Optional[<a title="slack_sdk.web.client.WebClient" href="../web/client.html#slack_sdk.web.client.WebClient">WebClient</a>] = None, auto_reconnect_enabled: bool = True, ssl: Optional[ssl.SSLContext] = None, proxy: Optional[str] = None, timeout: int = 30, base_url: str = 'https://slack.com/api/', headers: Optional[dict] = None, ping_interval: int = 5, concurrency: int = 10, logger: Optional[logging.Logger] = None, on_message_listeners: Optional[List[Callable[[str], None]]] = None, on_error_listeners: Optional[List[Callable[[Exception], None]]] = None, on_close_listeners: Optional[List[Callable[[int, Optional[str]], None]]] = None, trace_enabled: bool = False, all_message_trace_enabled: bool = False, ping_pong_trace_enabled: bool = False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RTMClient:
    token: Optional[str]
    bot_id: Optional[str]
    default_auto_reconnect_enabled: bool
    auto_reconnect_enabled: bool
    ssl: Optional[SSLContext]
    proxy: Optional[str]
    timeout: int
    base_url: str
    ping_interval: int
    logger: Logger
    web_client: WebClient

    current_session: Optional[Connection]
    current_session_state: Optional[ConnectionState]
    wss_uri: Optional[str]

    message_queue: Queue
    message_listeners: List[Callable[[&#34;RTMClient&#34;, dict], None]]
    message_processor: IntervalRunner
    message_workers: ThreadPoolExecutor

    closed: bool
    connect_operation_lock: Lock

    on_message_listeners: List[Callable[[str], None]]
    on_error_listeners: List[Callable[[Exception], None]]
    on_close_listeners: List[Callable[[int, Optional[str]], None]]

    def __init__(
        self,
        *,
        token: Optional[str] = None,
        web_client: Optional[WebClient] = None,
        auto_reconnect_enabled: bool = True,
        ssl: Optional[SSLContext] = None,
        proxy: Optional[str] = None,
        timeout: int = 30,
        base_url: str = WebClient.BASE_URL,
        headers: Optional[dict] = None,
        ping_interval: int = 5,
        concurrency: int = 10,
        logger: Optional[logging.Logger] = None,
        on_message_listeners: Optional[List[Callable[[str], None]]] = None,
        on_error_listeners: Optional[List[Callable[[Exception], None]]] = None,
        on_close_listeners: Optional[List[Callable[[int, Optional[str]], None]]] = None,
        trace_enabled: bool = False,
        all_message_trace_enabled: bool = False,
        ping_pong_trace_enabled: bool = False,
    ):
        self.token = token.strip() if token is not None else None
        self.bot_id = None
        self.default_auto_reconnect_enabled = auto_reconnect_enabled
        # You may want temporarily turn off the auto_reconnect as necessary
        self.auto_reconnect_enabled = self.default_auto_reconnect_enabled
        self.ssl = ssl
        self.proxy = proxy
        self.timeout = timeout
        self.base_url = base_url
        self.headers = headers
        self.ping_interval = ping_interval
        self.logger = logger or logging.getLogger(__name__)
        if self.proxy is None or len(self.proxy.strip()) == 0:
            env_variable = load_http_proxy_from_env(self.logger)
            if env_variable is not None:
                self.proxy = env_variable

        self.web_client = web_client or WebClient(
            token=self.token,
            base_url=self.base_url,
            timeout=self.timeout,
            ssl=self.ssl,
            proxy=self.proxy,
            headers=self.headers,
            logger=logger,
        )

        self.on_message_listeners = on_message_listeners or []

        self.on_error_listeners = on_error_listeners or []
        self.on_close_listeners = on_close_listeners or []

        self.trace_enabled = trace_enabled
        self.all_message_trace_enabled = all_message_trace_enabled
        self.ping_pong_trace_enabled = ping_pong_trace_enabled

        self.message_queue = Queue()

        def goodbye_listener(_self, event: dict):
            if event.get(&#34;type&#34;) == &#34;goodbye&#34;:
                message = &#34;Got a goodbye message. Reconnecting to the server ...&#34;
                self.logger.info(message)
                self.connect_to_new_endpoint(force=True)

        self.message_listeners = [goodbye_listener]
        self.socket_mode_request_listeners = []

        self.current_session = None
        self.current_session_state = ConnectionState()
        self.current_session_runner = IntervalRunner(self._run_current_session, 0.1).start()
        self.wss_uri = None

        self.current_app_monitor_started = False
        self.current_app_monitor = IntervalRunner(
            self._monitor_current_session,
            self.ping_interval,
        )

        self.closed = False
        self.connect_operation_lock = Lock()

        self.message_processor = IntervalRunner(self.process_messages, 0.001).start()
        self.message_workers = ThreadPoolExecutor(max_workers=concurrency)

    # --------------------------------------------------------------
    # Decorator to register listeners
    # --------------------------------------------------------------

    def on(self, event_type: str) -&gt; Callable:
        &#34;&#34;&#34;Registers a new event listener.

        Args:
            event_type: str representing an event&#39;s type (e.g., message, reaction_added)
        &#34;&#34;&#34;

        def __call__(*args, **kwargs):
            func = args[0]
            if func is not None:
                if isinstance(func, Callable):
                    name = (
                        func.__name__
                        if hasattr(func, &#34;__name__&#34;)
                        else f&#34;{func.__class__.__module__}.{func.__class__.__name__}&#34;
                    )
                    inspect_result: inspect.FullArgSpec = inspect.getfullargspec(func)
                    if inspect_result is not None and len(inspect_result.args) != 2:
                        actual_args = &#34;, &#34;.join(inspect_result.args)
                        error = f&#34;The listener &#39;{name}&#39; must accept two args: client, event (actual: {actual_args})&#34;
                        raise SlackClientError(error)

                    def new_message_listener(_self, event: dict):
                        actual_event_type = event.get(&#34;type&#34;)
                        if event.get(&#34;bot_id&#34;) == self.bot_id:
                            # SKip the events generated by this bot user
                            return
                        # https://github.com/slackapi/python-slack-sdk/issues/533
                        if event_type == &#34;*&#34; or (actual_event_type is not None and actual_event_type == event_type):
                            func(_self, event)

                    self.message_listeners.append(new_message_listener)
                else:
                    error = f&#34;The listener &#39;{func}&#39; is not a Callable (actual: {type(func).__name__})&#34;
                    raise SlackClientError(error)
            # Not to cause modification to the decorated method
            return func

        return __call__

    # --------------------------------------------------------------
    # Connections
    # --------------------------------------------------------------

    def is_connected(self) -&gt; bool:
        &#34;&#34;&#34;Returns True if this client is connected.&#34;&#34;&#34;
        return self.current_session is not None and self.current_session.is_active()

    def issue_new_wss_url(self) -&gt; str:
        &#34;&#34;&#34;Acquires a new WSS URL using rtm.connect API method&#34;&#34;&#34;
        try:
            api_response = self.web_client.rtm_connect()
            return api_response[&#34;url&#34;]
        except SlackApiError as e:
            if e.response[&#34;error&#34;] == &#34;ratelimited&#34;:
                delay = int(e.response.headers.get(&#34;Retry-After&#34;, &#34;30&#34;))  # Tier1
                self.logger.info(f&#34;Rate limited. Retrying in {delay} seconds...&#34;)
                time.sleep(delay)
                # Retry to issue a new WSS URL
                return self.issue_new_wss_url()
            else:
                # other errors
                self.logger.error(f&#34;Failed to retrieve WSS URL: {e}&#34;)
                raise e

    def connect_to_new_endpoint(self, force: bool = False):
        &#34;&#34;&#34;Acquires a new WSS URL and tries to connect to the endpoint.&#34;&#34;&#34;
        with self.connect_operation_lock:
            if force or not self.is_connected():
                self.logger.info(&#34;Connecting to a new endpoint...&#34;)
                self.wss_uri = self.issue_new_wss_url()
                self.connect()
                self.logger.info(&#34;Connected to a new endpoint...&#34;)

    def connect(self):
        &#34;&#34;&#34;Starts talking to the RTM server through a WebSocket connection&#34;&#34;&#34;
        if self.bot_id is None:
            self.bot_id = self.web_client.auth_test()[&#34;bot_id&#34;]

        old_session: Optional[Connection] = self.current_session
        old_current_session_state: ConnectionState = self.current_session_state

        if self.wss_uri is None:
            self.wss_uri = self.issue_new_wss_url()

        current_session = Connection(
            url=self.wss_uri,
            logger=self.logger,
            ping_interval=self.ping_interval,
            trace_enabled=self.trace_enabled,
            all_message_trace_enabled=self.all_message_trace_enabled,
            ping_pong_trace_enabled=self.ping_pong_trace_enabled,
            receive_buffer_size=1024,
            proxy=self.proxy,
            on_message_listener=self.run_all_message_listeners,
            on_error_listener=self.run_all_error_listeners,
            on_close_listener=self.run_all_close_listeners,
            connection_type_name=&#34;RTM&#34;,
        )
        current_session.connect()

        if old_current_session_state is not None:
            old_current_session_state.terminated = True
        if old_session is not None:
            old_session.close()

        self.current_session = current_session
        self.current_session_state = ConnectionState()
        self.auto_reconnect_enabled = self.default_auto_reconnect_enabled

        if not self.current_app_monitor_started:
            self.current_app_monitor_started = True
            self.current_app_monitor.start()

        self.logger.info(f&#34;A new session has been established (session id: {self.session_id()})&#34;)

    def disconnect(self):
        &#34;&#34;&#34;Disconnects the current session.&#34;&#34;&#34;
        self.current_session.disconnect()

    def close(self) -&gt; None:
        &#34;&#34;&#34;
        Closes this instance and cleans up underlying resources.
        After calling this method, this instance is no longer usable.
        &#34;&#34;&#34;
        self.closed = True
        self.disconnect()
        self.current_session.close()

    def start(self) -&gt; None:
        &#34;&#34;&#34;Establishes an RTM connection and blocks the current thread.&#34;&#34;&#34;
        self.connect()
        Event().wait()

    def send(self, payload: Union[dict, str]) -&gt; None:
        if payload is None:
            return
        if self.current_session is None or not self.current_session.is_active():
            raise SlackClientError(&#34;The RTM client is not connected to the Slack servers&#34;)
        if isinstance(payload, str):
            self.current_session.send(payload)
        else:
            self.current_session.send(json.dumps(payload))

    # --------------------------------------------------------------
    # WS Message Processor
    # --------------------------------------------------------------

    def enqueue_message(self, message: str):
        self.message_queue.put(message)
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;A new message enqueued (current queue size: {self.message_queue.qsize()})&#34;)

    def process_message(self):
        try:
            raw_message = self.message_queue.get(timeout=1)
            if self.logger.level &lt;= logging.DEBUG:
                self.logger.debug(f&#34;A message dequeued (current queue size: {self.message_queue.qsize()})&#34;)

            if raw_message is not None:
                message: dict = {}
                if raw_message.startswith(&#34;{&#34;):
                    message = json.loads(raw_message)

                def _run_message_listeners():
                    self.run_message_listeners(message)

                self.message_workers.submit(_run_message_listeners)
        except Empty:
            pass

    def process_messages(self) -&gt; None:
        while not self.closed:
            try:
                self.process_message()
            except Exception as e:
                self.logger.exception(f&#34;Failed to process a message: {e}&#34;)

    def run_message_listeners(self, message: dict) -&gt; None:
        type = message.get(&#34;type&#34;)
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;Message processing started (type: {type})&#34;)
        try:
            for listener in self.message_listeners:
                try:
                    listener(self, message)
                except Exception as e:
                    self.logger.exception(f&#34;Failed to run a message listener: {e}&#34;)
        except Exception as e:
            self.logger.exception(f&#34;Failed to run message listeners: {e}&#34;)
        finally:
            if self.logger.level &lt;= logging.DEBUG:
                self.logger.debug(f&#34;Message processing completed (type: {type})&#34;)

    # --------------------------------------------------------------
    # Internals
    # --------------------------------------------------------------

    def session_id(self) -&gt; Optional[str]:
        if self.current_session is not None:
            return self.current_session.session_id
        return None

    def run_all_message_listeners(self, message: str):
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;on_message invoked: (message: {message})&#34;)
        self.enqueue_message(message)
        for listener in self.on_message_listeners:
            listener(message)

    def run_all_error_listeners(self, error: Exception):
        self.logger.exception(
            f&#34;on_error invoked (session id: {self.session_id()}, &#34; f&#34;error: {type(error).__name__}, message: {error})&#34;
        )
        for listener in self.on_error_listeners:
            listener(error)

    def run_all_close_listeners(self, code: int, reason: Optional[str] = None):
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;on_close invoked (session id: {self.session_id()})&#34;)
        if self.auto_reconnect_enabled:
            self.logger.info(&#34;Received CLOSE event. Going to reconnect... &#34; f&#34;(session id: {self.session_id()})&#34;)
            self.connect_to_new_endpoint()
        for listener in self.on_close_listeners:
            listener(code, reason)

    def _run_current_session(self):
        if self.current_session is not None and self.current_session.is_active():
            session_id = self.session_id()
            try:
                self.logger.info(&#34;Starting to receive messages from a new connection&#34; f&#34; (session id: {session_id})&#34;)
                self.current_session_state.terminated = False
                self.current_session.run_until_completion(self.current_session_state)
                self.logger.info(&#34;Stopped receiving messages from a connection&#34; f&#34; (session id: {session_id})&#34;)
            except Exception as e:
                self.logger.exception(
                    &#34;Failed to start or stop the current session&#34; f&#34; (session id: {session_id}, error: {e})&#34;
                )

    def _monitor_current_session(self):
        if self.current_app_monitor_started:
            try:
                self.current_session.check_state()

                if self.auto_reconnect_enabled and (self.current_session is None or not self.current_session.is_active()):
                    self.logger.info(
                        &#34;The session seems to be already closed. Going to reconnect... &#34; f&#34;(session id: {self.session_id()})&#34;
                    )
                    self.connect_to_new_endpoint()
            except Exception as e:
                self.logger.error(
                    &#34;Failed to check the current session or reconnect to the server &#34;
                    f&#34;(session id: {self.session_id()}, error: {type(e).__name__}, message: {e})&#34;
                )</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="slack_sdk.rtm_v2.RTMClient.auto_reconnect_enabled"><code class="name">var <span class="ident">auto_reconnect_enabled</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.base_url"><code class="name">var <span class="ident">base_url</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.bot_id"><code class="name">var <span class="ident">bot_id</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.closed"><code class="name">var <span class="ident">closed</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.connect_operation_lock"><code class="name">var <span class="ident">connect_operation_lock</span> : <built-in function allocate_lock></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.current_session"><code class="name">var <span class="ident">current_session</span> : Optional[<a title="slack_sdk.socket_mode.builtin.connection.Connection" href="../socket_mode/builtin/connection.html#slack_sdk.socket_mode.builtin.connection.Connection">Connection</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.current_session_state"><code class="name">var <span class="ident">current_session_state</span> : Optional[<a title="slack_sdk.socket_mode.builtin.connection.ConnectionState" href="../socket_mode/builtin/connection.html#slack_sdk.socket_mode.builtin.connection.ConnectionState">ConnectionState</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.default_auto_reconnect_enabled"><code class="name">var <span class="ident">default_auto_reconnect_enabled</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.logger"><code class="name">var <span class="ident">logger</span> : logging.Logger</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.message_listeners"><code class="name">var <span class="ident">message_listeners</span> : List[Callable[[<a title="slack_sdk.rtm_v2.RTMClient" href="#slack_sdk.rtm_v2.RTMClient">RTMClient</a>, dict], None]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.message_processor"><code class="name">var <span class="ident">message_processor</span> : <a title="slack_sdk.socket_mode.interval_runner.IntervalRunner" href="../socket_mode/interval_runner.html#slack_sdk.socket_mode.interval_runner.IntervalRunner">IntervalRunner</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.message_queue"><code class="name">var <span class="ident">message_queue</span> : queue.Queue</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.message_workers"><code class="name">var <span class="ident">message_workers</span> : concurrent.futures.thread.ThreadPoolExecutor</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.on_close_listeners"><code class="name">var <span class="ident">on_close_listeners</span> : List[Callable[[int, Optional[str]], None]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.on_error_listeners"><code class="name">var <span class="ident">on_error_listeners</span> : List[Callable[[Exception], None]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.on_message_listeners"><code class="name">var <span class="ident">on_message_listeners</span> : List[Callable[[str], None]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.ping_interval"><code class="name">var <span class="ident">ping_interval</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.proxy"><code class="name">var <span class="ident">proxy</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.ssl"><code class="name">var <span class="ident">ssl</span> : Optional[ssl.SSLContext]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.timeout"><code class="name">var <span class="ident">timeout</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.token"><code class="name">var <span class="ident">token</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.web_client"><code class="name">var <span class="ident">web_client</span> : <a title="slack_sdk.web.client.WebClient" href="../web/client.html#slack_sdk.web.client.WebClient">WebClient</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.wss_uri"><code class="name">var <span class="ident">wss_uri</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="slack_sdk.rtm_v2.RTMClient.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Closes this instance and cleans up underlying resources.
After calling this method, this instance is no longer usable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self) -&gt; None:
    &#34;&#34;&#34;
    Closes this instance and cleans up underlying resources.
    After calling this method, this instance is no longer usable.
    &#34;&#34;&#34;
    self.closed = True
    self.disconnect()
    self.current_session.close()</code></pre>
</details>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Starts talking to the RTM server through a WebSocket connection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self):
    &#34;&#34;&#34;Starts talking to the RTM server through a WebSocket connection&#34;&#34;&#34;
    if self.bot_id is None:
        self.bot_id = self.web_client.auth_test()[&#34;bot_id&#34;]

    old_session: Optional[Connection] = self.current_session
    old_current_session_state: ConnectionState = self.current_session_state

    if self.wss_uri is None:
        self.wss_uri = self.issue_new_wss_url()

    current_session = Connection(
        url=self.wss_uri,
        logger=self.logger,
        ping_interval=self.ping_interval,
        trace_enabled=self.trace_enabled,
        all_message_trace_enabled=self.all_message_trace_enabled,
        ping_pong_trace_enabled=self.ping_pong_trace_enabled,
        receive_buffer_size=1024,
        proxy=self.proxy,
        on_message_listener=self.run_all_message_listeners,
        on_error_listener=self.run_all_error_listeners,
        on_close_listener=self.run_all_close_listeners,
        connection_type_name=&#34;RTM&#34;,
    )
    current_session.connect()

    if old_current_session_state is not None:
        old_current_session_state.terminated = True
    if old_session is not None:
        old_session.close()

    self.current_session = current_session
    self.current_session_state = ConnectionState()
    self.auto_reconnect_enabled = self.default_auto_reconnect_enabled

    if not self.current_app_monitor_started:
        self.current_app_monitor_started = True
        self.current_app_monitor.start()

    self.logger.info(f&#34;A new session has been established (session id: {self.session_id()})&#34;)</code></pre>
</details>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.connect_to_new_endpoint"><code class="name flex">
<span>def <span class="ident">connect_to_new_endpoint</span></span>(<span>self, force: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Acquires a new WSS URL and tries to connect to the endpoint.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect_to_new_endpoint(self, force: bool = False):
    &#34;&#34;&#34;Acquires a new WSS URL and tries to connect to the endpoint.&#34;&#34;&#34;
    with self.connect_operation_lock:
        if force or not self.is_connected():
            self.logger.info(&#34;Connecting to a new endpoint...&#34;)
            self.wss_uri = self.issue_new_wss_url()
            self.connect()
            self.logger.info(&#34;Connected to a new endpoint...&#34;)</code></pre>
</details>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnects the current session.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self):
    &#34;&#34;&#34;Disconnects the current session.&#34;&#34;&#34;
    self.current_session.disconnect()</code></pre>
</details>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.enqueue_message"><code class="name flex">
<span>def <span class="ident">enqueue_message</span></span>(<span>self, message: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enqueue_message(self, message: str):
    self.message_queue.put(message)
    if self.logger.level &lt;= logging.DEBUG:
        self.logger.debug(f&#34;A new message enqueued (current queue size: {self.message_queue.qsize()})&#34;)</code></pre>
</details>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if this client is connected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_connected(self) -&gt; bool:
    &#34;&#34;&#34;Returns True if this client is connected.&#34;&#34;&#34;
    return self.current_session is not None and self.current_session.is_active()</code></pre>
</details>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.issue_new_wss_url"><code class="name flex">
<span>def <span class="ident">issue_new_wss_url</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Acquires a new WSS URL using rtm.connect API method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def issue_new_wss_url(self) -&gt; str:
    &#34;&#34;&#34;Acquires a new WSS URL using rtm.connect API method&#34;&#34;&#34;
    try:
        api_response = self.web_client.rtm_connect()
        return api_response[&#34;url&#34;]
    except SlackApiError as e:
        if e.response[&#34;error&#34;] == &#34;ratelimited&#34;:
            delay = int(e.response.headers.get(&#34;Retry-After&#34;, &#34;30&#34;))  # Tier1
            self.logger.info(f&#34;Rate limited. Retrying in {delay} seconds...&#34;)
            time.sleep(delay)
            # Retry to issue a new WSS URL
            return self.issue_new_wss_url()
        else:
            # other errors
            self.logger.error(f&#34;Failed to retrieve WSS URL: {e}&#34;)
            raise e</code></pre>
</details>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.on"><code class="name flex">
<span>def <span class="ident">on</span></span>(<span>self, event_type: str) ‑> Callable</span>
</code></dt>
<dd>
<div class="desc"><p>Registers a new event listener.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event_type</code></strong></dt>
<dd>str representing an event's type (e.g., message, reaction_added)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on(self, event_type: str) -&gt; Callable:
    &#34;&#34;&#34;Registers a new event listener.

    Args:
        event_type: str representing an event&#39;s type (e.g., message, reaction_added)
    &#34;&#34;&#34;

    def __call__(*args, **kwargs):
        func = args[0]
        if func is not None:
            if isinstance(func, Callable):
                name = (
                    func.__name__
                    if hasattr(func, &#34;__name__&#34;)
                    else f&#34;{func.__class__.__module__}.{func.__class__.__name__}&#34;
                )
                inspect_result: inspect.FullArgSpec = inspect.getfullargspec(func)
                if inspect_result is not None and len(inspect_result.args) != 2:
                    actual_args = &#34;, &#34;.join(inspect_result.args)
                    error = f&#34;The listener &#39;{name}&#39; must accept two args: client, event (actual: {actual_args})&#34;
                    raise SlackClientError(error)

                def new_message_listener(_self, event: dict):
                    actual_event_type = event.get(&#34;type&#34;)
                    if event.get(&#34;bot_id&#34;) == self.bot_id:
                        # SKip the events generated by this bot user
                        return
                    # https://github.com/slackapi/python-slack-sdk/issues/533
                    if event_type == &#34;*&#34; or (actual_event_type is not None and actual_event_type == event_type):
                        func(_self, event)

                self.message_listeners.append(new_message_listener)
            else:
                error = f&#34;The listener &#39;{func}&#39; is not a Callable (actual: {type(func).__name__})&#34;
                raise SlackClientError(error)
        # Not to cause modification to the decorated method
        return func

    return __call__</code></pre>
</details>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.process_message"><code class="name flex">
<span>def <span class="ident">process_message</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_message(self):
    try:
        raw_message = self.message_queue.get(timeout=1)
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;A message dequeued (current queue size: {self.message_queue.qsize()})&#34;)

        if raw_message is not None:
            message: dict = {}
            if raw_message.startswith(&#34;{&#34;):
                message = json.loads(raw_message)

            def _run_message_listeners():
                self.run_message_listeners(message)

            self.message_workers.submit(_run_message_listeners)
    except Empty:
        pass</code></pre>
</details>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.process_messages"><code class="name flex">
<span>def <span class="ident">process_messages</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_messages(self) -&gt; None:
    while not self.closed:
        try:
            self.process_message()
        except Exception as e:
            self.logger.exception(f&#34;Failed to process a message: {e}&#34;)</code></pre>
</details>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.run_all_close_listeners"><code class="name flex">
<span>def <span class="ident">run_all_close_listeners</span></span>(<span>self, code: int, reason: Optional[str] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_all_close_listeners(self, code: int, reason: Optional[str] = None):
    if self.logger.level &lt;= logging.DEBUG:
        self.logger.debug(f&#34;on_close invoked (session id: {self.session_id()})&#34;)
    if self.auto_reconnect_enabled:
        self.logger.info(&#34;Received CLOSE event. Going to reconnect... &#34; f&#34;(session id: {self.session_id()})&#34;)
        self.connect_to_new_endpoint()
    for listener in self.on_close_listeners:
        listener(code, reason)</code></pre>
</details>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.run_all_error_listeners"><code class="name flex">
<span>def <span class="ident">run_all_error_listeners</span></span>(<span>self, error: Exception)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_all_error_listeners(self, error: Exception):
    self.logger.exception(
        f&#34;on_error invoked (session id: {self.session_id()}, &#34; f&#34;error: {type(error).__name__}, message: {error})&#34;
    )
    for listener in self.on_error_listeners:
        listener(error)</code></pre>
</details>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.run_all_message_listeners"><code class="name flex">
<span>def <span class="ident">run_all_message_listeners</span></span>(<span>self, message: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_all_message_listeners(self, message: str):
    if self.logger.level &lt;= logging.DEBUG:
        self.logger.debug(f&#34;on_message invoked: (message: {message})&#34;)
    self.enqueue_message(message)
    for listener in self.on_message_listeners:
        listener(message)</code></pre>
</details>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.run_message_listeners"><code class="name flex">
<span>def <span class="ident">run_message_listeners</span></span>(<span>self, message: dict) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_message_listeners(self, message: dict) -&gt; None:
    type = message.get(&#34;type&#34;)
    if self.logger.level &lt;= logging.DEBUG:
        self.logger.debug(f&#34;Message processing started (type: {type})&#34;)
    try:
        for listener in self.message_listeners:
            try:
                listener(self, message)
            except Exception as e:
                self.logger.exception(f&#34;Failed to run a message listener: {e}&#34;)
    except Exception as e:
        self.logger.exception(f&#34;Failed to run message listeners: {e}&#34;)
    finally:
        if self.logger.level &lt;= logging.DEBUG:
            self.logger.debug(f&#34;Message processing completed (type: {type})&#34;)</code></pre>
</details>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.send"><code class="name flex">
<span>def <span class="ident">send</span></span>(<span>self, payload: Union[dict, str]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send(self, payload: Union[dict, str]) -&gt; None:
    if payload is None:
        return
    if self.current_session is None or not self.current_session.is_active():
        raise SlackClientError(&#34;The RTM client is not connected to the Slack servers&#34;)
    if isinstance(payload, str):
        self.current_session.send(payload)
    else:
        self.current_session.send(json.dumps(payload))</code></pre>
</details>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.session_id"><code class="name flex">
<span>def <span class="ident">session_id</span></span>(<span>self) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def session_id(self) -&gt; Optional[str]:
    if self.current_session is not None:
        return self.current_session.session_id
    return None</code></pre>
</details>
</dd>
<dt id="slack_sdk.rtm_v2.RTMClient.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Establishes an RTM connection and blocks the current thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self) -&gt; None:
    &#34;&#34;&#34;Establishes an RTM connection and blocks the current thread.&#34;&#34;&#34;
    self.connect()
    Event().wait()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="slack_sdk" href="../index.html">slack_sdk</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="slack_sdk.rtm_v2.RTMClient" href="#slack_sdk.rtm_v2.RTMClient">RTMClient</a></code></h4>
<ul class="">
<li><code><a title="slack_sdk.rtm_v2.RTMClient.auto_reconnect_enabled" href="#slack_sdk.rtm_v2.RTMClient.auto_reconnect_enabled">auto_reconnect_enabled</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.base_url" href="#slack_sdk.rtm_v2.RTMClient.base_url">base_url</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.bot_id" href="#slack_sdk.rtm_v2.RTMClient.bot_id">bot_id</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.close" href="#slack_sdk.rtm_v2.RTMClient.close">close</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.closed" href="#slack_sdk.rtm_v2.RTMClient.closed">closed</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.connect" href="#slack_sdk.rtm_v2.RTMClient.connect">connect</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.connect_operation_lock" href="#slack_sdk.rtm_v2.RTMClient.connect_operation_lock">connect_operation_lock</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.connect_to_new_endpoint" href="#slack_sdk.rtm_v2.RTMClient.connect_to_new_endpoint">connect_to_new_endpoint</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.current_session" href="#slack_sdk.rtm_v2.RTMClient.current_session">current_session</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.current_session_state" href="#slack_sdk.rtm_v2.RTMClient.current_session_state">current_session_state</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.default_auto_reconnect_enabled" href="#slack_sdk.rtm_v2.RTMClient.default_auto_reconnect_enabled">default_auto_reconnect_enabled</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.disconnect" href="#slack_sdk.rtm_v2.RTMClient.disconnect">disconnect</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.enqueue_message" href="#slack_sdk.rtm_v2.RTMClient.enqueue_message">enqueue_message</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.is_connected" href="#slack_sdk.rtm_v2.RTMClient.is_connected">is_connected</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.issue_new_wss_url" href="#slack_sdk.rtm_v2.RTMClient.issue_new_wss_url">issue_new_wss_url</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.logger" href="#slack_sdk.rtm_v2.RTMClient.logger">logger</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.message_listeners" href="#slack_sdk.rtm_v2.RTMClient.message_listeners">message_listeners</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.message_processor" href="#slack_sdk.rtm_v2.RTMClient.message_processor">message_processor</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.message_queue" href="#slack_sdk.rtm_v2.RTMClient.message_queue">message_queue</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.message_workers" href="#slack_sdk.rtm_v2.RTMClient.message_workers">message_workers</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.on" href="#slack_sdk.rtm_v2.RTMClient.on">on</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.on_close_listeners" href="#slack_sdk.rtm_v2.RTMClient.on_close_listeners">on_close_listeners</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.on_error_listeners" href="#slack_sdk.rtm_v2.RTMClient.on_error_listeners">on_error_listeners</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.on_message_listeners" href="#slack_sdk.rtm_v2.RTMClient.on_message_listeners">on_message_listeners</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.ping_interval" href="#slack_sdk.rtm_v2.RTMClient.ping_interval">ping_interval</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.process_message" href="#slack_sdk.rtm_v2.RTMClient.process_message">process_message</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.process_messages" href="#slack_sdk.rtm_v2.RTMClient.process_messages">process_messages</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.proxy" href="#slack_sdk.rtm_v2.RTMClient.proxy">proxy</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.run_all_close_listeners" href="#slack_sdk.rtm_v2.RTMClient.run_all_close_listeners">run_all_close_listeners</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.run_all_error_listeners" href="#slack_sdk.rtm_v2.RTMClient.run_all_error_listeners">run_all_error_listeners</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.run_all_message_listeners" href="#slack_sdk.rtm_v2.RTMClient.run_all_message_listeners">run_all_message_listeners</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.run_message_listeners" href="#slack_sdk.rtm_v2.RTMClient.run_message_listeners">run_message_listeners</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.send" href="#slack_sdk.rtm_v2.RTMClient.send">send</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.session_id" href="#slack_sdk.rtm_v2.RTMClient.session_id">session_id</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.ssl" href="#slack_sdk.rtm_v2.RTMClient.ssl">ssl</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.start" href="#slack_sdk.rtm_v2.RTMClient.start">start</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.timeout" href="#slack_sdk.rtm_v2.RTMClient.timeout">timeout</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.token" href="#slack_sdk.rtm_v2.RTMClient.token">token</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.web_client" href="#slack_sdk.rtm_v2.RTMClient.web_client">web_client</a></code></li>
<li><code><a title="slack_sdk.rtm_v2.RTMClient.wss_uri" href="#slack_sdk.rtm_v2.RTMClient.wss_uri">wss_uri</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>